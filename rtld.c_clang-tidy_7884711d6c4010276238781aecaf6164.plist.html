<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"5": {"id": 5, "path": "/media/lavo07/lavo07/glibc/elf/do-rel.h", "content": "/* Do relocations for ELF dynamic linking.\n   Copyright (C) 1995-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n/* This file may be included twice, to define both\n   `elf_dynamic_do_rel' and `elf_dynamic_do_rela'.  */\n\n#ifdef DO_RELA\n# define elf_dynamic_do_Rel\t\telf_dynamic_do_Rela\n# define Rel\t\t\t\tRela\n# define elf_machine_rel\t\telf_machine_rela\n# define elf_machine_rel_relative\telf_machine_rela_relative\n#endif\n\n#ifndef DO_ELF_MACHINE_REL_RELATIVE\n# define DO_ELF_MACHINE_REL_RELATIVE(map, l_addr, relative) \\\n  elf_machine_rel_relative (l_addr, relative,\t\t\t\t      \\\n\t\t\t    (void *) (l_addr + relative->r_offset))\n#endif\n\n/* Perform the relocations in MAP on the running program image as specified\n   by RELTAG, SZTAG.  If LAZY is nonzero, this is the first pass on PLT\n   relocations; they should be set up to call _dl_runtime_resolve, rather\n   than fully resolved now.  */\n\nauto inline void __attribute__ ((always_inline))\nelf_dynamic_do_Rel (struct link_map *map,\n\t\t    ElfW(Addr) reladdr, ElfW(Addr) relsize,\n\t\t    __typeof (((ElfW(Dyn) *) 0)->d_un.d_val) nrelative,\n\t\t    int lazy, int skip_ifunc)\n{\n  const ElfW(Rel) *r = (const void *) reladdr;\n  const ElfW(Rel) *end = (const void *) (reladdr + relsize);\n  ElfW(Addr) l_addr = map->l_addr;\n# if defined ELF_MACHINE_IRELATIVE && !defined RTLD_BOOTSTRAP\n  const ElfW(Rel) *r2 = NULL;\n  const ElfW(Rel) *end2 = NULL;\n# endif\n\n#if (!defined DO_RELA || !defined ELF_MACHINE_PLT_REL) && !defined RTLD_BOOTSTRAP\n  /* We never bind lazily during ld.so bootstrap.  Unfortunately gcc is\n     not clever enough to see through all the function calls to realize\n     that.  */\n  if (lazy)\n    {\n      /* Doing lazy PLT relocations; they need very little info.  */\n      for (; r < end; ++r)\n# ifdef ELF_MACHINE_IRELATIVE\n\tif (ELFW(R_TYPE) (r->r_info) == ELF_MACHINE_IRELATIVE)\n\t  {\n\t    if (r2 == NULL)\n\t      r2 = r;\n\t    end2 = r;\n\t  }\n\telse\n# endif\n\t  elf_machine_lazy_rel (map, l_addr, r, skip_ifunc);\n\n# ifdef ELF_MACHINE_IRELATIVE\n      if (r2 != NULL)\n\tfor (; r2 <= end2; ++r2)\n\t  if (ELFW(R_TYPE) (r2->r_info) == ELF_MACHINE_IRELATIVE)\n\t    elf_machine_lazy_rel (map, l_addr, r2, skip_ifunc);\n# endif\n    }\n  else\n#endif\n    {\n      const ElfW(Sym) *const symtab =\n\t(const void *) D_PTR (map, l_info[DT_SYMTAB]);\n      const ElfW(Rel) *relative = r;\n      r += nrelative;\n\n#ifndef RTLD_BOOTSTRAP\n      /* This is defined in rtld.c, but nowhere in the static libc.a; make\n\t the reference weak so static programs can still link.  This\n\t declaration cannot be done when compiling rtld.c (i.e. #ifdef\n\t RTLD_BOOTSTRAP) because rtld.c contains the common defn for\n\t _dl_rtld_map, which is incompatible with a weak decl in the same\n\t file.  */\n# ifndef SHARED\n      weak_extern (GL(dl_rtld_map));\n# endif\n      if (map != &GL(dl_rtld_map)) /* Already done in rtld itself.  */\n# if !defined DO_RELA || defined ELF_MACHINE_REL_RELATIVE\n\t/* Rela platforms get the offset from r_addend and this must\n\t   be copied in the relocation address.  Therefore we can skip\n\t   the relative relocations only if this is for rel\n\t   relocations or rela relocations if they are computed as\n\t   memory_loc += l_addr...  */\n\tif (l_addr != 0)\n# else\n\t/* ...or we know the object has been prelinked.  */\n\tif (l_addr != 0 || ! map->l_info[VALIDX(DT_GNU_PRELINKED)])\n# endif\n#endif\n\t  for (; relative < r; ++relative)\n\t    DO_ELF_MACHINE_REL_RELATIVE (map, l_addr, relative);\n\n#ifdef RTLD_BOOTSTRAP\n      /* The dynamic linker always uses versioning.  */\n      assert (map->l_info[VERSYMIDX (DT_VERSYM)] != NULL);\n#else\n      if (map->l_info[VERSYMIDX (DT_VERSYM)])\n#endif\n\t{\n\t  const ElfW(Half) *const version =\n\t    (const void *) D_PTR (map, l_info[VERSYMIDX (DT_VERSYM)]);\n\n\t  for (; r < end; ++r)\n\t    {\n#if defined ELF_MACHINE_IRELATIVE && !defined RTLD_BOOTSTRAP\n\t      if (ELFW(R_TYPE) (r->r_info) == ELF_MACHINE_IRELATIVE)\n\t\t{\n\t\t  if (r2 == NULL)\n\t\t    r2 = r;\n\t\t  end2 = r;\n\t\t  continue;\n\t\t}\n#endif\n\n\t      ElfW(Half) ndx = version[ELFW(R_SYM) (r->r_info)] & 0x7fff;\n\t      elf_machine_rel (map, r, &symtab[ELFW(R_SYM) (r->r_info)],\n\t\t\t       &map->l_versions[ndx],\n\t\t\t       (void *) (l_addr + r->r_offset), skip_ifunc);\n\t    }\n\n#if defined ELF_MACHINE_IRELATIVE && !defined RTLD_BOOTSTRAP\n\t  if (r2 != NULL)\n\t    for (; r2 <= end2; ++r2)\n\t      if (ELFW(R_TYPE) (r2->r_info) == ELF_MACHINE_IRELATIVE)\n\t\t{\n\t\t  ElfW(Half) ndx\n\t\t    = version[ELFW(R_SYM) (r2->r_info)] & 0x7fff;\n\t\t  elf_machine_rel (map, r2,\n\t\t\t\t   &symtab[ELFW(R_SYM) (r2->r_info)],\n\t\t\t\t   &map->l_versions[ndx],\n\t\t\t\t   (void *) (l_addr + r2->r_offset),\n\t\t\t\t   skip_ifunc);\n\t\t}\n#endif\n\t}\n#ifndef RTLD_BOOTSTRAP\n      else\n\t{\n\t  for (; r < end; ++r)\n# ifdef ELF_MACHINE_IRELATIVE\n\t    if (ELFW(R_TYPE) (r->r_info) == ELF_MACHINE_IRELATIVE)\n\t      {\n\t\tif (r2 == NULL)\n\t\t  r2 = r;\n\t\tend2 = r;\n\t      }\n\t    else\n# endif\n\t      elf_machine_rel (map, r, &symtab[ELFW(R_SYM) (r->r_info)], NULL,\n\t\t\t       (void *) (l_addr + r->r_offset), skip_ifunc);\n\n# ifdef ELF_MACHINE_IRELATIVE\n\t  if (r2 != NULL)\n\t    for (; r2 <= end2; ++r2)\n\t      if (ELFW(R_TYPE) (r2->r_info) == ELF_MACHINE_IRELATIVE)\n\t\telf_machine_rel (map, r2, &symtab[ELFW(R_SYM) (r2->r_info)],\n\t\t\t\t NULL, (void *) (l_addr + r2->r_offset),\n\t\t\t\t skip_ifunc);\n# endif\n\t}\n#endif\n    }\n}\n\n#undef elf_dynamic_do_Rel\n#undef Rel\n#undef elf_machine_rel\n#undef elf_machine_rel_relative\n#undef DO_ELF_MACHINE_REL_RELATIVE\n#undef DO_RELA\n"}, "6": {"id": 6, "path": "/media/lavo07/lavo07/glibc/elf/dynamic-link.h", "content": "/* Inline functions for dynamic linking.\n   Copyright (C) 1995-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n/* This macro is used as a callback from elf_machine_rel{a,} when a\n   static TLS reloc is about to be performed.  Since (in dl-load.c) we\n   permit dynamic loading of objects that might use such relocs, we\n   have to check whether each use is actually doable.  If the object\n   whose TLS segment the reference resolves to was allocated space in\n   the static TLS block at startup, then it's ok.  Otherwise, we make\n   an attempt to allocate it in surplus space on the fly.  If that\n   can't be done, we fall back to the error that DF_STATIC_TLS is\n   intended to produce.  */\n#define HAVE_STATIC_TLS(map, sym_map)\t\t\t\t\t\\\n    (__builtin_expect ((sym_map)->l_tls_offset != NO_TLS_OFFSET\t\t\\\n\t\t       && ((sym_map)->l_tls_offset\t\t\t\\\n\t\t\t   != FORCED_DYNAMIC_TLS_OFFSET), 1))\n\n#define CHECK_STATIC_TLS(map, sym_map)\t\t\t\t\t\\\n    do {\t\t\t\t\t\t\t\t\\\n      if (!HAVE_STATIC_TLS (map, sym_map))\t\t\t\t\\\n\t_dl_allocate_static_tls (sym_map);\t\t\t\t\\\n    } while (0)\n\n#define TRY_STATIC_TLS(map, sym_map)\t\t\t\t\t\\\n    (__builtin_expect ((sym_map)->l_tls_offset\t\t\t\t\\\n\t\t       != FORCED_DYNAMIC_TLS_OFFSET, 1)\t\t\t\\\n     && (__builtin_expect ((sym_map)->l_tls_offset != NO_TLS_OFFSET, 1)\t\\\n\t || _dl_try_allocate_static_tls (sym_map) == 0))\n\nint _dl_try_allocate_static_tls (struct link_map *map) attribute_hidden;\n\n#include <elf.h>\n\n#ifdef RESOLVE_MAP\n/* We pass reloc_addr as a pointer to void, as opposed to a pointer to\n   ElfW(Addr), because not all architectures can assume that the\n   relocated address is properly aligned, whereas the compiler is\n   entitled to assume that a pointer to a type is properly aligned for\n   the type.  Even if we cast the pointer back to some other type with\n   less strict alignment requirements, the compiler might still\n   remember that the pointer was originally more aligned, thereby\n   optimizing away alignment tests or using word instructions for\n   copying memory, breaking the very code written to handle the\n   unaligned cases.  */\n# if ! ELF_MACHINE_NO_REL\nauto inline void __attribute__((always_inline))\nelf_machine_rel (struct link_map *map, const ElfW(Rel) *reloc,\n\t\t const ElfW(Sym) *sym, const struct r_found_version *version,\n\t\t void *const reloc_addr, int skip_ifunc);\nauto inline void __attribute__((always_inline))\nelf_machine_rel_relative (ElfW(Addr) l_addr, const ElfW(Rel) *reloc,\n\t\t\t  void *const reloc_addr);\n# endif\n# if ! ELF_MACHINE_NO_RELA\nauto inline void __attribute__((always_inline))\nelf_machine_rela (struct link_map *map, const ElfW(Rela) *reloc,\n\t\t  const ElfW(Sym) *sym, const struct r_found_version *version,\n\t\t  void *const reloc_addr, int skip_ifunc);\nauto inline void __attribute__((always_inline))\nelf_machine_rela_relative (ElfW(Addr) l_addr, const ElfW(Rela) *reloc,\n\t\t\t   void *const reloc_addr);\n# endif\n# if ELF_MACHINE_NO_RELA || defined ELF_MACHINE_PLT_REL\nauto inline void __attribute__((always_inline))\nelf_machine_lazy_rel (struct link_map *map,\n\t\t      ElfW(Addr) l_addr, const ElfW(Rel) *reloc,\n\t\t      int skip_ifunc);\n# else\nauto inline void __attribute__((always_inline))\nelf_machine_lazy_rel (struct link_map *map,\n\t\t      ElfW(Addr) l_addr, const ElfW(Rela) *reloc,\n\t\t      int skip_ifunc);\n# endif\n#endif\n\n#include <dl-machine.h>\n\n#include \"get-dynamic-info.h\"\n\n#ifdef RESOLVE_MAP\n\n# if defined RTLD_BOOTSTRAP || defined STATIC_PIE_BOOTSTRAP\n#  define ELF_DURING_STARTUP (1)\n# else\n#  define ELF_DURING_STARTUP (0)\n# endif\n\n/* Get the definitions of `elf_dynamic_do_rel' and `elf_dynamic_do_rela'.\n   These functions are almost identical, so we use cpp magic to avoid\n   duplicating their code.  It cannot be done in a more general function\n   because we must be able to completely inline.  */\n\n/* On some machines, notably SPARC, DT_REL* includes DT_JMPREL in its\n   range.  Note that according to the ELF spec, this is completely legal!\n\n   We are guarenteed that we have one of three situations.  Either DT_JMPREL\n   comes immediately after DT_REL*, or there is overlap and DT_JMPREL\n   consumes precisely the very end of the DT_REL*, or DT_JMPREL and DT_REL*\n   are completely separate and there is a gap between them.  */\n\n# define _ELF_DYNAMIC_DO_RELOC(RELOC, reloc, map, do_lazy, skip_ifunc, test_rel) \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    struct { ElfW(Addr) start, size;\t\t\t\t\t      \\\n\t     __typeof (((ElfW(Dyn) *) 0)->d_un.d_val) nrelative; int lazy; }  \\\n      ranges[2] = { { 0, 0, 0, 0 }, { 0, 0, 0, 0 } };\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n    if ((map)->l_info[DT_##RELOC])\t\t\t\t\t      \\\n      {\t\t\t\t\t\t\t\t\t      \\\n\tranges[0].start = D_PTR ((map), l_info[DT_##RELOC]);\t\t      \\\n\tranges[0].size = (map)->l_info[DT_##RELOC##SZ]->d_un.d_val;\t      \\\n\tif (map->l_info[VERSYMIDX (DT_##RELOC##COUNT)] != NULL)\t\t      \\\n\t  ranges[0].nrelative\t\t\t\t\t\t      \\\n\t    = map->l_info[VERSYMIDX (DT_##RELOC##COUNT)]->d_un.d_val;\t      \\\n      }\t\t\t\t\t\t\t\t\t      \\\n    if ((map)->l_info[DT_PLTREL]\t\t\t\t\t      \\\n\t&& (!test_rel || (map)->l_info[DT_PLTREL]->d_un.d_val == DT_##RELOC)) \\\n      {\t\t\t\t\t\t\t\t\t      \\\n\tElfW(Addr) start = D_PTR ((map), l_info[DT_JMPREL]);\t\t      \\\n\tElfW(Addr) size = (map)->l_info[DT_PLTRELSZ]->d_un.d_val;\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\tif (ranges[0].start + ranges[0].size == (start + size))\t\t      \\\n\t  ranges[0].size -= size;\t\t\t\t\t      \\\n\tif (ELF_DURING_STARTUP\t\t\t\t\t\t      \\\n\t    || (!(do_lazy)\t\t\t\t\t\t      \\\n\t\t&& (ranges[0].start + ranges[0].size) == start))\t      \\\n\t  {\t\t\t\t\t\t\t\t      \\\n\t    /* Combine processing the sections.  */\t\t\t      \\\n\t    ranges[0].size += size;\t\t\t\t\t      \\\n\t  }\t\t\t\t\t\t\t\t      \\\n\telse\t\t\t\t\t\t\t\t      \\\n\t  {\t\t\t\t\t\t\t\t      \\\n\t    ranges[1].start = start;\t\t\t\t\t      \\\n\t    ranges[1].size = size;\t\t\t\t\t      \\\n\t    ranges[1].lazy = (do_lazy);\t\t\t\t\t      \\\n\t  }\t\t\t\t\t\t\t\t      \\\n      }\t\t\t\t\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n    if (ELF_DURING_STARTUP)\t\t\t\t\t\t      \\\n      elf_dynamic_do_##reloc ((map), ranges[0].start, ranges[0].size,\t      \\\n\t\t\t      ranges[0].nrelative, 0, skip_ifunc);\t      \\\n    else\t\t\t\t\t\t\t\t      \\\n      {\t\t\t\t\t\t\t\t\t      \\\n\tint ranges_index;\t\t\t\t\t\t      \\\n\tfor (ranges_index = 0; ranges_index < 2; ++ranges_index)\t      \\\n\t  elf_dynamic_do_##reloc ((map),\t\t\t\t      \\\n\t\t\t\t  ranges[ranges_index].start,\t\t      \\\n\t\t\t\t  ranges[ranges_index].size,\t\t      \\\n\t\t\t\t  ranges[ranges_index].nrelative,\t      \\\n\t\t\t\t  ranges[ranges_index].lazy,\t\t      \\\n\t\t\t\t  skip_ifunc);\t\t\t\t      \\\n      }\t\t\t\t\t\t\t\t\t      \\\n  } while (0)\n\n# if ELF_MACHINE_NO_REL || ELF_MACHINE_NO_RELA\n#  define _ELF_CHECK_REL 0\n# else\n#  define _ELF_CHECK_REL 1\n# endif\n\n# if ! ELF_MACHINE_NO_REL\n#  include \"do-rel.h\"\n#  define ELF_DYNAMIC_DO_REL(map, lazy, skip_ifunc) \\\n  _ELF_DYNAMIC_DO_RELOC (REL, Rel, map, lazy, skip_ifunc, _ELF_CHECK_REL)\n# else\n#  define ELF_DYNAMIC_DO_REL(map, lazy, skip_ifunc) /* Nothing to do.  */\n# endif\n\n# if ! ELF_MACHINE_NO_RELA\n#  define DO_RELA\n#  include \"do-rel.h\"\n#  define ELF_DYNAMIC_DO_RELA(map, lazy, skip_ifunc) \\\n  _ELF_DYNAMIC_DO_RELOC (RELA, Rela, map, lazy, skip_ifunc, _ELF_CHECK_REL)\n# else\n#  define ELF_DYNAMIC_DO_RELA(map, lazy, skip_ifunc) /* Nothing to do.  */\n# endif\n\n/* This can't just be an inline function because GCC is too dumb\n   to inline functions containing inlines themselves.  */\n# define ELF_DYNAMIC_RELOCATE(map, lazy, consider_profile, skip_ifunc) \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    int edr_lazy = elf_machine_runtime_setup ((map), (lazy),\t\t      \\\n\t\t\t\t\t      (consider_profile));\t      \\\n    ELF_DYNAMIC_DO_REL ((map), edr_lazy, skip_ifunc);\t\t\t      \\\n    ELF_DYNAMIC_DO_RELA ((map), edr_lazy, skip_ifunc);\t\t\t      \\\n  } while (0)\n\n#endif\n"}, "7": {"id": 7, "path": "/media/lavo07/lavo07/glibc/elf/get-dynamic-info.h", "content": "/* Read the dynamic section at DYN and fill in INFO with indices DT_*.\n   Copyright (C) 2012-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n/* This file is included multiple times and therefore lacks a header\n   file inclusion guard.  */\n\n#include <assert.h>\n#include <libc-diag.h>\n\n#ifndef RESOLVE_MAP\nstatic\n#else\nauto\n#endif\ninline void __attribute__ ((unused, always_inline))\nelf_get_dynamic_info (struct link_map *l, ElfW(Dyn) *temp)\n{\n  ElfW(Dyn) *dyn = l->l_ld;\n  ElfW(Dyn) **info;\n#if __ELF_NATIVE_CLASS == 32\n  typedef Elf32_Word d_tag_utype;\n#elif __ELF_NATIVE_CLASS == 64\n  typedef Elf64_Xword d_tag_utype;\n#endif\n\n#if !defined RTLD_BOOTSTRAP && !defined STATIC_PIE_BOOTSTRAP\n  if (dyn == NULL)\n    return;\n#endif\n\n  info = l->l_info;\n\n  while (dyn->d_tag != DT_NULL)\n    {\n      if ((d_tag_utype) dyn->d_tag < DT_NUM)\n\tinfo[dyn->d_tag] = dyn;\n      else if (dyn->d_tag >= DT_LOPROC &&\n\t       dyn->d_tag < DT_LOPROC + DT_THISPROCNUM)\n\t{\n\t  /* This does not violate the array bounds of l->l_info, but\n\t     gcc 4.6 on sparc somehow does not see this.  */\n\t  DIAG_PUSH_NEEDS_COMMENT;\n\t  DIAG_IGNORE_NEEDS_COMMENT (4.6,\n\t\t\t\t     \"-Warray-bounds\");\n\t  info[dyn->d_tag - DT_LOPROC + DT_NUM] = dyn;\n\t  DIAG_POP_NEEDS_COMMENT;\n\t}\n      else if ((d_tag_utype) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)\n\tinfo[VERSYMIDX (dyn->d_tag)] = dyn;\n      else if ((d_tag_utype) DT_EXTRATAGIDX (dyn->d_tag) < DT_EXTRANUM)\n\tinfo[DT_EXTRATAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM\n\t     + DT_VERSIONTAGNUM] = dyn;\n      else if ((d_tag_utype) DT_VALTAGIDX (dyn->d_tag) < DT_VALNUM)\n\tinfo[DT_VALTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM\n\t     + DT_VERSIONTAGNUM + DT_EXTRANUM] = dyn;\n      else if ((d_tag_utype) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)\n\tinfo[DT_ADDRTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM\n\t     + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn;\n      ++dyn;\n    }\n\n#define DL_RO_DYN_TEMP_CNT\t8\n\n#ifndef DL_RO_DYN_SECTION\n  /* Don't adjust .dynamic unnecessarily.  */\n  if (l->l_addr != 0)\n    {\n      ElfW(Addr) l_addr = l->l_addr;\n      int cnt = 0;\n\n# define ADJUST_DYN_INFO(tag) \\\n      do\t\t\t\t\t\t\t\t      \\\n\tif (info[tag] != NULL)\t\t\t\t\t\t      \\\n\t  {\t\t\t\t\t\t\t\t      \\\n\t    if (temp)\t\t\t\t\t\t\t      \\\n\t      {\t\t\t\t\t\t\t\t      \\\n\t\ttemp[cnt].d_tag = info[tag]->d_tag;\t\t\t      \\\n\t\ttemp[cnt].d_un.d_ptr = info[tag]->d_un.d_ptr + l_addr;\t      \\\n\t\tinfo[tag] = temp + cnt++;\t\t\t\t      \\\n\t      }\t\t\t\t\t\t\t\t      \\\n\t    else\t\t\t\t\t\t\t      \\\n\t      info[tag]->d_un.d_ptr += l_addr;\t\t\t\t      \\\n\t  }\t\t\t\t\t\t\t\t      \\\n      while (0)\n\n      ADJUST_DYN_INFO (DT_HASH);\n      ADJUST_DYN_INFO (DT_PLTGOT);\n      ADJUST_DYN_INFO (DT_STRTAB);\n      ADJUST_DYN_INFO (DT_SYMTAB);\n# if ! ELF_MACHINE_NO_RELA\n      ADJUST_DYN_INFO (DT_RELA);\n# endif\n# if ! ELF_MACHINE_NO_REL\n      ADJUST_DYN_INFO (DT_REL);\n# endif\n      ADJUST_DYN_INFO (DT_JMPREL);\n      ADJUST_DYN_INFO (VERSYMIDX (DT_VERSYM));\n      ADJUST_DYN_INFO (ADDRIDX (DT_GNU_HASH));\n# undef ADJUST_DYN_INFO\n      assert (cnt <= DL_RO_DYN_TEMP_CNT);\n    }\n#endif\n  if (info[DT_PLTREL] != NULL)\n    {\n#if ELF_MACHINE_NO_RELA\n      assert (info[DT_PLTREL]->d_un.d_val == DT_REL);\n#elif ELF_MACHINE_NO_REL\n      assert (info[DT_PLTREL]->d_un.d_val == DT_RELA);\n#else\n      assert (info[DT_PLTREL]->d_un.d_val == DT_REL\n\t      || info[DT_PLTREL]->d_un.d_val == DT_RELA);\n#endif\n    }\n#if ! ELF_MACHINE_NO_RELA\n  if (info[DT_RELA] != NULL)\n    assert (info[DT_RELAENT]->d_un.d_val == sizeof (ElfW(Rela)));\n# endif\n# if ! ELF_MACHINE_NO_REL\n  if (info[DT_REL] != NULL)\n    assert (info[DT_RELENT]->d_un.d_val == sizeof (ElfW(Rel)));\n#endif\n#ifdef RTLD_BOOTSTRAP\n  /* Only the bind now flags are allowed.  */\n  assert (info[VERSYMIDX (DT_FLAGS_1)] == NULL\n\t  || (info[VERSYMIDX (DT_FLAGS_1)]->d_un.d_val & ~DF_1_NOW) == 0);\n  /* Flags must not be set for ld.so.  */\n  assert (info[DT_FLAGS] == NULL\n\t  || (info[DT_FLAGS]->d_un.d_val & ~DF_BIND_NOW) == 0);\n#endif\n#if defined RTLD_BOOTSTRAP || defined STATIC_PIE_BOOTSTRAP\n  assert (info[DT_RUNPATH] == NULL);\n  assert (info[DT_RPATH] == NULL);\n#else\n  if (info[DT_FLAGS] != NULL)\n    {\n      /* Flags are used.  Translate to the old form where available.\n\t Since these l_info entries are only tested for NULL pointers it\n\t is ok if they point to the DT_FLAGS entry.  */\n      l->l_flags = info[DT_FLAGS]->d_un.d_val;\n\n      if (l->l_flags & DF_SYMBOLIC)\n\tinfo[DT_SYMBOLIC] = info[DT_FLAGS];\n      if (l->l_flags & DF_TEXTREL)\n\tinfo[DT_TEXTREL] = info[DT_FLAGS];\n      if (l->l_flags & DF_BIND_NOW)\n\tinfo[DT_BIND_NOW] = info[DT_FLAGS];\n    }\n  if (info[VERSYMIDX (DT_FLAGS_1)] != NULL)\n    {\n      l->l_flags_1 = info[VERSYMIDX (DT_FLAGS_1)]->d_un.d_val;\n\n      /* Only DT_1_SUPPORTED_MASK bits are supported, and we would like\n\t to assert this, but we can't. Users have been setting\n\t unsupported DF_1_* flags for a long time and glibc has ignored\n\t them. Therefore to avoid breaking existing applications the\n\t best we can do is add a warning during debugging with the\n\t intent of notifying the user of the problem.  */\n      if (__builtin_expect (GLRO(dl_debug_mask) & DL_DEBUG_FILES, 0)\n\t  && l->l_flags_1 & ~DT_1_SUPPORTED_MASK)\n\t_dl_debug_printf (\"\\nWARNING: Unsupported flag value(s) of 0x%x in DT_FLAGS_1.\\n\",\n\t\t\t  l->l_flags_1 & ~DT_1_SUPPORTED_MASK);\n\n      if (l->l_flags_1 & DF_1_NOW)\n\tinfo[DT_BIND_NOW] = info[VERSYMIDX (DT_FLAGS_1)];\n    }\n  if (info[DT_RUNPATH] != NULL)\n    /* If both RUNPATH and RPATH are given, the latter is ignored.  */\n    info[DT_RPATH] = NULL;\n#endif\n}\n"}, "8": {"id": 8, "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "content": "/* Run time dynamic linker.\n   Copyright (C) 1995-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n#include <errno.h>\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <sys/param.h>\n#include <sys/stat.h>\n#include <ldsodefs.h>\n#include <_itoa.h>\n#include <entry.h>\n#include <fpu_control.h>\n#include <hp-timing.h>\n#include <libc-lock.h>\n#include \"dynamic-link.h\"\n#include <dl-librecon.h>\n#include <unsecvars.h>\n#include <dl-cache.h>\n#include <dl-osinfo.h>\n#include <dl-procinfo.h>\n#include <dl-prop.h>\n#include <tls.h>\n#include <stap-probe.h>\n#include <stackinfo.h>\n#include <not-cancel.h>\n\n#include <assert.h>\n\n/* Avoid PLT use for our local calls at startup.  */\nextern __typeof (__mempcpy) __mempcpy attribute_hidden;\n\n/* GCC has mental blocks about _exit.  */\nextern __typeof (_exit) exit_internal asm (\"_exit\") attribute_hidden;\n#define _exit exit_internal\n\n/* Helper function to handle errors while resolving symbols.  */\nstatic void print_unresolved (int errcode, const char *objname,\n\t\t\t      const char *errsting);\n\n/* Helper function to handle errors when a version is missing.  */\nstatic void print_missing_version (int errcode, const char *objname,\n\t\t\t\t   const char *errsting);\n\n/* Print the various times we collected.  */\nstatic void print_statistics (hp_timing_t *total_timep);\n\n/* Add audit objects.  */\nstatic void process_dl_audit (char *str);\n\n/* This is a list of all the modes the dynamic loader can be in.  */\nenum mode { normal, list, verify, trace };\n\n/* Process all environments variables the dynamic linker must recognize.\n   Since all of them start with `LD_' we are a bit smarter while finding\n   all the entries.  */\nstatic void process_envvars (enum mode *modep);\n\n#ifdef DL_ARGV_NOT_RELRO\nint _dl_argc attribute_hidden;\nchar **_dl_argv = NULL;\n/* Nonzero if we were run directly.  */\nunsigned int _dl_skip_args attribute_hidden;\n#else\nint _dl_argc attribute_relro attribute_hidden;\nchar **_dl_argv attribute_relro = NULL;\nunsigned int _dl_skip_args attribute_relro attribute_hidden;\n#endif\nrtld_hidden_data_def (_dl_argv)\n\n#ifndef THREAD_SET_STACK_GUARD\n/* Only exported for architectures that don't store the stack guard canary\n   in thread local area.  */\nuintptr_t __stack_chk_guard attribute_relro;\n#endif\n\n/* Only exported for architectures that don't store the pointer guard\n   value in thread local area.  */\nuintptr_t __pointer_chk_guard_local\n     attribute_relro attribute_hidden __attribute__ ((nocommon));\n#ifndef THREAD_SET_POINTER_GUARD\nstrong_alias (__pointer_chk_guard_local, __pointer_chk_guard)\n#endif\n\n/* Length limits for names and paths, to protect the dynamic linker,\n   particularly when __libc_enable_secure is active.  */\n#ifdef NAME_MAX\n# define SECURE_NAME_LIMIT NAME_MAX\n#else\n# define SECURE_NAME_LIMIT 255\n#endif\n#ifdef PATH_MAX\n# define SECURE_PATH_LIMIT PATH_MAX\n#else\n# define SECURE_PATH_LIMIT 1024\n#endif\n\n/* Check that AT_SECURE=0, or that the passed name does not contain\n   directories and is not overly long.  Reject empty names\n   unconditionally.  */\nstatic bool\ndso_name_valid_for_suid (const char *p)\n{\n  if (__glibc_unlikely (__libc_enable_secure))\n    {\n      /* Ignore pathnames with directories for AT_SECURE=1\n\t programs, and also skip overlong names.  */\n      size_t len = strlen (p);\n      if (len >= SECURE_NAME_LIMIT || memchr (p, '/', len) != NULL)\n\treturn false;\n    }\n  return *p != '\\0';\n}\n\n/* LD_AUDIT variable contents.  Must be processed before the\n   audit_list below.  */\nconst char *audit_list_string;\n\n/* Cyclic list of auditing DSOs.  audit_list->next is the first\n   element.  */\nstatic struct audit_list\n{\n  const char *name;\n  struct audit_list *next;\n} *audit_list;\n\n/* Iterator for audit_list_string followed by audit_list.  */\nstruct audit_list_iter\n{\n  /* Tail of audit_list_string still needing processing, or NULL.  */\n  const char *audit_list_tail;\n\n  /* The list element returned in the previous iteration.  NULL before\n     the first element.  */\n  struct audit_list *previous;\n\n  /* Scratch buffer for returning a name which is part of\n     audit_list_string.  */\n  char fname[SECURE_NAME_LIMIT];\n};\n\n/* Initialize an audit list iterator.  */\nstatic void\naudit_list_iter_init (struct audit_list_iter *iter)\n{\n  iter->audit_list_tail = audit_list_string;\n  iter->previous = NULL;\n}\n\n/* Iterate through both audit_list_string and audit_list.  */\nstatic const char *\naudit_list_iter_next (struct audit_list_iter *iter)\n{\n  if (iter->audit_list_tail != NULL)\n    {\n      /* First iterate over audit_list_string.  */\n      while (*iter->audit_list_tail != '\\0')\n\t{\n\t  /* Split audit list at colon.  */\n\t  size_t len = strcspn (iter->audit_list_tail, \":\");\n\t  if (len > 0 && len < sizeof (iter->fname))\n\t    {\n\t      memcpy (iter->fname, iter->audit_list_tail, len);\n\t      iter->fname[len] = '\\0';\n\t    }\n\t  else\n\t    /* Do not return this name to the caller.  */\n\t    iter->fname[0] = '\\0';\n\n\t  /* Skip over the substring and the following delimiter.  */\n\t  iter->audit_list_tail += len;\n\t  if (*iter->audit_list_tail == ':')\n\t    ++iter->audit_list_tail;\n\n\t  /* If the name is valid, return it.  */\n\t  if (dso_name_valid_for_suid (iter->fname))\n\t    return iter->fname;\n\t  /* Otherwise, wrap around and try the next name.  */\n\t}\n      /* Fall through to the procesing of audit_list.  */\n    }\n\n  if (iter->previous == NULL)\n    {\n      if (audit_list == NULL)\n\t/* No pre-parsed audit list.  */\n\treturn NULL;\n      /* Start of audit list.  The first list element is at\n\t audit_list->next (cyclic list).  */\n      iter->previous = audit_list->next;\n      return iter->previous->name;\n    }\n  if (iter->previous == audit_list)\n    /* Cyclic list wrap-around.  */\n    return NULL;\n  iter->previous = iter->previous->next;\n  return iter->previous->name;\n}\n\n#ifndef HAVE_INLINED_SYSCALLS\n/* Set nonzero during loading and initialization of executable and\n   libraries, cleared before the executable's entry point runs.  This\n   must not be initialized to nonzero, because the unused dynamic\n   linker loaded in for libc.so's \"ld.so.1\" dep will provide the\n   definition seen by libc.so's initializer; that value must be zero,\n   and will be since that dynamic linker's _dl_start and dl_main will\n   never be called.  */\nint _dl_starting_up = 0;\nrtld_hidden_def (_dl_starting_up)\n#endif\n\n/* This is the structure which defines all variables global to ld.so\n   (except those which cannot be added for some reason).  */\nstruct rtld_global _rtld_global =\n  {\n    /* Generally the default presumption without further information is an\n     * executable stack but this is not true for all platforms.  */\n    ._dl_stack_flags = DEFAULT_STACK_PERMS,\n#ifdef _LIBC_REENTRANT\n    ._dl_load_lock = _RTLD_LOCK_RECURSIVE_INITIALIZER,\n    ._dl_load_write_lock = _RTLD_LOCK_RECURSIVE_INITIALIZER,\n#endif\n    ._dl_nns = 1,\n    ._dl_ns =\n    {\n#ifdef _LIBC_REENTRANT\n      [LM_ID_BASE] = { ._ns_unique_sym_table\n\t\t       = { .lock = _RTLD_LOCK_RECURSIVE_INITIALIZER } }\n#endif\n    }\n  };\n/* If we would use strong_alias here the compiler would see a\n   non-hidden definition.  This would undo the effect of the previous\n   declaration.  So spell out was strong_alias does plus add the\n   visibility attribute.  */\nextern struct rtld_global _rtld_local\n    __attribute__ ((alias (\"_rtld_global\"), visibility (\"hidden\")));\n\n\n/* This variable is similar to _rtld_local, but all values are\n   read-only after relocation.  */\nstruct rtld_global_ro _rtld_global_ro attribute_relro =\n  {\n    /* Get architecture specific initializer.  */\n#include <dl-procinfo.c>\n#ifdef NEED_DL_SYSINFO\n    ._dl_sysinfo = DL_SYSINFO_DEFAULT,\n#endif\n    ._dl_debug_fd = STDERR_FILENO,\n    ._dl_use_load_bias = -2,\n    ._dl_correct_cache_id = _DL_CACHE_DEFAULT_ID,\n#if !HAVE_TUNABLES\n    ._dl_hwcap_mask = HWCAP_IMPORTANT,\n#endif\n    ._dl_lazy = 1,\n    ._dl_fpu_control = _FPU_DEFAULT,\n    ._dl_pagesize = EXEC_PAGESIZE,\n    ._dl_inhibit_cache = 0,\n\n    /* Function pointers.  */\n    ._dl_debug_printf = _dl_debug_printf,\n    ._dl_mcount = _dl_mcount,\n    ._dl_lookup_symbol_x = _dl_lookup_symbol_x,\n    ._dl_open = _dl_open,\n    ._dl_close = _dl_close,\n    ._dl_tls_get_addr_soft = _dl_tls_get_addr_soft,\n#ifdef HAVE_DL_DISCOVER_OSVERSION\n    ._dl_discover_osversion = _dl_discover_osversion\n#endif\n  };\n/* If we would use strong_alias here the compiler would see a\n   non-hidden definition.  This would undo the effect of the previous\n   declaration.  So spell out was strong_alias does plus add the\n   visibility attribute.  */\nextern struct rtld_global_ro _rtld_local_ro\n    __attribute__ ((alias (\"_rtld_global_ro\"), visibility (\"hidden\")));\n\n\nstatic void dl_main (const ElfW(Phdr) *phdr, ElfW(Word) phnum,\n\t\t     ElfW(Addr) *user_entry, ElfW(auxv_t) *auxv);\n\n/* These two variables cannot be moved into .data.rel.ro.  */\nstatic struct libname_list _dl_rtld_libname;\nstatic struct libname_list _dl_rtld_libname2;\n\n/* Variable for statistics.  */\n#ifndef HP_TIMING_NONAVAIL\nstatic hp_timing_t relocate_time;\nstatic hp_timing_t load_time attribute_relro;\nstatic hp_timing_t start_time attribute_relro;\n#endif\n\n/* Additional definitions needed by TLS initialization.  */\n#ifdef TLS_INIT_HELPER\nTLS_INIT_HELPER\n#endif\n\n/* Helper function for syscall implementation.  */\n#ifdef DL_SYSINFO_IMPLEMENTATION\nDL_SYSINFO_IMPLEMENTATION\n#endif\n\n/* Before ld.so is relocated we must not access variables which need\n   relocations.  This means variables which are exported.  Variables\n   declared as static are fine.  If we can mark a variable hidden this\n   is fine, too.  The latter is important here.  We can avoid setting\n   up a temporary link map for ld.so if we can mark _rtld_global as\n   hidden.  */\n#ifdef PI_STATIC_AND_HIDDEN\n# define DONT_USE_BOOTSTRAP_MAP\t1\n#endif\n\n#ifdef DONT_USE_BOOTSTRAP_MAP\nstatic ElfW(Addr) _dl_start_final (void *arg);\n#else\nstruct dl_start_final_info\n{\n  struct link_map l;\n#if !defined HP_TIMING_NONAVAIL && HP_TIMING_INLINE\n  hp_timing_t start_time;\n#endif\n};\nstatic ElfW(Addr) _dl_start_final (void *arg,\n\t\t\t\t   struct dl_start_final_info *info);\n#endif\n\n/* These defined magically in the linker script.  */\nextern char _begin[] attribute_hidden;\nextern char _etext[] attribute_hidden;\nextern char _end[] attribute_hidden;\n\n\n#ifdef RTLD_START\nRTLD_START\n#else\n# error \"sysdeps/MACHINE/dl-machine.h fails to define RTLD_START\"\n#endif\n\n/* This is the second half of _dl_start (below).  It can be inlined safely\n   under DONT_USE_BOOTSTRAP_MAP, where it is careful not to make any GOT\n   references.  When the tools don't permit us to avoid using a GOT entry\n   for _dl_rtld_global (no attribute_hidden support), we must make sure\n   this function is not inlined (see below).  */\n\n#ifdef DONT_USE_BOOTSTRAP_MAP\nstatic inline ElfW(Addr) __attribute__ ((always_inline))\n_dl_start_final (void *arg)\n#else\nstatic ElfW(Addr) __attribute__ ((noinline))\n_dl_start_final (void *arg, struct dl_start_final_info *info)\n#endif\n{\n  ElfW(Addr) start_addr;\n\n  if (HP_SMALL_TIMING_AVAIL)\n    {\n      /* If it hasn't happen yet record the startup time.  */\n      if (! HP_TIMING_INLINE)\n\tHP_TIMING_NOW (start_time);\n#if !defined DONT_USE_BOOTSTRAP_MAP && !defined HP_TIMING_NONAVAIL\n      else\n\tstart_time = info->start_time;\n#endif\n    }\n\n  /* Transfer data about ourselves to the permanent link_map structure.  */\n#ifndef DONT_USE_BOOTSTRAP_MAP\n  GL(dl_rtld_map).l_addr = info->l.l_addr;\n  GL(dl_rtld_map).l_ld = info->l.l_ld;\n  memcpy (GL(dl_rtld_map).l_info, info->l.l_info,\n\t  sizeof GL(dl_rtld_map).l_info);\n  GL(dl_rtld_map).l_mach = info->l.l_mach;\n  GL(dl_rtld_map).l_relocated = 1;\n#endif\n  _dl_setup_hash (&GL(dl_rtld_map));\n  GL(dl_rtld_map).l_real = &GL(dl_rtld_map);\n  GL(dl_rtld_map).l_map_start = (ElfW(Addr)) _begin;\n  GL(dl_rtld_map).l_map_end = (ElfW(Addr)) _end;\n  GL(dl_rtld_map).l_text_end = (ElfW(Addr)) _etext;\n  /* Copy the TLS related data if necessary.  */\n#ifndef DONT_USE_BOOTSTRAP_MAP\n# if NO_TLS_OFFSET != 0\n  GL(dl_rtld_map).l_tls_offset = NO_TLS_OFFSET;\n# endif\n#endif\n\n  HP_TIMING_NOW (GL(dl_cpuclock_offset));\n\n  /* Initialize the stack end variable.  */\n  __libc_stack_end = __builtin_frame_address (0);\n\n  /* Call the OS-dependent function to set up life so we can do things like\n     file access.  It will call `dl_main' (below) to do all the real work\n     of the dynamic linker, and then unwind our frame and run the user\n     entry point on the same stack we entered on.  */\n  start_addr = _dl_sysdep_start (arg, &dl_main);\n\n#ifndef HP_TIMING_NONAVAIL\n  hp_timing_t rtld_total_time;\n  if (HP_SMALL_TIMING_AVAIL)\n    {\n      hp_timing_t end_time;\n\n      /* Get the current time.  */\n      HP_TIMING_NOW (end_time);\n\n      /* Compute the difference.  */\n      HP_TIMING_DIFF (rtld_total_time, start_time, end_time);\n    }\n#endif\n\n  if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_STATISTICS))\n    {\n#ifndef HP_TIMING_NONAVAIL\n      print_statistics (&rtld_total_time);\n#else\n      print_statistics (NULL);\n#endif\n    }\n\n  return start_addr;\n}\n\nstatic ElfW(Addr) __attribute_used__\n_dl_start (void *arg)\n{\n#ifdef DONT_USE_BOOTSTRAP_MAP\n# define bootstrap_map GL(dl_rtld_map)\n#else\n  struct dl_start_final_info info;\n# define bootstrap_map info.l\n#endif\n\n  /* This #define produces dynamic linking inline functions for\n     bootstrap relocation instead of general-purpose relocation.\n     Since ld.so must not have any undefined symbols the result\n     is trivial: always the map of ld.so itself.  */\n#define RTLD_BOOTSTRAP\n#define BOOTSTRAP_MAP (&bootstrap_map)\n#define RESOLVE_MAP(sym, version, flags) BOOTSTRAP_MAP\n#include \"dynamic-link.h\"\n\n  if (HP_TIMING_INLINE && HP_SMALL_TIMING_AVAIL)\n#ifdef DONT_USE_BOOTSTRAP_MAP\n    HP_TIMING_NOW (start_time);\n#else\n    HP_TIMING_NOW (info.start_time);\n#endif\n\n  /* Partly clean the `bootstrap_map' structure up.  Don't use\n     `memset' since it might not be built in or inlined and we cannot\n     make function calls at this point.  Use '__builtin_memset' if we\n     know it is available.  We do not have to clear the memory if we\n     do not have to use the temporary bootstrap_map.  Global variables\n     are initialized to zero by default.  */\n#ifndef DONT_USE_BOOTSTRAP_MAP\n# ifdef HAVE_BUILTIN_MEMSET\n  __builtin_memset (bootstrap_map.l_info, '\\0', sizeof (bootstrap_map.l_info));\n# else\n  for (size_t cnt = 0;\n       cnt < sizeof (bootstrap_map.l_info) / sizeof (bootstrap_map.l_info[0]);\n       ++cnt)\n    bootstrap_map.l_info[cnt] = 0;\n# endif\n#endif\n\n  /* Figure out the run-time load address of the dynamic linker itself.  */\n  bootstrap_map.l_addr = elf_machine_load_address ();\n\n  /* Read our own dynamic section and fill in the info array.  */\n  bootstrap_map.l_ld = (void *) bootstrap_map.l_addr + elf_machine_dynamic ();\n  elf_get_dynamic_info (&bootstrap_map, NULL);\n\n#if NO_TLS_OFFSET != 0\n  bootstrap_map.l_tls_offset = NO_TLS_OFFSET;\n#endif\n\n#ifdef ELF_MACHINE_BEFORE_RTLD_RELOC\n  ELF_MACHINE_BEFORE_RTLD_RELOC (bootstrap_map.l_info);\n#endif\n\n  if (bootstrap_map.l_addr || ! bootstrap_map.l_info[VALIDX(DT_GNU_PRELINKED)])\n    {\n      /* Relocate ourselves so we can do normal function calls and\n\t data access using the global offset table.  */\n\n      ELF_DYNAMIC_RELOCATE (&bootstrap_map, 0, 0, 0);\n    }\n  bootstrap_map.l_relocated = 1;\n\n  /* Please note that we don't allow profiling of this object and\n     therefore need not test whether we have to allocate the array\n     for the relocation results (as done in dl-reloc.c).  */\n\n  /* Now life is sane; we can call functions and access global data.\n     Set up to use the operating system facilities, and find out from\n     the operating system's program loader where to find the program\n     header table in core.  Put the rest of _dl_start into a separate\n     function, that way the compiler cannot put accesses to the GOT\n     before ELF_DYNAMIC_RELOCATE.  */\n  {\n#ifdef DONT_USE_BOOTSTRAP_MAP\n    ElfW(Addr) entry = _dl_start_final (arg);\n#else\n    ElfW(Addr) entry = _dl_start_final (arg, &info);\n#endif\n\n#ifndef ELF_MACHINE_START_ADDRESS\n# define ELF_MACHINE_START_ADDRESS(map, start) (start)\n#endif\n\n    return ELF_MACHINE_START_ADDRESS (GL(dl_ns)[LM_ID_BASE]._ns_loaded, entry);\n  }\n}\n\n\n\n/* Now life is peachy; we can do all normal operations.\n   On to the real work.  */\n\n/* Some helper functions.  */\n\n/* Arguments to relocate_doit.  */\nstruct relocate_args\n{\n  struct link_map *l;\n  int reloc_mode;\n};\n\nstruct map_args\n{\n  /* Argument to map_doit.  */\n  const char *str;\n  struct link_map *loader;\n  int mode;\n  /* Return value of map_doit.  */\n  struct link_map *map;\n};\n\nstruct dlmopen_args\n{\n  const char *fname;\n  struct link_map *map;\n};\n\nstruct lookup_args\n{\n  const char *name;\n  struct link_map *map;\n  void *result;\n};\n\n/* Arguments to version_check_doit.  */\nstruct version_check_args\n{\n  int doexit;\n  int dotrace;\n};\n\nstatic void\nrelocate_doit (void *a)\n{\n  struct relocate_args *args = (struct relocate_args *) a;\n\n  _dl_relocate_object (args->l, args->l->l_scope, args->reloc_mode, 0);\n}\n\nstatic void\nmap_doit (void *a)\n{\n  struct map_args *args = (struct map_args *) a;\n  int type = (args->mode == __RTLD_OPENEXEC) ? lt_executable : lt_library;\n  args->map = _dl_map_object (args->loader, args->str, type, 0,\n\t\t\t      args->mode, LM_ID_BASE);\n}\n\nstatic void\ndlmopen_doit (void *a)\n{\n  struct dlmopen_args *args = (struct dlmopen_args *) a;\n  args->map = _dl_open (args->fname,\n\t\t\t(RTLD_LAZY | __RTLD_DLOPEN | __RTLD_AUDIT\n\t\t\t | __RTLD_SECURE),\n\t\t\tdl_main, LM_ID_NEWLM, _dl_argc, _dl_argv,\n\t\t\t__environ);\n}\n\nstatic void\nlookup_doit (void *a)\n{\n  struct lookup_args *args = (struct lookup_args *) a;\n  const ElfW(Sym) *ref = NULL;\n  args->result = NULL;\n  lookup_t l = _dl_lookup_symbol_x (args->name, args->map, &ref,\n\t\t\t\t    args->map->l_local_scope, NULL, 0,\n\t\t\t\t    DL_LOOKUP_RETURN_NEWEST, NULL);\n  if (ref != NULL)\n    args->result = DL_SYMBOL_ADDRESS (l, ref);\n}\n\nstatic void\nversion_check_doit (void *a)\n{\n  struct version_check_args *args = (struct version_check_args *) a;\n  if (_dl_check_all_versions (GL(dl_ns)[LM_ID_BASE]._ns_loaded, 1,\n\t\t\t      args->dotrace) && args->doexit)\n    /* We cannot start the application.  Abort now.  */\n    _exit (1);\n}\n\n\nstatic inline struct link_map *\nfind_needed (const char *name)\n{\n  struct r_scope_elem *scope = &GL(dl_ns)[LM_ID_BASE]._ns_loaded->l_searchlist;\n  unsigned int n = scope->r_nlist;\n\n  while (n-- > 0)\n    if (_dl_name_match_p (name, scope->r_list[n]))\n      return scope->r_list[n];\n\n  /* Should never happen.  */\n  return NULL;\n}\n\nstatic int\nmatch_version (const char *string, struct link_map *map)\n{\n  const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);\n  ElfW(Verdef) *def;\n\n#define VERDEFTAG (DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGIDX (DT_VERDEF))\n  if (map->l_info[VERDEFTAG] == NULL)\n    /* The file has no symbol versioning.  */\n    return 0;\n\n  def = (ElfW(Verdef) *) ((char *) map->l_addr\n\t\t\t  + map->l_info[VERDEFTAG]->d_un.d_ptr);\n  while (1)\n    {\n      ElfW(Verdaux) *aux = (ElfW(Verdaux) *) ((char *) def + def->vd_aux);\n\n      /* Compare the version strings.  */\n      if (strcmp (string, strtab + aux->vda_name) == 0)\n\t/* Bingo!  */\n\treturn 1;\n\n      /* If no more definitions we failed to find what we want.  */\n      if (def->vd_next == 0)\n\tbreak;\n\n      /* Next definition.  */\n      def = (ElfW(Verdef) *) ((char *) def + def->vd_next);\n    }\n\n  return 0;\n}\n\nstatic bool tls_init_tp_called;\n\nstatic void *\ninit_tls (void)\n{\n  /* Number of elements in the static TLS block.  */\n  GL(dl_tls_static_nelem) = GL(dl_tls_max_dtv_idx);\n\n  /* Do not do this twice.  The audit interface might have required\n     the DTV interfaces to be set up early.  */\n  if (GL(dl_initial_dtv) != NULL)\n    return NULL;\n\n  /* Allocate the array which contains the information about the\n     dtv slots.  We allocate a few entries more than needed to\n     avoid the need for reallocation.  */\n  size_t nelem = GL(dl_tls_max_dtv_idx) + 1 + TLS_SLOTINFO_SURPLUS;\n\n  /* Allocate.  */\n  GL(dl_tls_dtv_slotinfo_list) = (struct dtv_slotinfo_list *)\n    calloc (sizeof (struct dtv_slotinfo_list)\n\t    + nelem * sizeof (struct dtv_slotinfo), 1);\n  /* No need to check the return value.  If memory allocation failed\n     the program would have been terminated.  */\n\n  struct dtv_slotinfo *slotinfo = GL(dl_tls_dtv_slotinfo_list)->slotinfo;\n  GL(dl_tls_dtv_slotinfo_list)->len = nelem;\n  GL(dl_tls_dtv_slotinfo_list)->next = NULL;\n\n  /* Fill in the information from the loaded modules.  No namespace\n     but the base one can be filled at this time.  */\n  assert (GL(dl_ns)[LM_ID_BASE + 1]._ns_loaded == NULL);\n  int i = 0;\n  for (struct link_map *l = GL(dl_ns)[LM_ID_BASE]._ns_loaded; l != NULL;\n       l = l->l_next)\n    if (l->l_tls_blocksize != 0)\n      {\n\t/* This is a module with TLS data.  Store the map reference.\n\t   The generation counter is zero.  */\n\tslotinfo[i].map = l;\n\t/* slotinfo[i].gen = 0; */\n\t++i;\n      }\n  assert (i == GL(dl_tls_max_dtv_idx));\n\n  /* Compute the TLS offsets for the various blocks.  */\n  _dl_determine_tlsoffset ();\n\n  /* Construct the static TLS block and the dtv for the initial\n     thread.  For some platforms this will include allocating memory\n     for the thread descriptor.  The memory for the TLS block will\n     never be freed.  It should be allocated accordingly.  The dtv\n     array can be changed if dynamic loading requires it.  */\n  void *tcbp = _dl_allocate_tls_storage ();\n  if (tcbp == NULL)\n    _dl_fatal_printf (\"\\\ncannot allocate TLS data structures for initial thread\\n\");\n\n  /* Store for detection of the special case by __tls_get_addr\n     so it knows not to pass this dtv to the normal realloc.  */\n  GL(dl_initial_dtv) = GET_DTV (tcbp);\n\n  /* And finally install it for the main thread.  */\n  const char *lossage = TLS_INIT_TP (tcbp);\n  if (__glibc_unlikely (lossage != NULL))\n    _dl_fatal_printf (\"cannot set up thread-local storage: %s\\n\", lossage);\n  tls_init_tp_called = true;\n\n  return tcbp;\n}\n\nstatic unsigned int\ndo_preload (const char *fname, struct link_map *main_map, const char *where)\n{\n  const char *objname;\n  const char *err_str = NULL;\n  struct map_args args;\n  bool malloced;\n\n  args.str = fname;\n  args.loader = main_map;\n  args.mode = __RTLD_SECURE;\n\n  unsigned int old_nloaded = GL(dl_ns)[LM_ID_BASE]._ns_nloaded;\n\n  (void) _dl_catch_error (&objname, &err_str, &malloced, map_doit, &args);\n  if (__glibc_unlikely (err_str != NULL))\n    {\n      _dl_error_printf (\"\\\nERROR: ld.so: object '%s' from %s cannot be preloaded (%s): ignored.\\n\",\n\t\t\tfname, where, err_str);\n      /* No need to call free, this is still before\n\t the libc's malloc is used.  */\n    }\n  else if (GL(dl_ns)[LM_ID_BASE]._ns_nloaded != old_nloaded)\n    /* It is no duplicate.  */\n    return 1;\n\n  /* Nothing loaded.  */\n  return 0;\n}\n\n#if defined SHARED && defined _LIBC_REENTRANT \\\n    && defined __rtld_lock_default_lock_recursive\nstatic void\nrtld_lock_default_lock_recursive (void *lock)\n{\n  __rtld_lock_default_lock_recursive (lock);\n}\n\nstatic void\nrtld_lock_default_unlock_recursive (void *lock)\n{\n  __rtld_lock_default_unlock_recursive (lock);\n}\n#endif\n\n\nstatic void\nsecurity_init (void)\n{\n  /* Set up the stack checker's canary.  */\n  uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);\n#ifdef THREAD_SET_STACK_GUARD\n  THREAD_SET_STACK_GUARD (stack_chk_guard);\n#else\n  __stack_chk_guard = stack_chk_guard;\n#endif\n\n  /* Set up the pointer guard as well, if necessary.  */\n  uintptr_t pointer_chk_guard\n    = _dl_setup_pointer_guard (_dl_random, stack_chk_guard);\n#ifdef THREAD_SET_POINTER_GUARD\n  THREAD_SET_POINTER_GUARD (pointer_chk_guard);\n#endif\n  __pointer_chk_guard_local = pointer_chk_guard;\n\n  /* We do not need the _dl_random value anymore.  The less\n     information we leave behind, the better, so clear the\n     variable.  */\n  _dl_random = NULL;\n}\n\n#include \"setup-vdso.h\"\n\n/* The library search path.  */\nstatic const char *library_path attribute_relro;\n/* The list preloaded objects.  */\nstatic const char *preloadlist attribute_relro;\n/* Nonzero if information about versions has to be printed.  */\nstatic int version_info attribute_relro;\n\n/* The LD_PRELOAD environment variable gives list of libraries\n   separated by white space or colons that are loaded before the\n   executable's dependencies and prepended to the global scope list.\n   (If the binary is running setuid all elements containing a '/' are\n   ignored since it is insecure.)  Return the number of preloads\n   performed.  */\nunsigned int\nhandle_ld_preload (const char *preloadlist, struct link_map *main_map)\n{\n  unsigned int npreloads = 0;\n  const char *p = preloadlist;\n  char fname[SECURE_PATH_LIMIT];\n\n  while (*p != '\\0')\n    {\n      /* Split preload list at space/colon.  */\n      size_t len = strcspn (p, \" :\");\n      if (len > 0 && len < sizeof (fname))\n\t{\n\t  memcpy (fname, p, len);\n\t  fname[len] = '\\0';\n\t}\n      else\n\tfname[0] = '\\0';\n\n      /* Skip over the substring and the following delimiter.  */\n      p += len;\n      if (*p != '\\0')\n\t++p;\n\n      if (dso_name_valid_for_suid (fname))\n\tnpreloads += do_preload (fname, main_map, \"LD_PRELOAD\");\n    }\n  return npreloads;\n}\n\nstatic void\ndl_main (const ElfW(Phdr) *phdr,\n\t ElfW(Word) phnum,\n\t ElfW(Addr) *user_entry,\n\t ElfW(auxv_t) *auxv)\n{\n  const ElfW(Phdr) *ph;\n  enum mode mode;\n  struct link_map *main_map;\n  size_t file_size;\n  char *file;\n  bool has_interp = false;\n  unsigned int i;\n  bool prelinked = false;\n  bool rtld_is_main = false;\n#ifndef HP_TIMING_NONAVAIL\n  hp_timing_t start;\n  hp_timing_t stop;\n  hp_timing_t diff;\n#endif\n  void *tcbp = NULL;\n\n  GL(dl_init_static_tls) = &_dl_nothread_init_static_tls;\n\n#if defined SHARED && defined _LIBC_REENTRANT \\\n    && defined __rtld_lock_default_lock_recursive\n  GL(dl_rtld_lock_recursive) = rtld_lock_default_lock_recursive;\n  GL(dl_rtld_unlock_recursive) = rtld_lock_default_unlock_recursive;\n#endif\n\n  /* The explicit initialization here is cheaper than processing the reloc\n     in the _rtld_local definition's initializer.  */\n  GL(dl_make_stack_executable_hook) = &_dl_make_stack_executable;\n\n  /* Process the environment variable which control the behaviour.  */\n  process_envvars (&mode);\n\n#ifndef HAVE_INLINED_SYSCALLS\n  /* Set up a flag which tells we are just starting.  */\n  _dl_starting_up = 1;\n#endif\n\n  if (*user_entry == (ElfW(Addr)) ENTRY_POINT)\n    {\n      /* Ho ho.  We are not the program interpreter!  We are the program\n\t itself!  This means someone ran ld.so as a command.  Well, that\n\t might be convenient to do sometimes.  We support it by\n\t interpreting the args like this:\n\n\t ld.so PROGRAM ARGS...\n\n\t The first argument is the name of a file containing an ELF\n\t executable we will load and run with the following arguments.\n\t To simplify life here, PROGRAM is searched for using the\n\t normal rules for shared objects, rather than $PATH or anything\n\t like that.  We just load it and use its entry point; we don't\n\t pay attention to its PT_INTERP command (we are the interpreter\n\t ourselves).  This is an easy way to test a new ld.so before\n\t installing it.  */\n      rtld_is_main = true;\n\n      /* Note the place where the dynamic linker actually came from.  */\n      GL(dl_rtld_map).l_name = rtld_progname;\n\n      while (_dl_argc > 1)\n\tif (! strcmp (_dl_argv[1], \"--list\"))\n\t  {\n\t    mode = list;\n\t    GLRO(dl_lazy) = -1;\t/* This means do no dependency analysis.  */\n\n\t    ++_dl_skip_args;\n\t    --_dl_argc;\n\t    ++_dl_argv;\n\t  }\n\telse if (! strcmp (_dl_argv[1], \"--verify\"))\n\t  {\n\t    mode = verify;\n\n\t    ++_dl_skip_args;\n\t    --_dl_argc;\n\t    ++_dl_argv;\n\t  }\n\telse if (! strcmp (_dl_argv[1], \"--inhibit-cache\"))\n\t  {\n\t    GLRO(dl_inhibit_cache) = 1;\n\t    ++_dl_skip_args;\n\t    --_dl_argc;\n\t    ++_dl_argv;\n\t  }\n\telse if (! strcmp (_dl_argv[1], \"--library-path\")\n\t\t && _dl_argc > 2)\n\t  {\n\t    library_path = _dl_argv[2];\n\n\t    _dl_skip_args += 2;\n\t    _dl_argc -= 2;\n\t    _dl_argv += 2;\n\t  }\n\telse if (! strcmp (_dl_argv[1], \"--inhibit-rpath\")\n\t\t && _dl_argc > 2)\n\t  {\n\t    GLRO(dl_inhibit_rpath) = _dl_argv[2];\n\n\t    _dl_skip_args += 2;\n\t    _dl_argc -= 2;\n\t    _dl_argv += 2;\n\t  }\n\telse if (! strcmp (_dl_argv[1], \"--audit\") && _dl_argc > 2)\n\t  {\n\t    process_dl_audit (_dl_argv[2]);\n\n\t    _dl_skip_args += 2;\n\t    _dl_argc -= 2;\n\t    _dl_argv += 2;\n\t  }\n\telse\n\t  break;\n\n      /* If we have no further argument the program was called incorrectly.\n\t Grant the user some education.  */\n      if (_dl_argc < 2)\n\t_dl_fatal_printf (\"\\\nUsage: ld.so [OPTION]... EXECUTABLE-FILE [ARGS-FOR-PROGRAM...]\\n\\\nYou have invoked `ld.so', the helper program for shared library executables.\\n\\\nThis program usually lives in the file `/lib/ld.so', and special directives\\n\\\nin executable files using ELF shared libraries tell the system's program\\n\\\nloader to load the helper program from this file.  This helper program loads\\n\\\nthe shared libraries needed by the program executable, prepares the program\\n\\\nto run, and runs it.  You may invoke this helper program directly from the\\n\\\ncommand line to load and run an ELF executable file; this is like executing\\n\\\nthat file itself, but always uses this helper program from the file you\\n\\\nspecified, instead of the helper program file specified in the executable\\n\\\nfile you run.  This is mostly of use for maintainers to test new versions\\n\\\nof this helper program; chances are you did not intend to run this program.\\n\\\n\\n\\\n  --list                list all dependencies and how they are resolved\\n\\\n  --verify              verify that given object really is a dynamically linked\\n\\\n\t\t\tobject we can handle\\n\\\n  --inhibit-cache       Do not use \" LD_SO_CACHE \"\\n\\\n  --library-path PATH   use given PATH instead of content of the environment\\n\\\n\t\t\tvariable LD_LIBRARY_PATH\\n\\\n  --inhibit-rpath LIST  ignore RUNPATH and RPATH information in object names\\n\\\n\t\t\tin LIST\\n\\\n  --audit LIST          use objects named in LIST as auditors\\n\");\n\n      ++_dl_skip_args;\n      --_dl_argc;\n      ++_dl_argv;\n\n      /* The initialization of _dl_stack_flags done below assumes the\n\t executable's PT_GNU_STACK may have been honored by the kernel, and\n\t so a PT_GNU_STACK with PF_X set means the stack started out with\n\t execute permission.  However, this is not really true if the\n\t dynamic linker is the executable the kernel loaded.  For this\n\t case, we must reinitialize _dl_stack_flags to match the dynamic\n\t linker itself.  If the dynamic linker was built with a\n\t PT_GNU_STACK, then the kernel may have loaded us with a\n\t nonexecutable stack that we will have to make executable when we\n\t load the program below unless it has a PT_GNU_STACK indicating\n\t nonexecutable stack is ok.  */\n\n      for (ph = phdr; ph < &phdr[phnum]; ++ph)\n\tif (ph->p_type == PT_GNU_STACK)\n\t  {\n\t    GL(dl_stack_flags) = ph->p_flags;\n\t    break;\n\t  }\n\n      if (__builtin_expect (mode, normal) == verify)\n\t{\n\t  const char *objname;\n\t  const char *err_str = NULL;\n\t  struct map_args args;\n\t  bool malloced;\n\n\t  args.str = rtld_progname;\n\t  args.loader = NULL;\n\t  args.mode = __RTLD_OPENEXEC;\n\t  (void) _dl_catch_error (&objname, &err_str, &malloced, map_doit,\n\t\t\t\t  &args);\n\t  if (__glibc_unlikely (err_str != NULL))\n\t    /* We don't free the returned string, the programs stops\n\t       anyway.  */\n\t    _exit (EXIT_FAILURE);\n\t}\n      else\n\t{\n\t  HP_TIMING_NOW (start);\n\t  _dl_map_object (NULL, rtld_progname, lt_executable, 0,\n\t\t\t  __RTLD_OPENEXEC, LM_ID_BASE);\n\t  HP_TIMING_NOW (stop);\n\n\t  HP_TIMING_DIFF (load_time, start, stop);\n\t}\n\n      /* Now the map for the main executable is available.  */\n      main_map = GL(dl_ns)[LM_ID_BASE]._ns_loaded;\n\n      if (__builtin_expect (mode, normal) == normal\n\t  && GL(dl_rtld_map).l_info[DT_SONAME] != NULL\n\t  && main_map->l_info[DT_SONAME] != NULL\n\t  && strcmp ((const char *) D_PTR (&GL(dl_rtld_map), l_info[DT_STRTAB])\n\t\t     + GL(dl_rtld_map).l_info[DT_SONAME]->d_un.d_val,\n\t\t     (const char *) D_PTR (main_map, l_info[DT_STRTAB])\n\t\t     + main_map->l_info[DT_SONAME]->d_un.d_val) == 0)\n\t_dl_fatal_printf (\"loader cannot load itself\\n\");\n\n      phdr = main_map->l_phdr;\n      phnum = main_map->l_phnum;\n      /* We overwrite here a pointer to a malloc()ed string.  But since\n\t the malloc() implementation used at this point is the dummy\n\t implementations which has no real free() function it does not\n\t makes sense to free the old string first.  */\n      main_map->l_name = (char *) \"\";\n      *user_entry = main_map->l_entry;\n\n#ifdef HAVE_AUX_VECTOR\n      /* Adjust the on-stack auxiliary vector so that it looks like the\n\t binary was executed directly.  */\n      for (ElfW(auxv_t) *av = auxv; av->a_type != AT_NULL; av++)\n\tswitch (av->a_type)\n\t  {\n\t  case AT_PHDR:\n\t    av->a_un.a_val = (uintptr_t) phdr;\n\t    break;\n\t  case AT_PHNUM:\n\t    av->a_un.a_val = phnum;\n\t    break;\n\t  case AT_ENTRY:\n\t    av->a_un.a_val = *user_entry;\n\t    break;\n\t  case AT_EXECFN:\n\t    av->a_un.a_val = (uintptr_t) _dl_argv[0];\n\t    break;\n\t  }\n#endif\n    }\n  else\n    {\n      /* Create a link_map for the executable itself.\n\t This will be what dlopen on \"\" returns.  */\n      main_map = _dl_new_object ((char *) \"\", \"\", lt_executable, NULL,\n\t\t\t\t __RTLD_OPENEXEC, LM_ID_BASE);\n      assert (main_map != NULL);\n      main_map->l_phdr = phdr;\n      main_map->l_phnum = phnum;\n      main_map->l_entry = *user_entry;\n\n      /* Even though the link map is not yet fully initialized we can add\n\t it to the map list since there are no possible users running yet.  */\n      _dl_add_to_namespace_list (main_map, LM_ID_BASE);\n      assert (main_map == GL(dl_ns)[LM_ID_BASE]._ns_loaded);\n\n      /* At this point we are in a bit of trouble.  We would have to\n\t fill in the values for l_dev and l_ino.  But in general we\n\t do not know where the file is.  We also do not handle AT_EXECFD\n\t even if it would be passed up.\n\n\t We leave the values here defined to 0.  This is normally no\n\t problem as the program code itself is normally no shared\n\t object and therefore cannot be loaded dynamically.  Nothing\n\t prevent the use of dynamic binaries and in these situations\n\t we might get problems.  We might not be able to find out\n\t whether the object is already loaded.  But since there is no\n\t easy way out and because the dynamic binary must also not\n\t have an SONAME we ignore this program for now.  If it becomes\n\t a problem we can force people using SONAMEs.  */\n\n      /* We delay initializing the path structure until we got the dynamic\n\t information for the program.  */\n    }\n\n  main_map->l_map_end = 0;\n  main_map->l_text_end = 0;\n  /* Perhaps the executable has no PT_LOAD header entries at all.  */\n  main_map->l_map_start = ~0;\n  /* And it was opened directly.  */\n  ++main_map->l_direct_opencount;\n\n  /* Scan the program header table for the dynamic section.  */\n  for (ph = phdr; ph < &phdr[phnum]; ++ph)\n    switch (ph->p_type)\n      {\n      case PT_PHDR:\n\t/* Find out the load address.  */\n\tmain_map->l_addr = (ElfW(Addr)) phdr - ph->p_vaddr;\n\tbreak;\n      case PT_DYNAMIC:\n\t/* This tells us where to find the dynamic section,\n\t   which tells us everything we need to do.  */\n\tmain_map->l_ld = (void *) main_map->l_addr + ph->p_vaddr;\n\tbreak;\n      case PT_INTERP:\n\t/* This \"interpreter segment\" was used by the program loader to\n\t   find the program interpreter, which is this program itself, the\n\t   dynamic linker.  We note what name finds us, so that a future\n\t   dlopen call or DT_NEEDED entry, for something that wants to link\n\t   against the dynamic linker as a shared library, will know that\n\t   the shared object is already loaded.  */\n\t_dl_rtld_libname.name = ((const char *) main_map->l_addr\n\t\t\t\t + ph->p_vaddr);\n\t/* _dl_rtld_libname.next = NULL;\tAlready zero.  */\n\tGL(dl_rtld_map).l_libname = &_dl_rtld_libname;\n\n\t/* Ordinarilly, we would get additional names for the loader from\n\t   our DT_SONAME.  This can't happen if we were actually linked as\n\t   a static executable (detect this case when we have no DYNAMIC).\n\t   If so, assume the filename component of the interpreter path to\n\t   be our SONAME, and add it to our name list.  */\n\tif (GL(dl_rtld_map).l_ld == NULL)\n\t  {\n\t    const char *p = NULL;\n\t    const char *cp = _dl_rtld_libname.name;\n\n\t    /* Find the filename part of the path.  */\n\t    while (*cp != '\\0')\n\t      if (*cp++ == '/')\n\t\tp = cp;\n\n\t    if (p != NULL)\n\t      {\n\t\t_dl_rtld_libname2.name = p;\n\t\t/* _dl_rtld_libname2.next = NULL;  Already zero.  */\n\t\t_dl_rtld_libname.next = &_dl_rtld_libname2;\n\t      }\n\t  }\n\n\thas_interp = true;\n\tbreak;\n      case PT_LOAD:\n\t{\n\t  ElfW(Addr) mapstart;\n\t  ElfW(Addr) allocend;\n\n\t  /* Remember where the main program starts in memory.  */\n\t  mapstart = (main_map->l_addr\n\t\t      + (ph->p_vaddr & ~(GLRO(dl_pagesize) - 1)));\n\t  if (main_map->l_map_start > mapstart)\n\t    main_map->l_map_start = mapstart;\n\n\t  /* Also where it ends.  */\n\t  allocend = main_map->l_addr + ph->p_vaddr + ph->p_memsz;\n\t  if (main_map->l_map_end < allocend)\n\t    main_map->l_map_end = allocend;\n\t  if ((ph->p_flags & PF_X) && allocend > main_map->l_text_end)\n\t    main_map->l_text_end = allocend;\n\t}\n\tbreak;\n\n      case PT_TLS:\n\tif (ph->p_memsz > 0)\n\t  {\n\t    /* Note that in the case the dynamic linker we duplicate work\n\t       here since we read the PT_TLS entry already in\n\t       _dl_start_final.  But the result is repeatable so do not\n\t       check for this special but unimportant case.  */\n\t    main_map->l_tls_blocksize = ph->p_memsz;\n\t    main_map->l_tls_align = ph->p_align;\n\t    if (ph->p_align == 0)\n\t      main_map->l_tls_firstbyte_offset = 0;\n\t    else\n\t      main_map->l_tls_firstbyte_offset = (ph->p_vaddr\n\t\t\t\t\t\t  & (ph->p_align - 1));\n\t    main_map->l_tls_initimage_size = ph->p_filesz;\n\t    main_map->l_tls_initimage = (void *) ph->p_vaddr;\n\n\t    /* This image gets the ID one.  */\n\t    GL(dl_tls_max_dtv_idx) = main_map->l_tls_modid = 1;\n\t  }\n\tbreak;\n\n      case PT_GNU_STACK:\n\tGL(dl_stack_flags) = ph->p_flags;\n\tbreak;\n\n      case PT_GNU_RELRO:\n\tmain_map->l_relro_addr = ph->p_vaddr;\n\tmain_map->l_relro_size = ph->p_memsz;\n\tbreak;\n\n      case PT_NOTE:\n\tif (_rtld_process_pt_note (main_map, ph))\n\t  _dl_error_printf (\"\\\nERROR: '%s': cannot process note segment.\\n\", _dl_argv[0]);\n\tbreak;\n      }\n\n  /* Adjust the address of the TLS initialization image in case\n     the executable is actually an ET_DYN object.  */\n  if (main_map->l_tls_initimage != NULL)\n    main_map->l_tls_initimage\n      = (char *) main_map->l_tls_initimage + main_map->l_addr;\n  if (! main_map->l_map_end)\n    main_map->l_map_end = ~0;\n  if (! main_map->l_text_end)\n    main_map->l_text_end = ~0;\n  if (! GL(dl_rtld_map).l_libname && GL(dl_rtld_map).l_name)\n    {\n      /* We were invoked directly, so the program might not have a\n\t PT_INTERP.  */\n      _dl_rtld_libname.name = GL(dl_rtld_map).l_name;\n      /* _dl_rtld_libname.next = NULL;\tAlready zero.  */\n      GL(dl_rtld_map).l_libname =  &_dl_rtld_libname;\n    }\n  else\n    assert (GL(dl_rtld_map).l_libname); /* How else did we get here?  */\n\n  /* If the current libname is different from the SONAME, add the\n     latter as well.  */\n  if (GL(dl_rtld_map).l_info[DT_SONAME] != NULL\n      && strcmp (GL(dl_rtld_map).l_libname->name,\n\t\t (const char *) D_PTR (&GL(dl_rtld_map), l_info[DT_STRTAB])\n\t\t + GL(dl_rtld_map).l_info[DT_SONAME]->d_un.d_val) != 0)\n    {\n      static struct libname_list newname;\n      newname.name = ((char *) D_PTR (&GL(dl_rtld_map), l_info[DT_STRTAB])\n\t\t      + GL(dl_rtld_map).l_info[DT_SONAME]->d_un.d_ptr);\n      newname.next = NULL;\n      newname.dont_free = 1;\n\n      assert (GL(dl_rtld_map).l_libname->next == NULL);\n      GL(dl_rtld_map).l_libname->next = &newname;\n    }\n  /* The ld.so must be relocated since otherwise loading audit modules\n     will fail since they reuse the very same ld.so.  */\n  assert (GL(dl_rtld_map).l_relocated);\n\n  if (! rtld_is_main)\n    {\n      /* Extract the contents of the dynamic section for easy access.  */\n      elf_get_dynamic_info (main_map, NULL);\n      /* Set up our cache of pointers into the hash table.  */\n      _dl_setup_hash (main_map);\n    }\n\n  if (__builtin_expect (mode, normal) == verify)\n    {\n      /* We were called just to verify that this is a dynamic\n\t executable using us as the program interpreter.  Exit with an\n\t error if we were not able to load the binary or no interpreter\n\t is specified (i.e., this is no dynamically linked binary.  */\n      if (main_map->l_ld == NULL)\n\t_exit (1);\n\n      /* We allow here some platform specific code.  */\n#ifdef DISTINGUISH_LIB_VERSIONS\n      DISTINGUISH_LIB_VERSIONS;\n#endif\n      _exit (has_interp ? 0 : 2);\n    }\n\n  struct link_map **first_preload = &GL(dl_rtld_map).l_next;\n  /* Set up the data structures for the system-supplied DSO early,\n     so they can influence _dl_init_paths.  */\n  setup_vdso (main_map, &first_preload);\n\n#ifdef DL_SYSDEP_OSCHECK\n  DL_SYSDEP_OSCHECK (_dl_fatal_printf);\n#endif\n\n  /* Initialize the data structures for the search paths for shared\n     objects.  */\n  _dl_init_paths (library_path);\n\n  /* Initialize _r_debug.  */\n  struct r_debug *r = _dl_debug_initialize (GL(dl_rtld_map).l_addr,\n\t\t\t\t\t    LM_ID_BASE);\n  r->r_state = RT_CONSISTENT;\n\n  /* Put the link_map for ourselves on the chain so it can be found by\n     name.  Note that at this point the global chain of link maps contains\n     exactly one element, which is pointed to by dl_loaded.  */\n  if (! GL(dl_rtld_map).l_name)\n    /* If not invoked directly, the dynamic linker shared object file was\n       found by the PT_INTERP name.  */\n    GL(dl_rtld_map).l_name = (char *) GL(dl_rtld_map).l_libname->name;\n  GL(dl_rtld_map).l_type = lt_library;\n  main_map->l_next = &GL(dl_rtld_map);\n  GL(dl_rtld_map).l_prev = main_map;\n  ++GL(dl_ns)[LM_ID_BASE]._ns_nloaded;\n  ++GL(dl_load_adds);\n\n  /* If LD_USE_LOAD_BIAS env variable has not been seen, default\n     to not using bias for non-prelinked PIEs and libraries\n     and using it for executables or prelinked PIEs or libraries.  */\n  if (GLRO(dl_use_load_bias) == (ElfW(Addr)) -2)\n    GLRO(dl_use_load_bias) = main_map->l_addr == 0 ? -1 : 0;\n\n  /* Set up the program header information for the dynamic linker\n     itself.  It is needed in the dl_iterate_phdr callbacks.  */\n  const ElfW(Ehdr) *rtld_ehdr;\n\n  /* Starting from binutils-2.23, the linker will define the magic symbol\n     __ehdr_start to point to our own ELF header if it is visible in a\n     segment that also includes the phdrs.  If that's not available, we use\n     the old method that assumes the beginning of the file is part of the\n     lowest-addressed PT_LOAD segment.  */\n#ifdef HAVE_EHDR_START\n  extern const ElfW(Ehdr) __ehdr_start __attribute__ ((visibility (\"hidden\")));\n  rtld_ehdr = &__ehdr_start;\n#else\n  rtld_ehdr = (void *) GL(dl_rtld_map).l_map_start;\n#endif\n  assert (rtld_ehdr->e_ehsize == sizeof *rtld_ehdr);\n  assert (rtld_ehdr->e_phentsize == sizeof (ElfW(Phdr)));\n\n  const ElfW(Phdr) *rtld_phdr = (const void *) rtld_ehdr + rtld_ehdr->e_phoff;\n\n  GL(dl_rtld_map).l_phdr = rtld_phdr;\n  GL(dl_rtld_map).l_phnum = rtld_ehdr->e_phnum;\n\n\n  /* PT_GNU_RELRO is usually the last phdr.  */\n  size_t cnt = rtld_ehdr->e_phnum;\n  while (cnt-- > 0)\n    if (rtld_phdr[cnt].p_type == PT_GNU_RELRO)\n      {\n\tGL(dl_rtld_map).l_relro_addr = rtld_phdr[cnt].p_vaddr;\n\tGL(dl_rtld_map).l_relro_size = rtld_phdr[cnt].p_memsz;\n\tbreak;\n      }\n\n  /* Add the dynamic linker to the TLS list if it also uses TLS.  */\n  if (GL(dl_rtld_map).l_tls_blocksize != 0)\n    /* Assign a module ID.  Do this before loading any audit modules.  */\n    GL(dl_rtld_map).l_tls_modid = _dl_next_tls_modid ();\n\n  /* If we have auditing DSOs to load, do it now.  */\n  bool need_security_init = true;\n  if (__glibc_unlikely (audit_list != NULL)\n      || __glibc_unlikely (audit_list_string != NULL))\n    {\n      struct audit_ifaces *last_audit = NULL;\n      struct audit_list_iter al_iter;\n      audit_list_iter_init (&al_iter);\n\n      /* Since we start using the auditing DSOs right away we need to\n\t initialize the data structures now.  */\n      tcbp = init_tls ();\n\n      /* Initialize security features.  We need to do it this early\n\t since otherwise the constructors of the audit libraries will\n\t use different values (especially the pointer guard) and will\n\t fail later on.  */\n      security_init ();\n      need_security_init = false;\n\n      while (true)\n\t{\n\t  const char *name = audit_list_iter_next (&al_iter);\n\t  if (name == NULL)\n\t    break;\n\n\t  int tls_idx = GL(dl_tls_max_dtv_idx);\n\n\t  /* Now it is time to determine the layout of the static TLS\n\t     block and allocate it for the initial thread.  Note that we\n\t     always allocate the static block, we never defer it even if\n\t     no DF_STATIC_TLS bit is set.  The reason is that we know\n\t     glibc will use the static model.  */\n\t  struct dlmopen_args dlmargs;\n\t  dlmargs.fname = name;\n\t  dlmargs.map = NULL;\n\n\t  const char *objname;\n\t  const char *err_str = NULL;\n\t  bool malloced;\n\t  (void) _dl_catch_error (&objname, &err_str, &malloced, dlmopen_doit,\n\t\t\t\t  &dlmargs);\n\t  if (__glibc_unlikely (err_str != NULL))\n\t    {\n\t    not_loaded:\n\t      _dl_error_printf (\"\\\nERROR: ld.so: object '%s' cannot be loaded as audit interface: %s; ignored.\\n\",\n\t\t\t\tname, err_str);\n\t      if (malloced)\n\t\tfree ((char *) err_str);\n\t    }\n\t  else\n\t    {\n\t      struct lookup_args largs;\n\t      largs.name = \"la_version\";\n\t      largs.map = dlmargs.map;\n\n\t      /* Check whether the interface version matches.  */\n\t      (void) _dl_catch_error (&objname, &err_str, &malloced,\n\t\t\t\t      lookup_doit, &largs);\n\n\t      unsigned int (*laversion) (unsigned int);\n\t      unsigned int lav;\n\t      if  (err_str == NULL\n\t\t   && (laversion = largs.result) != NULL\n\t\t   && (lav = laversion (LAV_CURRENT)) > 0\n\t\t   && lav <= LAV_CURRENT)\n\t\t{\n\t\t  /* Allocate structure for the callback function pointers.\n\t\t     This call can never fail.  */\n\t\t  union\n\t\t  {\n\t\t    struct audit_ifaces ifaces;\n#define naudit_ifaces 8\n\t\t    void (*fptr[naudit_ifaces]) (void);\n\t\t  } *newp = malloc (sizeof (*newp));\n\n\t\t  /* Names of the auditing interfaces.  All in one\n\t\t     long string.  */\n\t\t  static const char audit_iface_names[] =\n\t\t    \"la_activity\\0\"\n\t\t    \"la_objsearch\\0\"\n\t\t    \"la_objopen\\0\"\n\t\t    \"la_preinit\\0\"\n#if __ELF_NATIVE_CLASS == 32\n\t\t    \"la_symbind32\\0\"\n#elif __ELF_NATIVE_CLASS == 64\n\t\t    \"la_symbind64\\0\"\n#else\n# error \"__ELF_NATIVE_CLASS must be defined\"\n#endif\n#define STRING(s) __STRING (s)\n\t\t    \"la_\" STRING (ARCH_LA_PLTENTER) \"\\0\"\n\t\t    \"la_\" STRING (ARCH_LA_PLTEXIT) \"\\0\"\n\t\t    \"la_objclose\\0\";\n\t\t  unsigned int cnt = 0;\n\t\t  const char *cp = audit_iface_names;\n\t\t  do\n\t\t    {\n\t\t      largs.name = cp;\n\t\t      (void) _dl_catch_error (&objname, &err_str, &malloced,\n\t\t\t\t\t      lookup_doit, &largs);\n\n\t\t      /* Store the pointer.  */\n\t\t      if (err_str == NULL && largs.result != NULL)\n\t\t\t{\n\t\t\t  newp->fptr[cnt] = largs.result;\n\n\t\t\t  /* The dynamic linker link map is statically\n\t\t\t     allocated, initialize the data now.   */\n\t\t\t  GL(dl_rtld_map).l_audit[cnt].cookie\n\t\t\t    = (intptr_t) &GL(dl_rtld_map);\n\t\t\t}\n\t\t      else\n\t\t\tnewp->fptr[cnt] = NULL;\n\t\t      ++cnt;\n\n\t\t      cp = (char *) rawmemchr (cp, '\\0') + 1;\n\t\t    }\n\t\t  while (*cp != '\\0');\n\t\t  assert (cnt == naudit_ifaces);\n\n\t\t  /* Now append the new auditing interface to the list.  */\n\t\t  newp->ifaces.next = NULL;\n\t\t  if (last_audit == NULL)\n\t\t    last_audit = GLRO(dl_audit) = &newp->ifaces;\n\t\t  else\n\t\t    last_audit = last_audit->next = &newp->ifaces;\n\t\t  ++GLRO(dl_naudit);\n\n\t\t  /* Mark the DSO as being used for auditing.  */\n\t\t  dlmargs.map->l_auditing = 1;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* We cannot use the DSO, it does not have the\n\t\t     appropriate interfaces or it expects something\n\t\t     more recent.  */\n#ifndef NDEBUG\n\t\t  Lmid_t ns = dlmargs.map->l_ns;\n#endif\n\t\t  _dl_close (dlmargs.map);\n\n\t\t  /* Make sure the namespace has been cleared entirely.  */\n\t\t  assert (GL(dl_ns)[ns]._ns_loaded == NULL);\n\t\t  assert (GL(dl_ns)[ns]._ns_nloaded == 0);\n\n\t\t  GL(dl_tls_max_dtv_idx) = tls_idx;\n\t\t  goto not_loaded;\n\t\t}\n\t    }\n\t}\n\n      /* If we have any auditing modules, announce that we already\n\t have two objects loaded.  */\n      if (__glibc_unlikely (GLRO(dl_naudit) > 0))\n\t{\n\t  struct link_map *ls[2] = { main_map, &GL(dl_rtld_map) };\n\n\t  for (unsigned int outer = 0; outer < 2; ++outer)\n\t    {\n\t      struct audit_ifaces *afct = GLRO(dl_audit);\n\t      for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)\n\t\t{\n\t\t  if (afct->objopen != NULL)\n\t\t    {\n\t\t      ls[outer]->l_audit[cnt].bindflags\n\t\t\t= afct->objopen (ls[outer], LM_ID_BASE,\n\t\t\t\t\t &ls[outer]->l_audit[cnt].cookie);\n\n\t\t      ls[outer]->l_audit_any_plt\n\t\t\t|= ls[outer]->l_audit[cnt].bindflags != 0;\n\t\t    }\n\n\t\t  afct = afct->next;\n\t\t}\n\t    }\n\t}\n    }\n\n  /* Keep track of the currently loaded modules to count how many\n     non-audit modules which use TLS are loaded.  */\n  size_t count_modids = _dl_count_modids ();\n\n  /* Set up debugging before the debugger is notified for the first time.  */\n#ifdef ELF_MACHINE_DEBUG_SETUP\n  /* Some machines (e.g. MIPS) don't use DT_DEBUG in this way.  */\n  ELF_MACHINE_DEBUG_SETUP (main_map, r);\n  ELF_MACHINE_DEBUG_SETUP (&GL(dl_rtld_map), r);\n#else\n  if (main_map->l_info[DT_DEBUG] != NULL)\n    /* There is a DT_DEBUG entry in the dynamic section.  Fill it in\n       with the run-time address of the r_debug structure  */\n    main_map->l_info[DT_DEBUG]->d_un.d_ptr = (ElfW(Addr)) r;\n\n  /* Fill in the pointer in the dynamic linker's own dynamic section, in\n     case you run gdb on the dynamic linker directly.  */\n  if (GL(dl_rtld_map).l_info[DT_DEBUG] != NULL)\n    GL(dl_rtld_map).l_info[DT_DEBUG]->d_un.d_ptr = (ElfW(Addr)) r;\n#endif\n\n  /* We start adding objects.  */\n  r->r_state = RT_ADD;\n  _dl_debug_state ();\n  LIBC_PROBE (init_start, 2, LM_ID_BASE, r);\n\n  /* Auditing checkpoint: we are ready to signal that the initial map\n     is being constructed.  */\n  if (__glibc_unlikely (GLRO(dl_naudit) > 0))\n    {\n      struct audit_ifaces *afct = GLRO(dl_audit);\n      for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)\n\t{\n\t  if (afct->activity != NULL)\n\t    afct->activity (&main_map->l_audit[cnt].cookie, LA_ACT_ADD);\n\n\t  afct = afct->next;\n\t}\n    }\n\n  /* We have two ways to specify objects to preload: via environment\n     variable and via the file /etc/ld.so.preload.  The latter can also\n     be used when security is enabled.  */\n  assert (*first_preload == NULL);\n  struct link_map **preloads = NULL;\n  unsigned int npreloads = 0;\n\n  if (__glibc_unlikely (preloadlist != NULL))\n    {\n      HP_TIMING_NOW (start);\n      npreloads += handle_ld_preload (preloadlist, main_map);\n      HP_TIMING_NOW (stop);\n      HP_TIMING_DIFF (diff, start, stop);\n      HP_TIMING_ACCUM_NT (load_time, diff);\n    }\n\n  /* There usually is no ld.so.preload file, it should only be used\n     for emergencies and testing.  So the open call etc should usually\n     fail.  Using access() on a non-existing file is faster than using\n     open().  So we do this first.  If it succeeds we do almost twice\n     the work but this does not matter, since it is not for production\n     use.  */\n  static const char preload_file[] = \"/etc/ld.so.preload\";\n  if (__glibc_unlikely (__access (preload_file, R_OK) == 0))\n    {\n      /* Read the contents of the file.  */\n      file = _dl_sysdep_read_whole_file (preload_file, &file_size,\n\t\t\t\t\t PROT_READ | PROT_WRITE);\n      if (__glibc_unlikely (file != MAP_FAILED))\n\t{\n\t  /* Parse the file.  It contains names of libraries to be loaded,\n\t     separated by white spaces or `:'.  It may also contain\n\t     comments introduced by `#'.  */\n\t  char *problem;\n\t  char *runp;\n\t  size_t rest;\n\n\t  /* Eliminate comments.  */\n\t  runp = file;\n\t  rest = file_size;\n\t  while (rest > 0)\n\t    {\n\t      char *comment = memchr (runp, '#', rest);\n\t      if (comment == NULL)\n\t\tbreak;\n\n\t      rest -= comment - runp;\n\t      do\n\t\t*comment = ' ';\n\t      while (--rest > 0 && *++comment != '\\n');\n\t    }\n\n\t  /* We have one problematic case: if we have a name at the end of\n\t     the file without a trailing terminating characters, we cannot\n\t     place the \\0.  Handle the case separately.  */\n\t  if (file[file_size - 1] != ' ' && file[file_size - 1] != '\\t'\n\t      && file[file_size - 1] != '\\n' && file[file_size - 1] != ':')\n\t    {\n\t      problem = &file[file_size];\n\t      while (problem > file && problem[-1] != ' '\n\t\t     && problem[-1] != '\\t'\n\t\t     && problem[-1] != '\\n' && problem[-1] != ':')\n\t\t--problem;\n\n\t      if (problem > file)\n\t\tproblem[-1] = '\\0';\n\t    }\n\t  else\n\t    {\n\t      problem = NULL;\n\t      file[file_size - 1] = '\\0';\n\t    }\n\n\t  HP_TIMING_NOW (start);\n\n\t  if (file != problem)\n\t    {\n\t      char *p;\n\t      runp = file;\n\t      while ((p = strsep (&runp, \": \\t\\n\")) != NULL)\n\t\tif (p[0] != '\\0')\n\t\t  npreloads += do_preload (p, main_map, preload_file);\n\t    }\n\n\t  if (problem != NULL)\n\t    {\n\t      char *p = strndupa (problem, file_size - (problem - file));\n\n\t      npreloads += do_preload (p, main_map, preload_file);\n\t    }\n\n\t  HP_TIMING_NOW (stop);\n\t  HP_TIMING_DIFF (diff, start, stop);\n\t  HP_TIMING_ACCUM_NT (load_time, diff);\n\n\t  /* We don't need the file anymore.  */\n\t  __munmap (file, file_size);\n\t}\n    }\n\n  if (__glibc_unlikely (*first_preload != NULL))\n    {\n      /* Set up PRELOADS with a vector of the preloaded libraries.  */\n      struct link_map *l = *first_preload;\n      preloads = __alloca (npreloads * sizeof preloads[0]);\n      i = 0;\n      do\n\t{\n\t  preloads[i++] = l;\n\t  l = l->l_next;\n\t} while (l);\n      assert (i == npreloads);\n    }\n\n  /* Load all the libraries specified by DT_NEEDED entries.  If LD_PRELOAD\n     specified some libraries to load, these are inserted before the actual\n     dependencies in the executable's searchlist for symbol resolution.  */\n  HP_TIMING_NOW (start);\n  _dl_map_object_deps (main_map, preloads, npreloads, mode == trace, 0);\n  HP_TIMING_NOW (stop);\n  HP_TIMING_DIFF (diff, start, stop);\n  HP_TIMING_ACCUM_NT (load_time, diff);\n\n  /* Mark all objects as being in the global scope.  */\n  for (i = main_map->l_searchlist.r_nlist; i > 0; )\n    main_map->l_searchlist.r_list[--i]->l_global = 1;\n\n  /* Remove _dl_rtld_map from the chain.  */\n  GL(dl_rtld_map).l_prev->l_next = GL(dl_rtld_map).l_next;\n  if (GL(dl_rtld_map).l_next != NULL)\n    GL(dl_rtld_map).l_next->l_prev = GL(dl_rtld_map).l_prev;\n\n  for (i = 1; i < main_map->l_searchlist.r_nlist; ++i)\n    if (main_map->l_searchlist.r_list[i] == &GL(dl_rtld_map))\n      break;\n\n  bool rtld_multiple_ref = false;\n  if (__glibc_likely (i < main_map->l_searchlist.r_nlist))\n    {\n      /* Some DT_NEEDED entry referred to the interpreter object itself, so\n\t put it back in the list of visible objects.  We insert it into the\n\t chain in symbol search order because gdb uses the chain's order as\n\t its symbol search order.  */\n      rtld_multiple_ref = true;\n\n      GL(dl_rtld_map).l_prev = main_map->l_searchlist.r_list[i - 1];\n      if (__builtin_expect (mode, normal) == normal)\n\t{\n\t  GL(dl_rtld_map).l_next = (i + 1 < main_map->l_searchlist.r_nlist\n\t\t\t\t    ? main_map->l_searchlist.r_list[i + 1]\n\t\t\t\t    : NULL);\n#ifdef NEED_DL_SYSINFO_DSO\n\t  if (GLRO(dl_sysinfo_map) != NULL\n\t      && GL(dl_rtld_map).l_prev->l_next == GLRO(dl_sysinfo_map)\n\t      && GL(dl_rtld_map).l_next != GLRO(dl_sysinfo_map))\n\t    GL(dl_rtld_map).l_prev = GLRO(dl_sysinfo_map);\n#endif\n\t}\n      else\n\t/* In trace mode there might be an invisible object (which we\n\t   could not find) after the previous one in the search list.\n\t   In this case it doesn't matter much where we put the\n\t   interpreter object, so we just initialize the list pointer so\n\t   that the assertion below holds.  */\n\tGL(dl_rtld_map).l_next = GL(dl_rtld_map).l_prev->l_next;\n\n      assert (GL(dl_rtld_map).l_prev->l_next == GL(dl_rtld_map).l_next);\n      GL(dl_rtld_map).l_prev->l_next = &GL(dl_rtld_map);\n      if (GL(dl_rtld_map).l_next != NULL)\n\t{\n\t  assert (GL(dl_rtld_map).l_next->l_prev == GL(dl_rtld_map).l_prev);\n\t  GL(dl_rtld_map).l_next->l_prev = &GL(dl_rtld_map);\n\t}\n    }\n\n  /* Now let us see whether all libraries are available in the\n     versions we need.  */\n  {\n    struct version_check_args args;\n    args.doexit = mode == normal;\n    args.dotrace = mode == trace;\n    _dl_receive_error (print_missing_version, version_check_doit, &args);\n  }\n\n  /* We do not initialize any of the TLS functionality unless any of the\n     initial modules uses TLS.  This makes dynamic loading of modules with\n     TLS impossible, but to support it requires either eagerly doing setup\n     now or lazily doing it later.  Doing it now makes us incompatible with\n     an old kernel that can't perform TLS_INIT_TP, even if no TLS is ever\n     used.  Trying to do it lazily is too hairy to try when there could be\n     multiple threads (from a non-TLS-using libpthread).  */\n  bool was_tls_init_tp_called = tls_init_tp_called;\n  if (tcbp == NULL)\n    tcbp = init_tls ();\n\n  if (__glibc_likely (need_security_init))\n    /* Initialize security features.  But only if we have not done it\n       earlier.  */\n    security_init ();\n\n  if (__builtin_expect (mode, normal) != normal)\n    {\n      /* We were run just to list the shared libraries.  It is\n\t important that we do this before real relocation, because the\n\t functions we call below for output may no longer work properly\n\t after relocation.  */\n      struct link_map *l;\n\n      if (GLRO(dl_debug_mask) & DL_DEBUG_PRELINK)\n\t{\n\t  struct r_scope_elem *scope = &main_map->l_searchlist;\n\n\t  for (i = 0; i < scope->r_nlist; i++)\n\t    {\n\t      l = scope->r_list [i];\n\t      if (l->l_faked)\n\t\t{\n\t\t  _dl_printf (\"\\t%s => not found\\n\", l->l_libname->name);\n\t\t  continue;\n\t\t}\n\t      if (_dl_name_match_p (GLRO(dl_trace_prelink), l))\n\t\tGLRO(dl_trace_prelink_map) = l;\n\t      _dl_printf (\"\\t%s => %s (0x%0*Zx, 0x%0*Zx)\",\n\t\t\t  DSO_FILENAME (l->l_libname->name),\n\t\t\t  DSO_FILENAME (l->l_name),\n\t\t\t  (int) sizeof l->l_map_start * 2,\n\t\t\t  (size_t) l->l_map_start,\n\t\t\t  (int) sizeof l->l_addr * 2,\n\t\t\t  (size_t) l->l_addr);\n\n\t      if (l->l_tls_modid)\n\t\t_dl_printf (\" TLS(0x%Zx, 0x%0*Zx)\\n\", l->l_tls_modid,\n\t\t\t    (int) sizeof l->l_tls_offset * 2,\n\t\t\t    (size_t) l->l_tls_offset);\n\t      else\n\t\t_dl_printf (\"\\n\");\n\t    }\n\t}\n      else if (GLRO(dl_debug_mask) & DL_DEBUG_UNUSED)\n\t{\n\t  /* Look through the dependencies of the main executable\n\t     and determine which of them is not actually\n\t     required.  */\n\t  struct link_map *l = main_map;\n\n\t  /* Relocate the main executable.  */\n\t  struct relocate_args args = { .l = l,\n\t\t\t\t\t.reloc_mode = ((GLRO(dl_lazy)\n\t\t\t\t\t\t       ? RTLD_LAZY : 0)\n\t\t\t\t\t\t       | __RTLD_NOIFUNC) };\n\t  _dl_receive_error (print_unresolved, relocate_doit, &args);\n\n\t  /* This loop depends on the dependencies of the executable to\n\t     correspond in number and order to the DT_NEEDED entries.  */\n\t  ElfW(Dyn) *dyn = main_map->l_ld;\n\t  bool first = true;\n\t  while (dyn->d_tag != DT_NULL)\n\t    {\n\t      if (dyn->d_tag == DT_NEEDED)\n\t\t{\n\t\t  l = l->l_next;\n#ifdef NEED_DL_SYSINFO_DSO\n\t\t  /* Skip the VDSO since it's not part of the list\n\t\t     of objects we brought in via DT_NEEDED entries.  */\n\t\t  if (l == GLRO(dl_sysinfo_map))\n\t\t    l = l->l_next;\n#endif\n\t\t  if (!l->l_used)\n\t\t    {\n\t\t      if (first)\n\t\t\t{\n\t\t\t  _dl_printf (\"Unused direct dependencies:\\n\");\n\t\t\t  first = false;\n\t\t\t}\n\n\t\t      _dl_printf (\"\\t%s\\n\", l->l_name);\n\t\t    }\n\t\t}\n\n\t      ++dyn;\n\t    }\n\n\t  _exit (first != true);\n\t}\n      else if (! main_map->l_info[DT_NEEDED])\n\t_dl_printf (\"\\tstatically linked\\n\");\n      else\n\t{\n\t  for (l = main_map->l_next; l; l = l->l_next)\n\t    if (l->l_faked)\n\t      /* The library was not found.  */\n\t      _dl_printf (\"\\t%s => not found\\n\", l->l_libname->name);\n\t    else if (strcmp (l->l_libname->name, l->l_name) == 0)\n\t      _dl_printf (\"\\t%s (0x%0*Zx)\\n\", l->l_libname->name,\n\t\t\t  (int) sizeof l->l_map_start * 2,\n\t\t\t  (size_t) l->l_map_start);\n\t    else\n\t      _dl_printf (\"\\t%s => %s (0x%0*Zx)\\n\", l->l_libname->name,\n\t\t\t  l->l_name, (int) sizeof l->l_map_start * 2,\n\t\t\t  (size_t) l->l_map_start);\n\t}\n\n      if (__builtin_expect (mode, trace) != trace)\n\tfor (i = 1; i < (unsigned int) _dl_argc; ++i)\n\t  {\n\t    const ElfW(Sym) *ref = NULL;\n\t    ElfW(Addr) loadbase;\n\t    lookup_t result;\n\n\t    result = _dl_lookup_symbol_x (_dl_argv[i], main_map,\n\t\t\t\t\t  &ref, main_map->l_scope,\n\t\t\t\t\t  NULL, ELF_RTYPE_CLASS_PLT,\n\t\t\t\t\t  DL_LOOKUP_ADD_DEPENDENCY, NULL);\n\n\t    loadbase = LOOKUP_VALUE_ADDRESS (result, false);\n\n\t    _dl_printf (\"%s found at 0x%0*Zd in object at 0x%0*Zd\\n\",\n\t\t\t_dl_argv[i],\n\t\t\t(int) sizeof ref->st_value * 2,\n\t\t\t(size_t) ref->st_value,\n\t\t\t(int) sizeof loadbase * 2, (size_t) loadbase);\n\t  }\n      else\n\t{\n\t  /* If LD_WARN is set, warn about undefined symbols.  */\n\t  if (GLRO(dl_lazy) >= 0 && GLRO(dl_verbose))\n\t    {\n\t      /* We have to do symbol dependency testing.  */\n\t      struct relocate_args args;\n\t      unsigned int i;\n\n\t      args.reloc_mode = ((GLRO(dl_lazy) ? RTLD_LAZY : 0)\n\t\t\t\t | __RTLD_NOIFUNC);\n\n\t      i = main_map->l_searchlist.r_nlist;\n\t      while (i-- > 0)\n\t\t{\n\t\t  struct link_map *l = main_map->l_initfini[i];\n\t\t  if (l != &GL(dl_rtld_map) && ! l->l_faked)\n\t\t    {\n\t\t      args.l = l;\n\t\t      _dl_receive_error (print_unresolved, relocate_doit,\n\t\t\t\t\t &args);\n\t\t    }\n\t\t}\n\n\t      if ((GLRO(dl_debug_mask) & DL_DEBUG_PRELINK)\n\t\t  && rtld_multiple_ref)\n\t\t{\n\t\t  /* Mark the link map as not yet relocated again.  */\n\t\t  GL(dl_rtld_map).l_relocated = 0;\n\t\t  _dl_relocate_object (&GL(dl_rtld_map),\n\t\t\t\t       main_map->l_scope, __RTLD_NOIFUNC, 0);\n\t\t}\n\t    }\n#define VERNEEDTAG (DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGIDX (DT_VERNEED))\n\t  if (version_info)\n\t    {\n\t      /* Print more information.  This means here, print information\n\t\t about the versions needed.  */\n\t      int first = 1;\n\t      struct link_map *map;\n\n\t      for (map = main_map; map != NULL; map = map->l_next)\n\t\t{\n\t\t  const char *strtab;\n\t\t  ElfW(Dyn) *dyn = map->l_info[VERNEEDTAG];\n\t\t  ElfW(Verneed) *ent;\n\n\t\t  if (dyn == NULL)\n\t\t    continue;\n\n\t\t  strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);\n\t\t  ent = (ElfW(Verneed) *) (map->l_addr + dyn->d_un.d_ptr);\n\n\t\t  if (first)\n\t\t    {\n\t\t      _dl_printf (\"\\n\\tVersion information:\\n\");\n\t\t      first = 0;\n\t\t    }\n\n\t\t  _dl_printf (\"\\t%s:\\n\", DSO_FILENAME (map->l_name));\n\n\t\t  while (1)\n\t\t    {\n\t\t      ElfW(Vernaux) *aux;\n\t\t      struct link_map *needed;\n\n\t\t      needed = find_needed (strtab + ent->vn_file);\n\t\t      aux = (ElfW(Vernaux) *) ((char *) ent + ent->vn_aux);\n\n\t\t      while (1)\n\t\t\t{\n\t\t\t  const char *fname = NULL;\n\n\t\t\t  if (needed != NULL\n\t\t\t      && match_version (strtab + aux->vna_name,\n\t\t\t\t\t\tneeded))\n\t\t\t    fname = needed->l_name;\n\n\t\t\t  _dl_printf (\"\\t\\t%s (%s) %s=> %s\\n\",\n\t\t\t\t      strtab + ent->vn_file,\n\t\t\t\t      strtab + aux->vna_name,\n\t\t\t\t      aux->vna_flags & VER_FLG_WEAK\n\t\t\t\t      ? \"[WEAK] \" : \"\",\n\t\t\t\t      fname ?: \"not found\");\n\n\t\t\t  if (aux->vna_next == 0)\n\t\t\t    /* No more symbols.  */\n\t\t\t    break;\n\n\t\t\t  /* Next symbol.  */\n\t\t\t  aux = (ElfW(Vernaux) *) ((char *) aux\n\t\t\t\t\t\t   + aux->vna_next);\n\t\t\t}\n\n\t\t      if (ent->vn_next == 0)\n\t\t\t/* No more dependencies.  */\n\t\t\tbreak;\n\n\t\t      /* Next dependency.  */\n\t\t      ent = (ElfW(Verneed) *) ((char *) ent + ent->vn_next);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n      _exit (0);\n    }\n\n  if (main_map->l_info[ADDRIDX (DT_GNU_LIBLIST)]\n      && ! __builtin_expect (GLRO(dl_profile) != NULL, 0)\n      && ! __builtin_expect (GLRO(dl_dynamic_weak), 0))\n    {\n      ElfW(Lib) *liblist, *liblistend;\n      struct link_map **r_list, **r_listend, *l;\n      const char *strtab = (const void *) D_PTR (main_map, l_info[DT_STRTAB]);\n\n      assert (main_map->l_info[VALIDX (DT_GNU_LIBLISTSZ)] != NULL);\n      liblist = (ElfW(Lib) *)\n\t\tmain_map->l_info[ADDRIDX (DT_GNU_LIBLIST)]->d_un.d_ptr;\n      liblistend = (ElfW(Lib) *)\n\t\t   ((char *) liblist +\n\t\t    main_map->l_info[VALIDX (DT_GNU_LIBLISTSZ)]->d_un.d_val);\n      r_list = main_map->l_searchlist.r_list;\n      r_listend = r_list + main_map->l_searchlist.r_nlist;\n\n      for (; r_list < r_listend && liblist < liblistend; r_list++)\n\t{\n\t  l = *r_list;\n\n\t  if (l == main_map)\n\t    continue;\n\n\t  /* If the library is not mapped where it should, fail.  */\n\t  if (l->l_addr)\n\t    break;\n\n\t  /* Next, check if checksum matches.  */\n\t  if (l->l_info [VALIDX(DT_CHECKSUM)] == NULL\n\t      || l->l_info [VALIDX(DT_CHECKSUM)]->d_un.d_val\n\t\t != liblist->l_checksum)\n\t    break;\n\n\t  if (l->l_info [VALIDX(DT_GNU_PRELINKED)] == NULL\n\t      || l->l_info [VALIDX(DT_GNU_PRELINKED)]->d_un.d_val\n\t\t != liblist->l_time_stamp)\n\t    break;\n\n\t  if (! _dl_name_match_p (strtab + liblist->l_name, l))\n\t    break;\n\n\t  ++liblist;\n\t}\n\n\n      if (r_list == r_listend && liblist == liblistend)\n\tprelinked = true;\n\n      if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_LIBS))\n\t_dl_debug_printf (\"\\nprelink checking: %s\\n\",\n\t\t\t  prelinked ? \"ok\" : \"failed\");\n    }\n\n\n  /* Now set up the variable which helps the assembler startup code.  */\n  GL(dl_ns)[LM_ID_BASE]._ns_main_searchlist = &main_map->l_searchlist;\n\n  /* Save the information about the original global scope list since\n     we need it in the memory handling later.  */\n  GLRO(dl_initial_searchlist) = *GL(dl_ns)[LM_ID_BASE]._ns_main_searchlist;\n\n  /* Remember the last search directory added at startup, now that\n     malloc will no longer be the one from dl-minimal.c.  As a side\n     effect, this marks ld.so as initialized, so that the rtld_active\n     function returns true from now on.  */\n  GLRO(dl_init_all_dirs) = GL(dl_all_dirs);\n\n  /* Print scope information.  */\n  if (__glibc_unlikely (GLRO(dl_debug_mask) & DL_DEBUG_SCOPES))\n    {\n      _dl_debug_printf (\"\\nInitial object scopes\\n\");\n\n      for (struct link_map *l = main_map; l != NULL; l = l->l_next)\n\t_dl_show_scope (l, 0);\n    }\n\n  _rtld_main_check (main_map, _dl_argv[0]);\n\n  if (prelinked)\n    {\n      if (main_map->l_info [ADDRIDX (DT_GNU_CONFLICT)] != NULL)\n\t{\n\t  ElfW(Rela) *conflict, *conflictend;\n#ifndef HP_TIMING_NONAVAIL\n\t  hp_timing_t start;\n\t  hp_timing_t stop;\n#endif\n\n\t  HP_TIMING_NOW (start);\n\t  assert (main_map->l_info [VALIDX (DT_GNU_CONFLICTSZ)] != NULL);\n\t  conflict = (ElfW(Rela) *)\n\t    main_map->l_info [ADDRIDX (DT_GNU_CONFLICT)]->d_un.d_ptr;\n\t  conflictend = (ElfW(Rela) *)\n\t    ((char *) conflict\n\t     + main_map->l_info [VALIDX (DT_GNU_CONFLICTSZ)]->d_un.d_val);\n\t  _dl_resolve_conflicts (main_map, conflict, conflictend);\n\t  HP_TIMING_NOW (stop);\n\t  HP_TIMING_DIFF (relocate_time, start, stop);\n\t}\n\n\n      /* Mark all the objects so we know they have been already relocated.  */\n      for (struct link_map *l = main_map; l != NULL; l = l->l_next)\n\t{\n\t  l->l_relocated = 1;\n\t  if (l->l_relro_size)\n\t    _dl_protect_relro (l);\n\n\t  /* Add object to slot information data if necessasy.  */\n\t  if (l->l_tls_blocksize != 0 && tls_init_tp_called)\n\t    _dl_add_to_slotinfo (l);\n\t}\n    }\n  else\n    {\n      /* Now we have all the objects loaded.  Relocate them all except for\n\t the dynamic linker itself.  We do this in reverse order so that copy\n\t relocs of earlier objects overwrite the data written by later\n\t objects.  We do not re-relocate the dynamic linker itself in this\n\t loop because that could result in the GOT entries for functions we\n\t call being changed, and that would break us.  It is safe to relocate\n\t the dynamic linker out of order because it has no copy relocs (we\n\t know that because it is self-contained).  */\n\n      int consider_profiling = GLRO(dl_profile) != NULL;\n#ifndef HP_TIMING_NONAVAIL\n      hp_timing_t start;\n      hp_timing_t stop;\n#endif\n\n      /* If we are profiling we also must do lazy reloaction.  */\n      GLRO(dl_lazy) |= consider_profiling;\n\n      HP_TIMING_NOW (start);\n      unsigned i = main_map->l_searchlist.r_nlist;\n      while (i-- > 0)\n\t{\n\t  struct link_map *l = main_map->l_initfini[i];\n\n\t  /* While we are at it, help the memory handling a bit.  We have to\n\t     mark some data structures as allocated with the fake malloc()\n\t     implementation in ld.so.  */\n\t  struct libname_list *lnp = l->l_libname->next;\n\n\t  while (__builtin_expect (lnp != NULL, 0))\n\t    {\n\t      lnp->dont_free = 1;\n\t      lnp = lnp->next;\n\t    }\n\t  /* Also allocated with the fake malloc().  */\n\t  l->l_free_initfini = 0;\n\n\t  if (l != &GL(dl_rtld_map))\n\t    _dl_relocate_object (l, l->l_scope, GLRO(dl_lazy) ? RTLD_LAZY : 0,\n\t\t\t\t consider_profiling);\n\n\t  /* Add object to slot information data if necessasy.  */\n\t  if (l->l_tls_blocksize != 0 && tls_init_tp_called)\n\t    _dl_add_to_slotinfo (l);\n\t}\n      HP_TIMING_NOW (stop);\n\n      HP_TIMING_DIFF (relocate_time, start, stop);\n\n      /* Now enable profiling if needed.  Like the previous call,\n\t this has to go here because the calls it makes should use the\n\t rtld versions of the functions (particularly calloc()), but it\n\t needs to have _dl_profile_map set up by the relocator.  */\n      if (__glibc_unlikely (GL(dl_profile_map) != NULL))\n\t/* We must prepare the profiling.  */\n\t_dl_start_profile ();\n    }\n\n  if ((!was_tls_init_tp_called && GL(dl_tls_max_dtv_idx) > 0)\n      || count_modids != _dl_count_modids ())\n    ++GL(dl_tls_generation);\n\n  /* Now that we have completed relocation, the initializer data\n     for the TLS blocks has its final values and we can copy them\n     into the main thread's TLS area, which we allocated above.\n     Note: thread-local variables must only be accessed after completing\n     the next step.  */\n  _dl_allocate_tls_init (tcbp);\n\n  /* And finally install it for the main thread.  */\n  if (! tls_init_tp_called)\n    {\n      const char *lossage = TLS_INIT_TP (tcbp);\n      if (__glibc_unlikely (lossage != NULL))\n\t_dl_fatal_printf (\"cannot set up thread-local storage: %s\\n\",\n\t\t\t  lossage);\n    }\n\n  /* Make sure no new search directories have been added.  */\n  assert (GLRO(dl_init_all_dirs) == GL(dl_all_dirs));\n\n  if (! prelinked && rtld_multiple_ref)\n    {\n      /* There was an explicit ref to the dynamic linker as a shared lib.\n\t Re-relocate ourselves with user-controlled symbol definitions.\n\n\t We must do this after TLS initialization in case after this\n\t re-relocation, we might call a user-supplied function\n\t (e.g. calloc from _dl_relocate_object) that uses TLS data.  */\n\n#ifndef HP_TIMING_NONAVAIL\n      hp_timing_t start;\n      hp_timing_t stop;\n      hp_timing_t add;\n#endif\n\n      HP_TIMING_NOW (start);\n      /* Mark the link map as not yet relocated again.  */\n      GL(dl_rtld_map).l_relocated = 0;\n      _dl_relocate_object (&GL(dl_rtld_map), main_map->l_scope, 0, 0);\n      HP_TIMING_NOW (stop);\n      HP_TIMING_DIFF (add, start, stop);\n      HP_TIMING_ACCUM_NT (relocate_time, add);\n    }\n\n  /* Do any necessary cleanups for the startup OS interface code.\n     We do these now so that no calls are made after rtld re-relocation\n     which might be resolved to different functions than we expect.\n     We cannot do this before relocating the other objects because\n     _dl_relocate_object might need to call `mprotect' for DT_TEXTREL.  */\n  _dl_sysdep_start_cleanup ();\n\n#ifdef SHARED\n  /* Auditing checkpoint: we have added all objects.  */\n  if (__glibc_unlikely (GLRO(dl_naudit) > 0))\n    {\n      struct link_map *head = GL(dl_ns)[LM_ID_BASE]._ns_loaded;\n      /* Do not call the functions for any auditing object.  */\n      if (head->l_auditing == 0)\n\t{\n\t  struct audit_ifaces *afct = GLRO(dl_audit);\n\t  for (unsigned int cnt = 0; cnt < GLRO(dl_naudit); ++cnt)\n\t    {\n\t      if (afct->activity != NULL)\n\t\tafct->activity (&head->l_audit[cnt].cookie, LA_ACT_CONSISTENT);\n\n\t      afct = afct->next;\n\t    }\n\t}\n    }\n#endif\n\n  /* Notify the debugger all new objects are now ready to go.  We must re-get\n     the address since by now the variable might be in another object.  */\n  r = _dl_debug_initialize (0, LM_ID_BASE);\n  r->r_state = RT_CONSISTENT;\n  _dl_debug_state ();\n  LIBC_PROBE (init_complete, 2, LM_ID_BASE, r);\n\n#if defined USE_LDCONFIG && !defined MAP_COPY\n  /* We must munmap() the cache file.  */\n  _dl_unload_cache ();\n#endif\n\n  /* Once we return, _dl_sysdep_start will invoke\n     the DT_INIT functions and then *USER_ENTRY.  */\n}\n\f\n/* This is a little helper function for resolving symbols while\n   tracing the binary.  */\nstatic void\nprint_unresolved (int errcode __attribute__ ((unused)), const char *objname,\n\t\t  const char *errstring)\n{\n  if (objname[0] == '\\0')\n    objname = RTLD_PROGNAME;\n  _dl_error_printf (\"%s\t(%s)\\n\", errstring, objname);\n}\n\f\n/* This is a little helper function for resolving symbols while\n   tracing the binary.  */\nstatic void\nprint_missing_version (int errcode __attribute__ ((unused)),\n\t\t       const char *objname, const char *errstring)\n{\n  _dl_error_printf (\"%s: %s: %s\\n\", RTLD_PROGNAME,\n\t\t    objname, errstring);\n}\n\f\n/* Nonzero if any of the debugging options is enabled.  */\nstatic int any_debug attribute_relro;\n\n/* Process the string given as the parameter which explains which debugging\n   options are enabled.  */\nstatic void\nprocess_dl_debug (const char *dl_debug)\n{\n  /* When adding new entries make sure that the maximal length of a name\n     is correctly handled in the LD_DEBUG_HELP code below.  */\n  static const struct\n  {\n    unsigned char len;\n    const char name[10];\n    const char helptext[41];\n    unsigned short int mask;\n  } debopts[] =\n    {\n#define LEN_AND_STR(str) sizeof (str) - 1, str\n      { LEN_AND_STR (\"libs\"), \"display library search paths\",\n\tDL_DEBUG_LIBS | DL_DEBUG_IMPCALLS },\n      { LEN_AND_STR (\"reloc\"), \"display relocation processing\",\n\tDL_DEBUG_RELOC | DL_DEBUG_IMPCALLS },\n      { LEN_AND_STR (\"files\"), \"display progress for input file\",\n\tDL_DEBUG_FILES | DL_DEBUG_IMPCALLS },\n      { LEN_AND_STR (\"symbols\"), \"display symbol table processing\",\n\tDL_DEBUG_SYMBOLS | DL_DEBUG_IMPCALLS },\n      { LEN_AND_STR (\"bindings\"), \"display information about symbol binding\",\n\tDL_DEBUG_BINDINGS | DL_DEBUG_IMPCALLS },\n      { LEN_AND_STR (\"versions\"), \"display version dependencies\",\n\tDL_DEBUG_VERSIONS | DL_DEBUG_IMPCALLS },\n      { LEN_AND_STR (\"scopes\"), \"display scope information\",\n\tDL_DEBUG_SCOPES },\n      { LEN_AND_STR (\"all\"), \"all previous options combined\",\n\tDL_DEBUG_LIBS | DL_DEBUG_RELOC | DL_DEBUG_FILES | DL_DEBUG_SYMBOLS\n\t| DL_DEBUG_BINDINGS | DL_DEBUG_VERSIONS | DL_DEBUG_IMPCALLS\n\t| DL_DEBUG_SCOPES },\n      { LEN_AND_STR (\"statistics\"), \"display relocation statistics\",\n\tDL_DEBUG_STATISTICS },\n      { LEN_AND_STR (\"unused\"), \"determined unused DSOs\",\n\tDL_DEBUG_UNUSED },\n      { LEN_AND_STR (\"help\"), \"display this help message and exit\",\n\tDL_DEBUG_HELP },\n    };\n#define ndebopts (sizeof (debopts) / sizeof (debopts[0]))\n\n  /* Skip separating white spaces and commas.  */\n  while (*dl_debug != '\\0')\n    {\n      if (*dl_debug != ' ' && *dl_debug != ',' && *dl_debug != ':')\n\t{\n\t  size_t cnt;\n\t  size_t len = 1;\n\n\t  while (dl_debug[len] != '\\0' && dl_debug[len] != ' '\n\t\t && dl_debug[len] != ',' && dl_debug[len] != ':')\n\t    ++len;\n\n\t  for (cnt = 0; cnt < ndebopts; ++cnt)\n\t    if (debopts[cnt].len == len\n\t\t&& memcmp (dl_debug, debopts[cnt].name, len) == 0)\n\t      {\n\t\tGLRO(dl_debug_mask) |= debopts[cnt].mask;\n\t\tany_debug = 1;\n\t\tbreak;\n\t      }\n\n\t  if (cnt == ndebopts)\n\t    {\n\t      /* Display a warning and skip everything until next\n\t\t separator.  */\n\t      char *copy = strndupa (dl_debug, len);\n\t      _dl_error_printf (\"\\\nwarning: debug option `%s' unknown; try LD_DEBUG=help\\n\", copy);\n\t    }\n\n\t  dl_debug += len;\n\t  continue;\n\t}\n\n      ++dl_debug;\n    }\n\n  if (GLRO(dl_debug_mask) & DL_DEBUG_UNUSED)\n    {\n      /* In order to get an accurate picture of whether a particular\n\t DT_NEEDED entry is actually used we have to process both\n\t the PLT and non-PLT relocation entries.  */\n      GLRO(dl_lazy) = 0;\n    }\n\n  if (GLRO(dl_debug_mask) & DL_DEBUG_HELP)\n    {\n      size_t cnt;\n\n      _dl_printf (\"\\\nValid options for the LD_DEBUG environment variable are:\\n\\n\");\n\n      for (cnt = 0; cnt < ndebopts; ++cnt)\n\t_dl_printf (\"  %.*s%s%s\\n\", debopts[cnt].len, debopts[cnt].name,\n\t\t    \"         \" + debopts[cnt].len - 3,\n\t\t    debopts[cnt].helptext);\n\n      _dl_printf (\"\\n\\\nTo direct the debugging output into a file instead of standard output\\n\\\na filename can be specified using the LD_DEBUG_OUTPUT environment variable.\\n\");\n      _exit (0);\n    }\n}\n\f\nstatic void\nprocess_dl_audit (char *str)\n{\n  /* The parameter is a colon separated list of DSO names.  */\n  char *p;\n\n  while ((p = (strsep) (&str, \":\")) != NULL)\n    if (dso_name_valid_for_suid (p))\n      {\n\t/* This is using the local malloc, not the system malloc.  The\n\t   memory can never be freed.  */\n\tstruct audit_list *newp = malloc (sizeof (*newp));\n\tnewp->name = p;\n\n\tif (audit_list == NULL)\n\t  audit_list = newp->next = newp;\n\telse\n\t  {\n\t    newp->next = audit_list->next;\n\t    audit_list = audit_list->next = newp;\n\t  }\n      }\n}\n\f\n/* Process all environments variables the dynamic linker must recognize.\n   Since all of them start with `LD_' we are a bit smarter while finding\n   all the entries.  */\nextern char **_environ attribute_hidden;\n\n\nstatic void\nprocess_envvars (enum mode *modep)\n{\n  char **runp = _environ;\n  char *envline;\n  enum mode mode = normal;\n  char *debug_output = NULL;\n\n  /* This is the default place for profiling data file.  */\n  GLRO(dl_profile_output)\n    = &\"/var/tmp\\0/var/profile\"[__libc_enable_secure ? 9 : 0];\n\n  while ((envline = _dl_next_ld_env_entry (&runp)) != NULL)\n    {\n      size_t len = 0;\n\n      while (envline[len] != '\\0' && envline[len] != '=')\n\t++len;\n\n      if (envline[len] != '=')\n\t/* This is a \"LD_\" variable at the end of the string without\n\t   a '=' character.  Ignore it since otherwise we will access\n\t   invalid memory below.  */\n\tcontinue;\n\n      switch (len)\n\t{\n\tcase 4:\n\t  /* Warning level, verbose or not.  */\n\t  if (memcmp (envline, \"WARN\", 4) == 0)\n\t    GLRO(dl_verbose) = envline[5] != '\\0';\n\t  break;\n\n\tcase 5:\n\t  /* Debugging of the dynamic linker?  */\n\t  if (memcmp (envline, \"DEBUG\", 5) == 0)\n\t    {\n\t      process_dl_debug (&envline[6]);\n\t      break;\n\t    }\n\t  if (memcmp (envline, \"AUDIT\", 5) == 0)\n\t    audit_list_string = &envline[6];\n\t  break;\n\n\tcase 7:\n\t  /* Print information about versions.  */\n\t  if (memcmp (envline, \"VERBOSE\", 7) == 0)\n\t    {\n\t      version_info = envline[8] != '\\0';\n\t      break;\n\t    }\n\n\t  /* List of objects to be preloaded.  */\n\t  if (memcmp (envline, \"PRELOAD\", 7) == 0)\n\t    {\n\t      preloadlist = &envline[8];\n\t      break;\n\t    }\n\n\t  /* Which shared object shall be profiled.  */\n\t  if (memcmp (envline, \"PROFILE\", 7) == 0 && envline[8] != '\\0')\n\t    GLRO(dl_profile) = &envline[8];\n\t  break;\n\n\tcase 8:\n\t  /* Do we bind early?  */\n\t  if (memcmp (envline, \"BIND_NOW\", 8) == 0)\n\t    {\n\t      GLRO(dl_lazy) = envline[9] == '\\0';\n\t      break;\n\t    }\n\t  if (memcmp (envline, \"BIND_NOT\", 8) == 0)\n\t    GLRO(dl_bind_not) = envline[9] != '\\0';\n\t  break;\n\n\tcase 9:\n\t  /* Test whether we want to see the content of the auxiliary\n\t     array passed up from the kernel.  */\n\t  if (!__libc_enable_secure\n\t      && memcmp (envline, \"SHOW_AUXV\", 9) == 0)\n\t    _dl_show_auxv ();\n\t  break;\n\n#if !HAVE_TUNABLES\n\tcase 10:\n\t  /* Mask for the important hardware capabilities.  */\n\t  if (!__libc_enable_secure\n\t      && memcmp (envline, \"HWCAP_MASK\", 10) == 0)\n\t    GLRO(dl_hwcap_mask) = _dl_strtoul (&envline[11], NULL);\n\t  break;\n#endif\n\n\tcase 11:\n\t  /* Path where the binary is found.  */\n\t  if (!__libc_enable_secure\n\t      && memcmp (envline, \"ORIGIN_PATH\", 11) == 0)\n\t    GLRO(dl_origin_path) = &envline[12];\n\t  break;\n\n\tcase 12:\n\t  /* The library search path.  */\n\t  if (!__libc_enable_secure\n\t      && memcmp (envline, \"LIBRARY_PATH\", 12) == 0)\n\t    {\n\t      library_path = &envline[13];\n\t      break;\n\t    }\n\n\t  /* Where to place the profiling data file.  */\n\t  if (memcmp (envline, \"DEBUG_OUTPUT\", 12) == 0)\n\t    {\n\t      debug_output = &envline[13];\n\t      break;\n\t    }\n\n\t  if (!__libc_enable_secure\n\t      && memcmp (envline, \"DYNAMIC_WEAK\", 12) == 0)\n\t    GLRO(dl_dynamic_weak) = 1;\n\t  break;\n\n\tcase 13:\n\t  /* We might have some extra environment variable with length 13\n\t     to handle.  */\n#ifdef EXTRA_LD_ENVVARS_13\n\t  EXTRA_LD_ENVVARS_13\n#endif\n\t  if (!__libc_enable_secure\n\t      && memcmp (envline, \"USE_LOAD_BIAS\", 13) == 0)\n\t    {\n\t      GLRO(dl_use_load_bias) = envline[14] == '1' ? -1 : 0;\n\t      break;\n\t    }\n\t  break;\n\n\tcase 14:\n\t  /* Where to place the profiling data file.  */\n\t  if (!__libc_enable_secure\n\t      && memcmp (envline, \"PROFILE_OUTPUT\", 14) == 0\n\t      && envline[15] != '\\0')\n\t    GLRO(dl_profile_output) = &envline[15];\n\t  break;\n\n\tcase 16:\n\t  /* The mode of the dynamic linker can be set.  */\n\t  if (memcmp (envline, \"TRACE_PRELINKING\", 16) == 0)\n\t    {\n\t      mode = trace;\n\t      GLRO(dl_verbose) = 1;\n\t      GLRO(dl_debug_mask) |= DL_DEBUG_PRELINK;\n\t      GLRO(dl_trace_prelink) = &envline[17];\n\t    }\n\t  break;\n\n\tcase 20:\n\t  /* The mode of the dynamic linker can be set.  */\n\t  if (memcmp (envline, \"TRACE_LOADED_OBJECTS\", 20) == 0)\n\t    mode = trace;\n\t  break;\n\n\t  /* We might have some extra environment variable to handle.  This\n\t     is tricky due to the pre-processing of the length of the name\n\t     in the switch statement here.  The code here assumes that added\n\t     environment variables have a different length.  */\n#ifdef EXTRA_LD_ENVVARS\n\t  EXTRA_LD_ENVVARS\n#endif\n\t}\n    }\n\n  /* The caller wants this information.  */\n  *modep = mode;\n\n  /* Extra security for SUID binaries.  Remove all dangerous environment\n     variables.  */\n  if (__builtin_expect (__libc_enable_secure, 0))\n    {\n      static const char unsecure_envvars[] =\n#ifdef EXTRA_UNSECURE_ENVVARS\n\tEXTRA_UNSECURE_ENVVARS\n#endif\n\tUNSECURE_ENVVARS;\n      const char *nextp;\n\n      nextp = unsecure_envvars;\n      do\n\t{\n\t  unsetenv (nextp);\n\t  /* We could use rawmemchr but this need not be fast.  */\n\t  nextp = (char *) (strchr) (nextp, '\\0') + 1;\n\t}\n      while (*nextp != '\\0');\n\n      if (__access (\"/etc/suid-debug\", F_OK) != 0)\n\t{\n#if !HAVE_TUNABLES\n\t  unsetenv (\"MALLOC_CHECK_\");\n#endif\n\t  GLRO(dl_debug_mask) = 0;\n\t}\n\n      if (mode != normal)\n\t_exit (5);\n    }\n  /* If we have to run the dynamic linker in debugging mode and the\n     LD_DEBUG_OUTPUT environment variable is given, we write the debug\n     messages to this file.  */\n  else if (any_debug && debug_output != NULL)\n    {\n      const int flags = O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW;\n      size_t name_len = strlen (debug_output);\n      char buf[name_len + 12];\n      char *startp;\n\n      buf[name_len + 11] = '\\0';\n      startp = _itoa (__getpid (), &buf[name_len + 11], 10, 0);\n      *--startp = '.';\n      startp = memcpy (startp - name_len, debug_output, name_len);\n\n      GLRO(dl_debug_fd) = __open64_nocancel (startp, flags, DEFFILEMODE);\n      if (GLRO(dl_debug_fd) == -1)\n\t/* We use standard output if opening the file failed.  */\n\tGLRO(dl_debug_fd) = STDOUT_FILENO;\n    }\n}\n\n\n/* Print the various times we collected.  */\nstatic void\n__attribute ((noinline))\nprint_statistics (hp_timing_t *rtld_total_timep)\n{\n#ifndef HP_TIMING_NONAVAIL\n  char buf[200];\n  char *cp;\n  char *wp;\n\n  /* Total time rtld used.  */\n  if (HP_SMALL_TIMING_AVAIL)\n    {\n      HP_TIMING_PRINT (buf, sizeof (buf), *rtld_total_timep);\n      _dl_debug_printf (\"\\nruntime linker statistics:\\n\"\n\t\t\t\"  total startup time in dynamic loader: %s\\n\", buf);\n\n      /* Print relocation statistics.  */\n      char pbuf[30];\n      HP_TIMING_PRINT (buf, sizeof (buf), relocate_time);\n      cp = _itoa ((1000ULL * relocate_time) / *rtld_total_timep,\n\t\t  pbuf + sizeof (pbuf), 10, 0);\n      wp = pbuf;\n      switch (pbuf + sizeof (pbuf) - cp)\n\t{\n\tcase 3:\n\t  *wp++ = *cp++;\n\tcase 2:\n\t  *wp++ = *cp++;\n\tcase 1:\n\t  *wp++ = '.';\n\t  *wp++ = *cp++;\n\t}\n      *wp = '\\0';\n      _dl_debug_printf (\"\\\n\t    time needed for relocation: %s (%s%%)\\n\", buf, pbuf);\n    }\n#endif\n\n  unsigned long int num_relative_relocations = 0;\n  for (Lmid_t ns = 0; ns < GL(dl_nns); ++ns)\n    {\n      if (GL(dl_ns)[ns]._ns_loaded == NULL)\n\tcontinue;\n\n      struct r_scope_elem *scope = &GL(dl_ns)[ns]._ns_loaded->l_searchlist;\n\n      for (unsigned int i = 0; i < scope->r_nlist; i++)\n\t{\n\t  struct link_map *l = scope->r_list [i];\n\n\t  if (l->l_addr != 0 && l->l_info[VERSYMIDX (DT_RELCOUNT)])\n\t    num_relative_relocations\n\t      += l->l_info[VERSYMIDX (DT_RELCOUNT)]->d_un.d_val;\n#ifndef ELF_MACHINE_REL_RELATIVE\n\t  /* Relative relocations are processed on these architectures if\n\t     library is loaded to different address than p_vaddr or\n\t     if not prelinked.  */\n\t  if ((l->l_addr != 0 || !l->l_info[VALIDX(DT_GNU_PRELINKED)])\n\t      && l->l_info[VERSYMIDX (DT_RELACOUNT)])\n#else\n\t  /* On e.g. IA-64 or Alpha, relative relocations are processed\n\t     only if library is loaded to different address than p_vaddr.  */\n\t  if (l->l_addr != 0 && l->l_info[VERSYMIDX (DT_RELACOUNT)])\n#endif\n\t    num_relative_relocations\n\t      += l->l_info[VERSYMIDX (DT_RELACOUNT)]->d_un.d_val;\n\t}\n    }\n\n  _dl_debug_printf (\"                 number of relocations: %lu\\n\"\n\t\t    \"      number of relocations from cache: %lu\\n\"\n\t\t    \"        number of relative relocations: %lu\\n\",\n\t\t    GL(dl_num_relocations),\n\t\t    GL(dl_num_cache_relocations),\n\t\t    num_relative_relocations);\n\n#ifndef HP_TIMING_NONAVAIL\n  /* Time spend while loading the object and the dependencies.  */\n  if (HP_SMALL_TIMING_AVAIL)\n    {\n      char pbuf[30];\n      HP_TIMING_PRINT (buf, sizeof (buf), load_time);\n      cp = _itoa ((1000ULL * load_time) / *rtld_total_timep,\n\t\t  pbuf + sizeof (pbuf), 10, 0);\n      wp = pbuf;\n      switch (pbuf + sizeof (pbuf) - cp)\n\t{\n\tcase 3:\n\t  *wp++ = *cp++;\n\tcase 2:\n\t  *wp++ = *cp++;\n\tcase 1:\n\t  *wp++ = '.';\n\t  *wp++ = *cp++;\n\t}\n      *wp = '\\0';\n      _dl_debug_printf (\"\\\n\t   time needed to load objects: %s (%s%%)\\n\",\n\t\t\t\tbuf, pbuf);\n    }\n#endif\n}\n"}, "9": {"id": 9, "path": "/media/lavo07/lavo07/glibc/assert/assert.h", "content": "/* Copyright (C) 1991-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n/*\n *\tISO C99 Standard: 7.2 Diagnostics\t<assert.h>\n */\n\n#ifdef\t_ASSERT_H\n\n# undef\t_ASSERT_H\n# undef\tassert\n# undef __ASSERT_VOID_CAST\n\n# ifdef\t__USE_GNU\n#  undef assert_perror\n# endif\n\n#endif /* assert.h\t*/\n\n#define\t_ASSERT_H\t1\n#include <features.h>\n\n#if defined __cplusplus && __GNUC_PREREQ (2,95)\n# define __ASSERT_VOID_CAST static_cast<void>\n#else\n# define __ASSERT_VOID_CAST (void)\n#endif\n\n/* void assert (int expression);\n\n   If NDEBUG is defined, do nothing.\n   If not, and EXPRESSION is zero, print an error message and abort.  */\n\n#ifdef\tNDEBUG\n\n# define assert(expr)\t\t(__ASSERT_VOID_CAST (0))\n\n/* void assert_perror (int errnum);\n\n   If NDEBUG is defined, do nothing.  If not, and ERRNUM is not zero, print an\n   error message with the error text for ERRNUM and abort.\n   (This is a GNU extension.) */\n\n# ifdef\t__USE_GNU\n#  define assert_perror(errnum)\t(__ASSERT_VOID_CAST (0))\n# endif\n\n#else /* Not NDEBUG.  */\n\n__BEGIN_DECLS\n\n/* This prints an \"Assertion failed\" message and aborts.  */\nextern void __assert_fail (const char *__assertion, const char *__file,\n\t\t\t   unsigned int __line, const char *__function)\n     __THROW __attribute__ ((__noreturn__));\n\n/* Likewise, but prints the error text for ERRNUM.  */\nextern void __assert_perror_fail (int __errnum, const char *__file,\n\t\t\t\t  unsigned int __line, const char *__function)\n     __THROW __attribute__ ((__noreturn__));\n\n\n/* The following is not at all used here but needed for standard\n   compliance.  */\nextern void __assert (const char *__assertion, const char *__file, int __line)\n     __THROW __attribute__ ((__noreturn__));\n\n\n__END_DECLS\n\n/* When possible, define assert so that it does not add extra\n   parentheses around EXPR.  Otherwise, those added parentheses would\n   suppress warnings we'd expect to be detected by gcc's -Wparentheses.  */\n# if defined __cplusplus\n#  define assert(expr)\t\t\t\t\t\t\t\\\n     (static_cast <bool> (expr)\t\t\t\t\t\t\\\n      ? void (0)\t\t\t\t\t\t\t\\\n      : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))\n# elif !defined __GNUC__ || defined __STRICT_ANSI__\n#  define assert(expr)\t\t\t\t\t\t\t\\\n    ((expr)\t\t\t\t\t\t\t\t\\\n     ? __ASSERT_VOID_CAST (0)\t\t\t\t\t\t\\\n     : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))\n# else\n/* The first occurrence of EXPR is not evaluated due to the sizeof,\n   but will trigger any pedantic warnings masked by the __extension__\n   for the second occurrence.  The ternary operator is required to\n   support function pointers and bit fields in this context, and to\n   suppress the evaluation of variable length arrays.  */\n#  define assert(expr)\t\t\t\t\t\t\t\\\n  ((void) sizeof ((expr) ? 1 : 0), __extension__ ({\t\t\t\\\n      if (expr)\t\t\t\t\t\t\t\t\\\n        ; /* empty */\t\t\t\t\t\t\t\\\n      else\t\t\t\t\t\t\t\t\\\n        __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION);\t\\\n    }))\n# endif\n\n# ifdef\t__USE_GNU\n#  define assert_perror(errnum)\t\t\t\t\t\t\\\n  (!(errnum)\t\t\t\t\t\t\t\t\\\n   ? __ASSERT_VOID_CAST (0)\t\t\t\t\t\t\\\n   : __assert_perror_fail ((errnum), __FILE__, __LINE__, __ASSERT_FUNCTION))\n# endif\n\n/* Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'\n   which contains the name of the function currently being defined.\n   This is broken in G++ before version 2.6.\n   C9x has a similar variable called __func__, but prefer the GCC one since\n   it demangles C++ function names.  */\n# if defined __cplusplus ? __GNUC_PREREQ (2, 6) : __GNUC_PREREQ (2, 4)\n#   define __ASSERT_FUNCTION\t__extension__ __PRETTY_FUNCTION__\n# else\n#  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L\n#   define __ASSERT_FUNCTION\t__func__\n#  else\n#   define __ASSERT_FUNCTION\t((const char *) 0)\n#  endif\n# endif\n\n#endif /* NDEBUG.  */\n\n\n#if defined __USE_ISOC11 && !defined __cplusplus\n# undef static_assert\n# define static_assert _Static_assert\n#endif\n"}, "10": {"id": 10, "path": "/media/lavo07/lavo07/glibc/sysdeps/unix/sysv/linux/dl-osinfo.h", "content": "/* Operating system specific code for generic dynamic loader functions.  Linux.\n   Copyright (C) 2000-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n#include <dl-sysdep.h>\n#include <endian.h>\n#include <fcntl.h>\n#include <stdint.h>\n#include <not-cancel.h>\n\n#ifndef MIN\n# define MIN(a,b) (((a)<(b))?(a):(b))\n#endif\n\n#define DL_SYSDEP_OSCHECK(FATAL)\t\t\t\t\t      \\\n  do {\t\t\t\t\t\t\t\t\t      \\\n    /* Test whether the kernel is new enough.  This test is only performed    \\\n       if the library is not compiled to run on all kernels.  */\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n    int version = _dl_discover_osversion ();\t\t\t\t      \\\n    if (__glibc_likely (version >= 0))\t\t\t\t\t      \\\n      {\t\t\t\t\t\t\t\t\t      \\\n\tif (__builtin_expect (GLRO(dl_osversion) == 0, 1)\t\t      \\\n\t    || GLRO(dl_osversion) > version)\t\t\t\t      \\\n\t  GLRO(dl_osversion) = version;\t\t\t\t\t      \\\n\t\t\t\t\t\t\t\t\t      \\\n\t/* Now we can test with the required version.  */\t\t      \\\n\tif (__LINUX_KERNEL_VERSION > 0 && version < __LINUX_KERNEL_VERSION)   \\\n\t  /* Not sufficent.  */\t\t\t\t\t\t      \\\n\t  FATAL (\"FATAL: kernel too old\\n\");\t\t\t\t      \\\n      }\t\t\t\t\t\t\t\t\t      \\\n    else if (__LINUX_KERNEL_VERSION > 0)\t\t\t\t      \\\n      FATAL (\"FATAL: cannot determine kernel version\\n\");\t\t      \\\n  } while (0)\n\nstatic inline uintptr_t __attribute__ ((always_inline))\n_dl_setup_stack_chk_guard (void *dl_random)\n{\n  union\n  {\n    uintptr_t num;\n    unsigned char bytes[sizeof (uintptr_t)];\n  } ret;\n\n  /* We need in the moment only 8 bytes on 32-bit platforms and 16\n     bytes on 64-bit platforms.  Therefore we can use the data\n     directly and not use the kernel-provided data to seed a PRNG.  */\n  memcpy (ret.bytes, dl_random, sizeof (ret));\n#if BYTE_ORDER == LITTLE_ENDIAN\n  ret.num &= ~(uintptr_t) 0xff;\n#elif BYTE_ORDER == BIG_ENDIAN\n  ret.num &= ~((uintptr_t) 0xff << (8 * (sizeof (ret) - 1)));\n#else\n# error \"BYTE_ORDER unknown\"\n#endif\n  return ret.num;\n}\n\nstatic inline uintptr_t __attribute__ ((always_inline))\n_dl_setup_pointer_guard (void *dl_random, uintptr_t stack_chk_guard)\n{\n  uintptr_t ret;\n  memcpy (&ret, (char *) dl_random + sizeof (ret), sizeof (ret));\n  return ret;\n}\n"}, "11": {"id": 11, "path": "/media/lavo07/lavo07/glibc/sysdeps/generic/ldsodefs.h", "content": "/* Run-time dynamic linker data structures for loaded ELF shared objects.\n   Copyright (C) 1995-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n#ifndef\t_LDSODEFS_H\n#define\t_LDSODEFS_H\t1\n\n#include <features.h>\n\n#include <stdbool.h>\n#define __need_size_t\n#define __need_NULL\n#include <stddef.h>\n#include <string.h>\n#include <stdint.h>\n\n#include <elf.h>\n#include <dlfcn.h>\n#include <fpu_control.h>\n#include <sys/mman.h>\n#include <link.h>\n#include <dl-lookupcfg.h>\n#include <dl-sysdep.h>\n#include <libc-lock.h>\n#include <hp-timing.h>\n#include <tls.h>\n\n__BEGIN_DECLS\n\n#define VERSYMIDX(sym)\t(DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGIDX (sym))\n#define VALIDX(tag)\t(DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM \\\n\t\t\t + DT_EXTRANUM + DT_VALTAGIDX (tag))\n#define ADDRIDX(tag)\t(DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM \\\n\t\t\t + DT_EXTRANUM + DT_VALNUM + DT_ADDRTAGIDX (tag))\n\n/* We use this macro to refer to ELF types independent of the native wordsize.\n   `ElfW(TYPE)' is used in place of `Elf32_TYPE' or `Elf64_TYPE'.  */\n#define ELFW(type)\t_ElfW (ELF, __ELF_NATIVE_CLASS, type)\n\n/* All references to the value of l_info[DT_PLTGOT],\n  l_info[DT_STRTAB], l_info[DT_SYMTAB], l_info[DT_RELA],\n  l_info[DT_REL], l_info[DT_JMPREL], and l_info[VERSYMIDX (DT_VERSYM)]\n  have to be accessed via the D_PTR macro.  The macro is needed since for\n  most architectures the entry is already relocated - but for some not\n  and we need to relocate at access time.  */\n#ifdef DL_RO_DYN_SECTION\n# define D_PTR(map, i) ((map)->i->d_un.d_ptr + (map)->l_addr)\n#else\n# define D_PTR(map, i) (map)->i->d_un.d_ptr\n#endif\n\n/* Result of the lookup functions and how to retrieve the base address.  */\ntypedef struct link_map *lookup_t;\n#define LOOKUP_VALUE(map) map\n#define LOOKUP_VALUE_ADDRESS(map, set) ((set) || (map) ? (map)->l_addr : 0)\n\n/* Calculate the address of symbol REF using the base address from map MAP,\n   if non-NULL.  Don't check for NULL map if MAP_SET is TRUE.  */\n#define SYMBOL_ADDRESS(map, ref, map_set)\t\t\t\t\\\n  ((ref) == NULL ? 0\t\t\t\t\t\t\t\\\n   : (__glibc_unlikely ((ref)->st_shndx == SHN_ABS) ? 0\t\t\t\\\n      : LOOKUP_VALUE_ADDRESS (map, map_set)) + (ref)->st_value)\n\n/* On some architectures a pointer to a function is not just a pointer\n   to the actual code of the function but rather an architecture\n   specific descriptor. */\n#ifndef ELF_FUNCTION_PTR_IS_SPECIAL\n# define DL_SYMBOL_ADDRESS(map, ref) \\\n (void *) SYMBOL_ADDRESS (map, ref, false)\n# define DL_LOOKUP_ADDRESS(addr) ((ElfW(Addr)) (addr))\n# define DL_CALL_DT_INIT(map, start, argc, argv, env) \\\n ((init_t) (start)) (argc, argv, env)\n# define DL_CALL_DT_FINI(map, start) ((fini_t) (start)) ()\n#endif\n\n/* On some architectures dladdr can't use st_size of all symbols this way.  */\n#define DL_ADDR_SYM_MATCH(L, SYM, MATCHSYM, ADDR) \\\n  ((ADDR) >= (L)->l_addr + (SYM)->st_value\t\t\t\t\\\n   && ((((SYM)->st_shndx == SHN_UNDEF || (SYM)->st_size == 0)\t\t\\\n\t&& (ADDR) == (L)->l_addr + (SYM)->st_value)\t\t\t\\\n       || (ADDR) < (L)->l_addr + (SYM)->st_value + (SYM)->st_size)\t\\\n   && ((MATCHSYM) == NULL || (MATCHSYM)->st_value < (SYM)->st_value))\n\n/* According to the ELF gABI no STV_HIDDEN or STV_INTERNAL symbols are\n   expected to be present in dynamic symbol tables as they should have\n   been either removed or converted to STB_LOCAL binding by the static\n   linker.  However some GNU binutils versions produce such symbols in\n   some cases.  To prevent such symbols present in a buggy binary from\n   preempting global symbols we filter them out with this predicate.  */\nstatic __always_inline bool\ndl_symbol_visibility_binds_local_p (const ElfW(Sym) *sym)\n{\n  return (ELFW(ST_VISIBILITY) (sym->st_other) == STV_HIDDEN\n\t  || ELFW(ST_VISIBILITY) (sym->st_other) == STV_INTERNAL);\n}\n\n/* Unmap a loaded object, called by _dl_close (). */\n#ifndef DL_UNMAP_IS_SPECIAL\n# define DL_UNMAP(map)\t_dl_unmap_segments (map)\n#endif\n\n/* By default we do not need special support to initialize DSOs loaded\n   by statically linked binaries.  */\n#ifndef DL_STATIC_INIT\n# define DL_STATIC_INIT(map)\n#endif\n\n/* Reloc type classes as returned by elf_machine_type_class().\n   ELF_RTYPE_CLASS_PLT means this reloc should not be satisfied by\n   some PLT symbol, ELF_RTYPE_CLASS_COPY means this reloc should not be\n   satisfied by any symbol in the executable.  Some architectures do\n   not support copy relocations.  In this case we define the macro to\n   zero so that the code for handling them gets automatically optimized\n   out.  ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA means address of protected\n   data defined in the shared library may be external, i.e., due to copy\n   relocation.  */\n#define ELF_RTYPE_CLASS_PLT 1\n#ifndef DL_NO_COPY_RELOCS\n# define ELF_RTYPE_CLASS_COPY 2\n#else\n# define ELF_RTYPE_CLASS_COPY 0\n#endif\n/* If DL_EXTERN_PROTECTED_DATA is defined, address of protected data\n   defined in the shared library may be external, i.e., due to copy\n   relocation.   */\n#ifdef DL_EXTERN_PROTECTED_DATA\n# define ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA 4\n#else\n# define ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA 0\n#endif\n\n/* ELF uses the PF_x macros to specify the segment permissions, mmap\n   uses PROT_xxx.  In most cases the three macros have the values 1, 2,\n   and 3 but not in a matching order.  The following macros allows\n   converting from the PF_x values to PROT_xxx values.  */\n#define PF_TO_PROT \\\n  ((PROT_READ << (PF_R * 4))\t\t\t\t\t\t      \\\n   | (PROT_WRITE << (PF_W * 4))\t\t\t\t\t\t      \\\n   | (PROT_EXEC << (PF_X * 4))\t\t\t\t\t\t      \\\n   | ((PROT_READ | PROT_WRITE) << ((PF_R | PF_W) * 4))\t\t\t      \\\n   | ((PROT_READ | PROT_EXEC) << ((PF_R | PF_X) * 4))\t\t\t      \\\n   | ((PROT_WRITE | PROT_EXEC) << (PF_W | PF_X) * 4)\t\t\t      \\\n   | ((PROT_READ | PROT_WRITE | PROT_EXEC) << ((PF_R | PF_W | PF_X) * 4)))\n\n/* The filename itself, or the main program name, if available.  */\n#define DSO_FILENAME(name) ((name)[0] ? (name)\t\t\t\t      \\\n\t\t\t    : (rtld_progname ?: \"<main program>\"))\n\n#define RTLD_PROGNAME (rtld_progname ?: \"<program name unknown>\")\n\n/* For the version handling we need an array with only names and their\n   hash values.  */\nstruct r_found_version\n  {\n    const char *name;\n    ElfW(Word) hash;\n\n    int hidden;\n    const char *filename;\n  };\n\n/* We want to cache information about the searches for shared objects.  */\n\nenum r_dir_status { unknown, nonexisting, existing };\n\nstruct r_search_path_elem\n  {\n    /* This link is only used in the `all_dirs' member of `r_search_path'.  */\n    struct r_search_path_elem *next;\n\n    /* Strings saying where the definition came from.  */\n    const char *what;\n    const char *where;\n\n    /* Basename for this search path element.  The string must end with\n       a slash character.  */\n    const char *dirname;\n    size_t dirnamelen;\n\n    enum r_dir_status status[0];\n  };\n\nstruct r_strlenpair\n  {\n    const char *str;\n    size_t len;\n  };\n\n\n/* A data structure for a simple single linked list of strings.  */\nstruct libname_list\n  {\n    const char *name;\t\t/* Name requested (before search).  */\n    struct libname_list *next;\t/* Link to next name for this object.  */\n    int dont_free;\t\t/* Flag whether this element should be freed\n\t\t\t\t   if the object is not entirely unloaded.  */\n  };\n\n\n/* Bit masks for the objects which valid callers can come from to\n   functions with restricted interface.  */\nenum allowmask\n  {\n    allow_libc = 1,\n    allow_libdl = 2,\n    allow_libpthread = 4,\n    allow_ldso = 8\n  };\n\n\nstruct audit_ifaces\n{\n  void (*activity) (uintptr_t *, unsigned int);\n  char *(*objsearch) (const char *, uintptr_t *, unsigned int);\n  unsigned int (*objopen) (struct link_map *, Lmid_t, uintptr_t *);\n  void (*preinit) (uintptr_t *);\n  union\n  {\n    uintptr_t (*symbind32) (Elf32_Sym *, unsigned int, uintptr_t *,\n\t\t\t    uintptr_t *, unsigned int *, const char *);\n    uintptr_t (*symbind64) (Elf64_Sym *, unsigned int, uintptr_t *,\n\t\t\t    uintptr_t *, unsigned int *, const char *);\n  };\n  union\n  {\n#ifdef ARCH_PLTENTER_MEMBERS\n    ARCH_PLTENTER_MEMBERS;\n#endif\n  };\n  union\n  {\n#ifdef ARCH_PLTEXIT_MEMBERS\n    ARCH_PLTEXIT_MEMBERS;\n#endif\n  };\n  unsigned int (*objclose) (uintptr_t *);\n\n  struct audit_ifaces *next;\n};\n\n\n/* Test whether given NAME matches any of the names of the given object.  */\nextern int _dl_name_match_p (const char *__name, const struct link_map *__map)\n     attribute_hidden;\n\n/* Compute next higher prime number.  */\nextern unsigned long int _dl_higher_prime_number (unsigned long int n)\n     attribute_hidden;\n\n/* A stripped down strtoul-like implementation.  */\nuint64_t _dl_strtoul (const char *, char **) attribute_hidden;\n\n/* Function used as argument for `_dl_receive_error' function.  The\n   arguments are the error code, error string, and the objname the\n   error occurred in.  */\ntypedef void (*receiver_fct) (int, const char *, const char *);\n\f\n/* Internal functions of the run-time dynamic linker.\n   These can be accessed if you link again the dynamic linker\n   as a shared library, as in `-lld' or `/lib/ld.so' explicitly;\n   but are not normally of interest to user programs.\n\n   The `-ldl' library functions in <dlfcn.h> provide a simple\n   user interface to run-time dynamic linking.  */\n\n\n#ifndef SHARED\n# define EXTERN extern\n# define GL(name) _##name\n#else\n# define EXTERN\n# if IS_IN (rtld)\n#  define GL(name) _rtld_local._##name\n# else\n#  define GL(name) _rtld_global._##name\n# endif\nstruct rtld_global\n{\n#endif\n  /* Don't change the order of the following elements.  'dl_loaded'\n     must remain the first element.  Forever.  */\n\n/* Non-shared code has no support for multiple namespaces.  */\n#ifdef SHARED\n# define DL_NNS 16\n#else\n# define DL_NNS 1\n#endif\n  EXTERN struct link_namespaces\n  {\n    /* A pointer to the map for the main map.  */\n    struct link_map *_ns_loaded;\n    /* Number of object in the _dl_loaded list.  */\n    unsigned int _ns_nloaded;\n    /* Direct pointer to the searchlist of the main object.  */\n    struct r_scope_elem *_ns_main_searchlist;\n    /* This is zero at program start to signal that the global scope map is\n       allocated by rtld.  Later it keeps the size of the map.  It might be\n       reset if in _dl_close if the last global object is removed.  */\n    size_t _ns_global_scope_alloc;\n    /* Search table for unique objects.  */\n    struct unique_sym_table\n    {\n      __rtld_lock_define_recursive (, lock)\n      struct unique_sym\n      {\n\tuint32_t hashval;\n\tconst char *name;\n\tconst ElfW(Sym) *sym;\n\tconst struct link_map *map;\n      } *entries;\n      size_t size;\n      size_t n_elements;\n      void (*free) (void *);\n    } _ns_unique_sym_table;\n    /* Keep track of changes to each namespace' list.  */\n    struct r_debug _ns_debug;\n  } _dl_ns[DL_NNS];\n  /* One higher than index of last used namespace.  */\n  EXTERN size_t _dl_nns;\n\n  /* During the program run we must not modify the global data of\n     loaded shared object simultanously in two threads.  Therefore we\n     protect `_dl_open' and `_dl_close' in dl-close.c.\n\n     This must be a recursive lock since the initializer function of\n     the loaded object might as well require a call to this function.\n     At this time it is not anymore a problem to modify the tables.  */\n  __rtld_lock_define_recursive (EXTERN, _dl_load_lock)\n  /* This lock is used to keep __dl_iterate_phdr from inspecting the\n     list of loaded objects while an object is added to or removed\n     from that list.  */\n  __rtld_lock_define_recursive (EXTERN, _dl_load_write_lock)\n\n  /* Incremented whenever something may have been added to dl_loaded.  */\n  EXTERN unsigned long long _dl_load_adds;\n\n  /* The object to be initialized first.  */\n  EXTERN struct link_map *_dl_initfirst;\n\n#if HP_SMALL_TIMING_AVAIL\n  /* Start time on CPU clock.  */\n  EXTERN hp_timing_t _dl_cpuclock_offset;\n#endif\n\n  /* Map of shared object to be profiled.  */\n  EXTERN struct link_map *_dl_profile_map;\n\n  /* Counters for the number of relocations performed.  */\n  EXTERN unsigned long int _dl_num_relocations;\n  EXTERN unsigned long int _dl_num_cache_relocations;\n\n  /* List of search directories.  */\n  EXTERN struct r_search_path_elem *_dl_all_dirs;\n\n  /* Structure describing the dynamic linker itself.  We need to\n     reserve memory for the data the audit libraries need.  */\n  EXTERN struct link_map _dl_rtld_map;\n#ifdef SHARED\n  struct auditstate audit_data[DL_NNS];\n#endif\n\n#if defined SHARED && defined _LIBC_REENTRANT \\\n    && defined __rtld_lock_default_lock_recursive\n  EXTERN void (*_dl_rtld_lock_recursive) (void *);\n  EXTERN void (*_dl_rtld_unlock_recursive) (void *);\n#endif\n\n  /* Get architecture specific definitions.  */\n#define PROCINFO_DECL\n#ifndef PROCINFO_CLASS\n# define PROCINFO_CLASS EXTERN\n#endif\n#include <dl-procruntime.c>\n\n  /* If loading a shared object requires that we make the stack executable\n     when it was not, we do it by calling this function.\n     It returns an errno code or zero on success.  */\n  EXTERN int (*_dl_make_stack_executable_hook) (void **);\n\n  /* Prevailing state of the stack, PF_X indicating it's executable.  */\n  EXTERN ElfW(Word) _dl_stack_flags;\n\n  /* Flag signalling whether there are gaps in the module ID allocation.  */\n  EXTERN bool _dl_tls_dtv_gaps;\n  /* Highest dtv index currently needed.  */\n  EXTERN size_t _dl_tls_max_dtv_idx;\n  /* Information about the dtv slots.  */\n  EXTERN struct dtv_slotinfo_list\n  {\n    size_t len;\n    struct dtv_slotinfo_list *next;\n    struct dtv_slotinfo\n    {\n      size_t gen;\n      struct link_map *map;\n    } slotinfo[0];\n  } *_dl_tls_dtv_slotinfo_list;\n  /* Number of modules in the static TLS block.  */\n  EXTERN size_t _dl_tls_static_nelem;\n  /* Size of the static TLS block.  */\n  EXTERN size_t _dl_tls_static_size;\n  /* Size actually allocated in the static TLS block.  */\n  EXTERN size_t _dl_tls_static_used;\n  /* Alignment requirement of the static TLS block.  */\n  EXTERN size_t _dl_tls_static_align;\n\n/* Number of additional entries in the slotinfo array of each slotinfo\n   list element.  A large number makes it almost certain take we never\n   have to iterate beyond the first element in the slotinfo list.  */\n#define TLS_SLOTINFO_SURPLUS (62)\n\n/* Number of additional slots in the dtv allocated.  */\n#define DTV_SURPLUS\t(14)\n\n  /* Initial dtv of the main thread, not allocated with normal malloc.  */\n  EXTERN void *_dl_initial_dtv;\n  /* Generation counter for the dtv.  */\n  EXTERN size_t _dl_tls_generation;\n\n  EXTERN void (*_dl_init_static_tls) (struct link_map *);\n\n  EXTERN void (*_dl_wait_lookup_done) (void);\n\n  /* Scopes to free after next THREAD_GSCOPE_WAIT ().  */\n  EXTERN struct dl_scope_free_list\n  {\n    size_t count;\n    void *list[50];\n  } *_dl_scope_free_list;\n#if !THREAD_GSCOPE_IN_TCB\n  EXTERN int _dl_thread_gscope_count;\n#endif\n#ifdef SHARED\n};\n# define __rtld_global_attribute__\n# if IS_IN (rtld)\n#  ifdef HAVE_SDATA_SECTION\n#   define __rtld_local_attribute__ \\\n\t    __attribute__ ((visibility (\"hidden\"), section (\".sdata\")))\n#   undef __rtld_global_attribute__\n#   define __rtld_global_attribute__ __attribute__ ((section (\".sdata\")))\n#  else\n#   define __rtld_local_attribute__ __attribute__ ((visibility (\"hidden\")))\n#  endif\nextern struct rtld_global _rtld_local __rtld_local_attribute__;\n#  undef __rtld_local_attribute__\n# endif\nextern struct rtld_global _rtld_global __rtld_global_attribute__;\n# undef __rtld_global_attribute__\n#endif\n\n#ifndef SHARED\n# define GLRO(name) _##name\n#else\n# if IS_IN (rtld)\n#  define GLRO(name) _rtld_local_ro._##name\n# else\n#  define GLRO(name) _rtld_global_ro._##name\n# endif\nstruct rtld_global_ro\n{\n#endif\n\n  /* If nonzero the appropriate debug information is printed.  */\n  EXTERN int _dl_debug_mask;\n#define DL_DEBUG_LIBS\t    (1 << 0)\n#define DL_DEBUG_IMPCALLS   (1 << 1)\n#define DL_DEBUG_BINDINGS   (1 << 2)\n#define DL_DEBUG_SYMBOLS    (1 << 3)\n#define DL_DEBUG_VERSIONS   (1 << 4)\n#define DL_DEBUG_RELOC      (1 << 5)\n#define DL_DEBUG_FILES      (1 << 6)\n#define DL_DEBUG_STATISTICS (1 << 7)\n#define DL_DEBUG_UNUSED\t    (1 << 8)\n#define DL_DEBUG_SCOPES\t    (1 << 9)\n/* These two are used only internally.  */\n#define DL_DEBUG_HELP       (1 << 10)\n#define DL_DEBUG_PRELINK    (1 << 11)\n\n  /* OS version.  */\n  EXTERN unsigned int _dl_osversion;\n  /* Platform name.  */\n  EXTERN const char *_dl_platform;\n  EXTERN size_t _dl_platformlen;\n\n  /* Cached value of `getpagesize ()'.  */\n  EXTERN size_t _dl_pagesize;\n\n  /* Do we read from ld.so.cache?  */\n  EXTERN int _dl_inhibit_cache;\n\n  /* Copy of the content of `_dl_main_searchlist' at startup time.  */\n  EXTERN struct r_scope_elem _dl_initial_searchlist;\n\n  /* CLK_TCK as reported by the kernel.  */\n  EXTERN int _dl_clktck;\n\n  /* If nonzero print warnings messages.  */\n  EXTERN int _dl_verbose;\n\n  /* File descriptor to write debug messages to.  */\n  EXTERN int _dl_debug_fd;\n\n  /* Do we do lazy relocations?  */\n  EXTERN int _dl_lazy;\n\n  /* Nonzero if runtime lookups should not update the .got/.plt.  */\n  EXTERN int _dl_bind_not;\n\n  /* Nonzero if references should be treated as weak during runtime\n     linking.  */\n  EXTERN int _dl_dynamic_weak;\n\n  /* Default floating-point control word.  */\n  EXTERN fpu_control_t _dl_fpu_control;\n\n  /* Expected cache ID.  */\n  EXTERN int _dl_correct_cache_id;\n\n  /* Mask for hardware capabilities that are available.  */\n  EXTERN uint64_t _dl_hwcap;\n\n#if !HAVE_TUNABLES\n  /* Mask for important hardware capabilities we honour. */\n  EXTERN uint64_t _dl_hwcap_mask;\n#endif\n\n#ifdef HAVE_AUX_VECTOR\n  /* Pointer to the auxv list supplied to the program at startup.  */\n  EXTERN ElfW(auxv_t) *_dl_auxv;\n#endif\n\n  /* Get architecture specific definitions.  */\n#include <dl-procinfo.c>\n\n  /* Names of shared object for which the RPATH should be ignored.  */\n  EXTERN const char *_dl_inhibit_rpath;\n\n  /* Location of the binary.  */\n  EXTERN const char *_dl_origin_path;\n\n  /* -1 if the dynamic linker should honor library load bias,\n     0 if not, -2 use the default (honor biases for normal\n     binaries, don't honor for PIEs).  */\n  EXTERN ElfW(Addr) _dl_use_load_bias;\n\n  /* Name of the shared object to be profiled (if any).  */\n  EXTERN const char *_dl_profile;\n  /* Filename of the output file.  */\n  EXTERN const char *_dl_profile_output;\n  /* Name of the object we want to trace the prelinking.  */\n  EXTERN const char *_dl_trace_prelink;\n  /* Map of shared object to be prelink traced.  */\n  EXTERN struct link_map *_dl_trace_prelink_map;\n\n  /* All search directories defined at startup.  This is assigned a\n     non-NULL pointer by the ld.so startup code (after initialization\n     to NULL), so this can also serve as an indicator whether a copy\n     of ld.so is initialized and active.  See the rtld_active function\n     below.  */\n  EXTERN struct r_search_path_elem *_dl_init_all_dirs;\n\n#ifdef NEED_DL_SYSINFO\n  /* Syscall handling improvements.  This is very specific to x86.  */\n  EXTERN uintptr_t _dl_sysinfo;\n#endif\n\n#ifdef NEED_DL_SYSINFO_DSO\n  /* The vsyscall page is a virtual DSO pre-mapped by the kernel.\n     This points to its ELF header.  */\n  EXTERN const ElfW(Ehdr) *_dl_sysinfo_dso;\n\n  /* At startup time we set up the normal DSO data structure for it,\n     and this points to it.  */\n  EXTERN struct link_map *_dl_sysinfo_map;\n#endif\n\n  /* Mask for more hardware capabilities that are available on some\n     platforms.  */\n  EXTERN uint64_t _dl_hwcap2;\n\n#ifdef SHARED\n  /* We add a function table to _rtld_global which is then used to\n     call the function instead of going through the PLT.  The result\n     is that we can avoid exporting the functions and we do not jump\n     PLT relocations in libc.so.  */\n  void (*_dl_debug_printf) (const char *, ...)\n       __attribute__ ((__format__ (__printf__, 1, 2)));\n  void (*_dl_mcount) (ElfW(Addr) frompc, ElfW(Addr) selfpc);\n  lookup_t (*_dl_lookup_symbol_x) (const char *, struct link_map *,\n\t\t\t\t   const ElfW(Sym) **, struct r_scope_elem *[],\n\t\t\t\t   const struct r_found_version *, int, int,\n\t\t\t\t   struct link_map *);\n  void *(*_dl_open) (const char *file, int mode, const void *caller_dlopen,\n\t\t     Lmid_t nsid, int argc, char *argv[], char *env[]);\n  void (*_dl_close) (void *map);\n  void *(*_dl_tls_get_addr_soft) (struct link_map *);\n#ifdef HAVE_DL_DISCOVER_OSVERSION\n  int (*_dl_discover_osversion) (void);\n#endif\n\n  /* List of auditing interfaces.  */\n  struct audit_ifaces *_dl_audit;\n  unsigned int _dl_naudit;\n};\n# define __rtld_global_attribute__\n# if IS_IN (rtld)\n#  define __rtld_local_attribute__ __attribute__ ((visibility (\"hidden\")))\nextern struct rtld_global_ro _rtld_local_ro\n    attribute_relro __rtld_local_attribute__;\nextern struct rtld_global_ro _rtld_global_ro\n    attribute_relro __rtld_global_attribute__;\n#  undef __rtld_local_attribute__\n# else\n/* We cheat a bit here.  We declare the variable as as const even\n   though it is at startup.  */\nextern const struct rtld_global_ro _rtld_global_ro\n    attribute_relro __rtld_global_attribute__;\n# endif\n# undef __rtld_global_attribute__\n#endif\n#undef EXTERN\n\n#ifndef SHARED\n/* dl-support.c defines these and initializes them early on.  */\nextern const ElfW(Phdr) *_dl_phdr;\nextern size_t _dl_phnum;\n#endif\n\n/* This is the initial value of GL(dl_make_stack_executable_hook).\n   A threads library can change it.  */\nextern int _dl_make_stack_executable (void **stack_endp);\nrtld_hidden_proto (_dl_make_stack_executable)\n\n/* Variable pointing to the end of the stack (or close to it).  This value\n   must be constant over the runtime of the application.  Some programs\n   might use the variable which results in copy relocations on some\n   platforms.  But this does not matter, ld.so can always use the local\n   copy.  */\nextern void *__libc_stack_end\n#ifndef LIBC_STACK_END_NOT_RELRO\n     attribute_relro\n#endif\n     ;\nrtld_hidden_proto (__libc_stack_end)\n\n/* Parameters passed to the dynamic linker.  */\nextern int _dl_argc attribute_hidden attribute_relro;\nextern char **_dl_argv\n#ifndef DL_ARGV_NOT_RELRO\n     attribute_relro\n#endif\n     ;\nrtld_hidden_proto (_dl_argv)\n#if IS_IN (rtld)\nextern unsigned int _dl_skip_args attribute_hidden\n# ifndef DL_ARGV_NOT_RELRO\n     attribute_relro\n# endif\n     ;\nextern unsigned int _dl_skip_args_internal attribute_hidden\n# ifndef DL_ARGV_NOT_RELRO\n     attribute_relro\n# endif\n     ;\n#endif\n#define rtld_progname _dl_argv[0]\n\n/* Flag set at startup and cleared when the last initializer has run.  */\nextern int _dl_starting_up;\nweak_extern (_dl_starting_up)\nrtld_hidden_proto (_dl_starting_up)\n\n/* Random data provided by the kernel.  */\nextern void *_dl_random attribute_hidden attribute_relro;\n\n/* OS-dependent function to open the zero-fill device.  */\nextern int _dl_sysdep_open_zero_fill (void); /* dl-sysdep.c */\n\n\n/* Write message on the debug file descriptor.  The parameters are\n   interpreted as for a `printf' call.  All the lines start with a\n   tag showing the PID.  */\nextern void _dl_debug_printf (const char *fmt, ...)\n     __attribute__ ((__format__ (__printf__, 1, 2))) attribute_hidden;\n\n/* Write message on the debug file descriptor.  The parameters are\n   interpreted as for a `printf' call.  All the lines buf the first\n   start with a tag showing the PID.  */\nextern void _dl_debug_printf_c (const char *fmt, ...)\n     __attribute__ ((__format__ (__printf__, 1, 2))) attribute_hidden;\n\n\n/* Write a message on the specified descriptor FD.  The parameters are\n   interpreted as for a `printf' call.  */\n#if IS_IN (rtld) || !defined (SHARED)\nextern void _dl_dprintf (int fd, const char *fmt, ...)\n     __attribute__ ((__format__ (__printf__, 2, 3)))\n     attribute_hidden;\n#else\n__attribute__ ((always_inline, __format__ (__printf__, 2, 3)))\nstatic inline void\n_dl_dprintf (int fd, const char *fmt, ...)\n{\n  /* Use local declaration to avoid includign <stdio.h>.  */\n  extern int __dprintf(int fd, const char *format, ...) attribute_hidden;\n  __dprintf (fd, fmt, __builtin_va_arg_pack ());\n}\n#endif\n\n/* Write a message on the specified descriptor standard output.  The\n   parameters are interpreted as for a `printf' call.  */\n#define _dl_printf(fmt, args...) \\\n  _dl_dprintf (STDOUT_FILENO, fmt, ##args)\n\n/* Write a message on the specified descriptor standard error.  The\n   parameters are interpreted as for a `printf' call.  */\n#define _dl_error_printf(fmt, args...) \\\n  _dl_dprintf (STDERR_FILENO, fmt, ##args)\n\n/* Write a message on the specified descriptor standard error and exit\n   the program.  The parameters are interpreted as for a `printf' call.  */\n#define _dl_fatal_printf(fmt, args...) \\\n  do\t\t\t\t\t\t\t\t\t      \\\n    {\t\t\t\t\t\t\t\t\t      \\\n      _dl_dprintf (STDERR_FILENO, fmt, ##args);\t\t\t\t      \\\n      _exit (127);\t\t\t\t\t\t\t      \\\n    }\t\t\t\t\t\t\t\t\t      \\\n  while (1)\n\n\n/* An exception raised by the _dl_signal_error function family and\n   caught by _dl_catch_error function family.  Exceptions themselves\n   are copied as part of the raise operation, but the strings are\n   not.  */\nstruct dl_exception\n{\n  const char *objname;\n  const char *errstring;\n\n  /* This buffer typically stores both objname and errstring\n     above.  */\n  char *message_buffer;\n};\n\n/* Creates a new exception.  This calls malloc; if allocation fails,\n   dummy values are inserted.  OBJECT is the name of the problematical\n   shared object, or null if its a general problem.  ERRSTRING is a\n   string describing the specific problem.  */\nvoid _dl_exception_create (struct dl_exception *, const char *object,\n\t\t\t   const char *errstring)\n  __attribute__ ((nonnull (1, 3)));\nrtld_hidden_proto (_dl_exception_create)\n\n/* Like _dl_exception_create, but create errstring from a format\n   string FMT.  Currently, only \"%s\" and \"%%\" are supported as format\n   directives.  */\nvoid _dl_exception_create_format (struct dl_exception *, const char *objname,\n\t\t\t\t  const char *fmt, ...)\n  __attribute__ ((nonnull (1, 3), format (printf, 3, 4)));\nrtld_hidden_proto (_dl_exception_create_format)\n\n/* Deallocate the exception, freeing allocated buffers (if\n   possible).  */\nvoid _dl_exception_free (struct dl_exception *)\n  __attribute__ ((nonnull (1)));\nrtld_hidden_proto (_dl_exception_free)\n\n/* This function is called by all the internal dynamic linker\n   functions when they encounter an error.  ERRCODE is either an\n   `errno' code or zero; it specifies the return value of\n   _dl_catch_error.  OCCASION is included in the error message if the\n   process is terminated immediately.  */\nvoid _dl_signal_exception (int errcode, struct dl_exception *,\n\t\t\t   const char *occasion)\n  __attribute__ ((__noreturn__));\nlibc_hidden_proto (_dl_signal_exception)\n\n/* Like _dl_signal_exception, but creates the exception first.  */\nextern void _dl_signal_error (int errcode, const char *object,\n\t\t\t      const char *occasion, const char *errstring)\n     __attribute__ ((__noreturn__));\nlibc_hidden_proto (_dl_signal_error)\n\n/* Like _dl_signal_exception, but may return when called in the\n   context of _dl_receive_error.  This is only used during ld.so\n   bootstrap.  In static and profiled builds, this is equivalent to\n   _dl_signal_exception.  */\n#if IS_IN (rtld)\nextern void _dl_signal_cexception (int errcode, struct dl_exception *,\n\t\t\t\t   const char *occasion) attribute_hidden;\n#else\n__attribute__ ((always_inline))\nstatic inline void\n_dl_signal_cexception (int errcode, struct dl_exception *exception,\n\t\t       const char *occasion)\n{\n  _dl_signal_exception (errcode, exception, occasion);\n}\n#endif\n\n/* See _dl_signal_cexception above.  */\n#if IS_IN (rtld)\nextern void _dl_signal_cerror (int errcode, const char *object,\n\t\t\t       const char *occasion, const char *errstring)\n     attribute_hidden;\n#else\n__attribute__ ((always_inline))\nstatic inline void\n_dl_signal_cerror (int errcode, const char *object,\n\t\t\t       const char *occasion, const char *errstring)\n{\n  _dl_signal_error (errcode, object, occasion, errstring);\n}\n#endif\n\n/* Call OPERATE, receiving errors from `dl_signal_cerror'.  Unlike\n   `_dl_catch_error' the operation is resumed after the OPERATE\n   function returns.\n   ARGS is passed as argument to OPERATE.  */\nextern void _dl_receive_error (receiver_fct fct, void (*operate) (void *),\n\t\t\t       void *args) attribute_hidden;\n\n/* Call OPERATE, catching errors from `_dl_signal_error' and related\n   functions.  If there is no error, *ERRSTRING is set to null.  If\n   there is an error, *ERRSTRING is set to a string constructed from\n   the strings passed to _dl_signal_error, and the error code passed\n   is the return value and *OBJNAME is set to the object name which\n   experienced the problems.  ERRSTRING if nonzero points to a\n   malloc'ed string which the caller has to free after use.  ARGS is\n   passed as argument to OPERATE.  MALLOCEDP is set to true only if\n   the returned string is allocated using the libc's malloc.  */\nextern int _dl_catch_error (const char **objname, const char **errstring,\n\t\t\t    bool *mallocedp, void (*operate) (void *),\n\t\t\t    void *args);\nlibc_hidden_proto (_dl_catch_error)\n\n/* Call OPERATE (ARGS).  If no error occurs, set *EXCEPTION to zero.\n   Otherwise, store a copy of the raised exception in *EXCEPTION,\n   which has to be freed by _dl_exception_free.  */\nint _dl_catch_exception (struct dl_exception *exception,\n\t\t\t void (*operate) (void *), void *args);\nlibc_hidden_proto (_dl_catch_exception)\n\n/* Open the shared object NAME and map in its segments.\n   LOADER's DT_RPATH is used in searching for NAME.\n   If the object is already opened, returns its existing map.  */\nextern struct link_map *_dl_map_object (struct link_map *loader,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tint type, int trace_mode, int mode,\n\t\t\t\t\tLmid_t nsid) attribute_hidden;\n\n/* Call _dl_map_object on the dependencies of MAP, and set up\n   MAP->l_searchlist.  PRELOADS points to a vector of NPRELOADS previously\n   loaded objects that will be inserted into MAP->l_searchlist after MAP\n   but before its dependencies.  */\nextern void _dl_map_object_deps (struct link_map *map,\n\t\t\t\t struct link_map **preloads,\n\t\t\t\t unsigned int npreloads, int trace_mode,\n\t\t\t\t int open_mode)\n     attribute_hidden;\n\n/* Cache the locations of MAP's hash table.  */\nextern void _dl_setup_hash (struct link_map *map) attribute_hidden;\n\n\n/* Collect the directories in the search path for LOADER's dependencies.\n   The data structure is defined in <dlfcn.h>.  If COUNTING is true,\n   SI->dls_cnt and SI->dls_size are set; if false, those must be as set\n   by a previous call with COUNTING set, and SI must point to SI->dls_size\n   bytes to be used in filling in the result.  */\nextern void _dl_rtld_di_serinfo (struct link_map *loader,\n\t\t\t\t Dl_serinfo *si, bool counting);\n\n\n/* Search loaded objects' symbol tables for a definition of the symbol\n   referred to by UNDEF.  *SYM is the symbol table entry containing the\n   reference; it is replaced with the defining symbol, and the base load\n   address of the defining object is returned.  SYMBOL_SCOPE is a\n   null-terminated list of object scopes to search; each object's\n   l_searchlist (i.e. the segment of the dependency tree starting at that\n   object) is searched in turn.  REFERENCE_NAME should name the object\n   containing the reference; it is used in error messages.\n   TYPE_CLASS describes the type of symbol we are looking for.  */\nenum\n  {\n    /* If necessary add dependency between user and provider object.  */\n    DL_LOOKUP_ADD_DEPENDENCY = 1,\n    /* Return most recent version instead of default version for\n       unversioned lookup.  */\n    DL_LOOKUP_RETURN_NEWEST = 2,\n    /* Set if dl_lookup* called with GSCOPE lock held.  */\n    DL_LOOKUP_GSCOPE_LOCK = 4,\n  };\n\n/* Lookup versioned symbol.  */\nextern lookup_t _dl_lookup_symbol_x (const char *undef,\n\t\t\t\t     struct link_map *undef_map,\n\t\t\t\t     const ElfW(Sym) **sym,\n\t\t\t\t     struct r_scope_elem *symbol_scope[],\n\t\t\t\t     const struct r_found_version *version,\n\t\t\t\t     int type_class, int flags,\n\t\t\t\t     struct link_map *skip_map)\n     attribute_hidden;\n\n\n/* Add the new link_map NEW to the end of the namespace list.  */\nextern void _dl_add_to_namespace_list (struct link_map *new, Lmid_t nsid)\n     attribute_hidden;\n\n/* Allocate a `struct link_map' for a new object being loaded.  */\nextern struct link_map *_dl_new_object (char *realname, const char *libname,\n\t\t\t\t\tint type, struct link_map *loader,\n\t\t\t\t\tint mode, Lmid_t nsid)\n     attribute_hidden;\n\n/* Relocate the given object (if it hasn't already been).\n   SCOPE is passed to _dl_lookup_symbol in symbol lookups.\n   If RTLD_LAZY is set in RELOC-MODE, don't relocate its PLT.  */\nextern void _dl_relocate_object (struct link_map *map,\n\t\t\t\t struct r_scope_elem *scope[],\n\t\t\t\t int reloc_mode, int consider_profiling)\n     attribute_hidden;\n\n/* Protect PT_GNU_RELRO area.  */\nextern void _dl_protect_relro (struct link_map *map) attribute_hidden;\n\n/* Call _dl_signal_error with a message about an unhandled reloc type.\n   TYPE is the result of ELFW(R_TYPE) (r_info), i.e. an R_<CPU>_* value.\n   PLT is nonzero if this was a PLT reloc; it just affects the message.  */\nextern void _dl_reloc_bad_type (struct link_map *map,\n\t\t\t\tunsigned int type, int plt)\n     attribute_hidden __attribute__ ((__noreturn__));\n\n/* Resolve conflicts if prelinking.  */\nextern void _dl_resolve_conflicts (struct link_map *l,\n\t\t\t\t   ElfW(Rela) *conflict,\n\t\t\t\t   ElfW(Rela) *conflictend)\n     attribute_hidden;\n\n/* Check the version dependencies of all objects available through\n   MAP.  If VERBOSE print some more diagnostics.  */\nextern int _dl_check_all_versions (struct link_map *map, int verbose,\n\t\t\t\t   int trace_mode) attribute_hidden;\n\n/* Check the version dependencies for MAP.  If VERBOSE print some more\n   diagnostics.  */\nextern int _dl_check_map_versions (struct link_map *map, int verbose,\n\t\t\t\t   int trace_mode) attribute_hidden;\n\n/* Initialize the object in SCOPE by calling the constructors with\n   ARGC, ARGV, and ENV as the parameters.  */\nextern void _dl_init (struct link_map *main_map, int argc, char **argv,\n\t\t      char **env) attribute_hidden;\n\n/* Call the finalizer functions of all shared objects whose\n   initializer functions have completed.  */\nextern void _dl_fini (void) attribute_hidden;\n\n/* Sort array MAPS according to dependencies of the contained objects.  */\nextern void _dl_sort_maps (struct link_map **maps, unsigned int nmaps,\n\t\t\t   char *used, bool for_fini) attribute_hidden;\n\n/* The dynamic linker calls this function before and having changing\n   any shared object mappings.  The `r_state' member of `struct r_debug'\n   says what change is taking place.  This function's address is\n   the value of the `r_brk' member.  */\nextern void _dl_debug_state (void);\nrtld_hidden_proto (_dl_debug_state)\n\n/* Initialize `struct r_debug' if it has not already been done.  The\n   argument is the run-time load address of the dynamic linker, to be put\n   in the `r_ldbase' member.  Returns the address of the structure.  */\nextern struct r_debug *_dl_debug_initialize (ElfW(Addr) ldbase, Lmid_t ns)\n     attribute_hidden;\n\n/* Initialize the basic data structure for the search paths.  */\nextern void _dl_init_paths (const char *library_path) attribute_hidden;\n\n/* Gather the information needed to install the profiling tables and start\n   the timers.  */\nextern void _dl_start_profile (void) attribute_hidden;\n\n/* The actual functions used to keep book on the calls.  */\nextern void _dl_mcount (ElfW(Addr) frompc, ElfW(Addr) selfpc);\nrtld_hidden_proto (_dl_mcount)\n\n/* This function is simply a wrapper around the _dl_mcount function\n   which does not require a FROMPC parameter since this is the\n   calling function.  */\nextern void _dl_mcount_wrapper (void *selfpc);\n\n/* Show the members of the auxiliary array passed up from the kernel.  */\nextern void _dl_show_auxv (void) attribute_hidden;\n\n/* Return all environment variables starting with `LD_', one after the\n   other.  */\nextern char *_dl_next_ld_env_entry (char ***position) attribute_hidden;\n\n/* Return an array with the names of the important hardware capabilities.  */\nextern const struct r_strlenpair *_dl_important_hwcaps (const char *platform,\n\t\t\t\t\t\t\tsize_t paltform_len,\n\t\t\t\t\t\t\tsize_t *sz,\n\t\t\t\t\t\t\tsize_t *max_capstrlen)\n     attribute_hidden;\n\n/* Look up NAME in ld.so.cache and return the file name stored there,\n   or null if none is found.  Caller must free returned string.  */\nextern char *_dl_load_cache_lookup (const char *name) attribute_hidden;\n\n/* If the system does not support MAP_COPY we cannot leave the file open\n   all the time since this would create problems when the file is replaced.\n   Therefore we provide this function to close the file and open it again\n   once needed.  */\nextern void _dl_unload_cache (void) attribute_hidden;\n\n/* System-dependent function to read a file's whole contents in the\n   most convenient manner available.  *SIZEP gets the size of the\n   file.  On error MAP_FAILED is returned.  */\nextern void *_dl_sysdep_read_whole_file (const char *file, size_t *sizep,\n\t\t\t\t\t int prot) attribute_hidden;\n\n/* System-specific function to do initial startup for the dynamic linker.\n   After this, file access calls and getenv must work.  This is responsible\n   for setting __libc_enable_secure if we need to be secure (e.g. setuid),\n   and for setting _dl_argc and _dl_argv, and then calling _dl_main.  */\nextern ElfW(Addr) _dl_sysdep_start (void **start_argptr,\n\t\t\t\t    void (*dl_main) (const ElfW(Phdr) *phdr,\n\t\t\t\t\t\t     ElfW(Word) phnum,\n\t\t\t\t\t\t     ElfW(Addr) *user_entry,\n\t\t\t\t\t\t     ElfW(auxv_t) *auxv))\n     attribute_hidden;\n\nextern void _dl_sysdep_start_cleanup (void) attribute_hidden;\n\n\n/* Determine next available module ID.  */\nextern size_t _dl_next_tls_modid (void) attribute_hidden;\n\n/* Count the modules with TLS segments.  */\nextern size_t _dl_count_modids (void) attribute_hidden;\n\n/* Calculate offset of the TLS blocks in the static TLS block.  */\nextern void _dl_determine_tlsoffset (void) attribute_hidden;\n\n#ifndef SHARED\n/* Set up the TCB for statically linked applications.  This is called\n   early during startup because we always use TLS (for errno and the\n   stack protector, among other things).  */\nvoid __libc_setup_tls (void);\n\n# if ENABLE_STATIC_PIE\n/* Relocate static executable with PIE.  */\nextern void _dl_relocate_static_pie (void) attribute_hidden;\n\n/* Get a pointer to _dl_main_map.  */\nextern struct link_map * _dl_get_dl_main_map (void)\n  __attribute__ ((visibility (\"hidden\")));\n# else\n#  define _dl_relocate_static_pie()\n# endif\n#endif\n\n/* Initialization of libpthread for statically linked applications.\n   If libpthread is not linked in, this is an empty function.  */\nvoid __pthread_initialize_minimal (void) weak_function;\n\n/* Allocate memory for static TLS block (unless MEM is nonzero) and dtv.  */\nextern void *_dl_allocate_tls (void *mem);\nrtld_hidden_proto (_dl_allocate_tls)\n\n/* Get size and alignment requirements of the static TLS block.  */\nextern void _dl_get_tls_static_info (size_t *sizep, size_t *alignp);\n\nextern void _dl_allocate_static_tls (struct link_map *map) attribute_hidden;\n\n/* These are internal entry points to the two halves of _dl_allocate_tls,\n   only used within rtld.c itself at startup time.  */\nextern void *_dl_allocate_tls_storage (void) attribute_hidden;\nextern void *_dl_allocate_tls_init (void *);\nrtld_hidden_proto (_dl_allocate_tls_init)\n\n/* Deallocate memory allocated with _dl_allocate_tls.  */\nextern void _dl_deallocate_tls (void *tcb, bool dealloc_tcb);\nrtld_hidden_proto (_dl_deallocate_tls)\n\nextern void _dl_nothread_init_static_tls (struct link_map *) attribute_hidden;\n\n/* Find origin of the executable.  */\nextern const char *_dl_get_origin (void) attribute_hidden;\n\n/* Count DSTs.  */\nextern size_t _dl_dst_count (const char *name) attribute_hidden;\n\n/* Substitute DST values.  */\nextern char *_dl_dst_substitute (struct link_map *l, const char *name,\n\t\t\t\t char *result) attribute_hidden;\n\n/* Open the shared object NAME, relocate it, and run its initializer if it\n   hasn't already been run.  MODE is as for `dlopen' (see <dlfcn.h>).  If\n   the object is already opened, returns its existing map.  */\nextern void *_dl_open (const char *name, int mode, const void *caller,\n\t\t       Lmid_t nsid, int argc, char *argv[], char *env[])\n     attribute_hidden;\n\n/* Free or queue for freeing scope OLD.  If other threads might be\n   in the middle of _dl_fixup, _dl_profile_fixup or dl*sym using the\n   old scope, OLD can't be freed until no thread is using it.  */\nextern int _dl_scope_free (void *) attribute_hidden;\n\n/* Add module to slot information data.  */\nextern void _dl_add_to_slotinfo (struct link_map  *l) attribute_hidden;\n\n/* Update slot information data for at least the generation of the\n   module with the given index.  */\nextern struct link_map *_dl_update_slotinfo (unsigned long int req_modid)\n     attribute_hidden;\n\n/* Look up the module's TLS block as for __tls_get_addr,\n   but never touch anything.  Return null if it's not allocated yet.  */\nextern void *_dl_tls_get_addr_soft (struct link_map *l) attribute_hidden;\n\nextern int _dl_addr_inside_object (struct link_map *l, const ElfW(Addr) addr)\n     attribute_hidden;\n\n/* Show show of an object.  */\nextern void _dl_show_scope (struct link_map *new, int from)\n     attribute_hidden;\n\nextern struct link_map *_dl_find_dso_for_object (const ElfW(Addr) addr);\nrtld_hidden_proto (_dl_find_dso_for_object)\n\n/* Initialization which is normally done by the dynamic linker.  */\nextern void _dl_non_dynamic_init (void)\n     attribute_hidden;\n\n/* Used by static binaries to check the auxiliary vector.  */\nextern void _dl_aux_init (ElfW(auxv_t) *av)\n     attribute_hidden;\n\n/* Return true if the ld.so copy in this namespace is actually active\n   and working.  If false, the dl_open/dlfcn hooks have to be used to\n   call into the outer dynamic linker (which happens after static\n   dlopen).  */\n#ifdef SHARED\nstatic inline bool\nrtld_active (void)\n{\n  /* The default-initialized variable does not have a non-zero\n     dl_init_all_dirs member, so this allows us to recognize an\n     initialized and active ld.so copy.  */\n  return GLRO(dl_init_all_dirs) != NULL;\n}\n#endif\n\n__END_DECLS\n\n#endif /* ldsodefs.h */\n"}, "12": {"id": 12, "path": "/media/lavo07/lavo07/glibc/sysdeps/generic/hp-timing-common.h", "content": "/* High precision, low overhead timing functions.  Generic version.\n   Copyright (C) 1998-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n/* In case a platform supports timers in the hardware the following macros\n   and types must be defined:\n\n   - HP_TIMING_AVAIL: test for availability.\n\n   - HP_TIMING_INLINE: this macro is non-zero if the functionality is not\n     implemented using function calls but instead uses some inlined code\n     which might simply consist of a few assembler instructions.  We have to\n     know this since we might want to use the macros here in places where we\n     cannot make function calls.\n\n   - hp_timing_t: This is the type for variables used to store the time\n     values.  This type must be integral.\n\n   - HP_TIMING_NOW: place timestamp for current time in variable given as\n     parameter.\n*/\n\n/* The target supports hp-timing.  Share the common infrastructure.  */\n\n#include <string.h>\n#include <sys/param.h>\n#include <_itoa.h>\n\n/* Compute the difference between START and END, storing into DIFF.  */\n#define HP_TIMING_DIFF(Diff, Start, End)\t((Diff) = (End) - (Start))\n\n/* Accumulate ADD into SUM.  No attempt is made to be thread-safe.  */\n#define HP_TIMING_ACCUM_NT(Sum, Diff)\t\t((Sum) += (Diff))\n\n/* Write a decimal representation of the timing value into the given string.  */\n#define HP_TIMING_PRINT(Dest, Len, Val) \t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\t\\\n    char __buf[20];\t\t\t\t\t\t\t\\\n    char *__dest = (Dest);\t\t\t\t\t\t\\\n    size_t __len = (Len);\t\t\t\t\t\t\\\n    char *__cp = _itoa ((Val), __buf + sizeof (__buf), 10, 0);\t\t\\\n    size_t __cp_len = MIN (__buf + sizeof (__buf) - __cp, __len);\t\\\n    memcpy (__dest, __cp, __cp_len);\t\t\t\t\t\\\n    memcpy (__dest + __cp_len, \" cycles\",\t\t\t\t\\\n\t    MIN (__len - __cp_len, sizeof (\" cycles\")));\t\t\\\n    __dest[__len - 1] = '\\0';\t\t\t\t\t\t\\\n  } while (0)\n"}, "13": {"id": 13, "path": "/media/lavo07/lavo07/glibc/misc/sys/param.h", "content": "/* Compatibility header for old-style Unix parameters and limits.\n   Copyright (C) 1995-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n#ifndef _SYS_PARAM_H\n#define _SYS_PARAM_H    1\n\n#define __need_NULL\n#include <stddef.h>\n\n#include <sys/types.h>\n#include <limits.h>\n#include <endian.h>                     /* Define BYTE_ORDER et al.  */\n#include <signal.h>                     /* Define NSIG.  */\n\n/* This file defines some things in system-specific ways.  */\n#include <bits/param.h>\n\n\n/* BSD names for some <limits.h> values.  */\n\n#define NBBY\t\tCHAR_BIT\n\n#if !defined NGROUPS && defined NGROUPS_MAX\n# define NGROUPS\tNGROUPS_MAX\n#endif\n#if !defined MAXSYMLINKS && defined SYMLOOP_MAX\n# define MAXSYMLINKS\tSYMLOOP_MAX\n#endif\n#if !defined CANBSIZ && defined MAX_CANON\n# define CANBSIZ\tMAX_CANON\n#endif\n#if !defined MAXPATHLEN && defined PATH_MAX\n# define MAXPATHLEN\tPATH_MAX\n#endif\n#if !defined NOFILE && defined OPEN_MAX\n# define NOFILE\t\tOPEN_MAX\n#endif\n#if !defined MAXHOSTNAMELEN && defined HOST_NAME_MAX\n# define MAXHOSTNAMELEN\tHOST_NAME_MAX\n#endif\n#ifndef NCARGS\n# ifdef ARG_MAX\n#  define NCARGS\tARG_MAX\n# else\n/* ARG_MAX is unlimited, but we define NCARGS for BSD programs that want to\n   compare against some fixed limit.  */\n# define NCARGS\t\tINT_MAX\n# endif\n#endif\n\n\n/* Magical constants.  */\n#ifndef NOGROUP\n# define NOGROUP\t65535     /* Marker for empty group set member.  */\n#endif\n#ifndef NODEV\n# define NODEV\t\t((dev_t) -1)    /* Non-existent device.  */\n#endif\n\n\n/* Unit of `st_blocks'.  */\n#ifndef DEV_BSIZE\n# define DEV_BSIZE\t512\n#endif\n\n\n/* Bit map related macros.  */\n#define setbit(a,i)     ((a)[(i)/NBBY] |= 1<<((i)%NBBY))\n#define clrbit(a,i)     ((a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))\n#define isset(a,i)      ((a)[(i)/NBBY] & (1<<((i)%NBBY)))\n#define isclr(a,i)      (((a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)\n\n/* Macros for counting and rounding.  */\n#ifndef howmany\n# define howmany(x, y)  (((x) + ((y) - 1)) / (y))\n#endif\n#ifdef __GNUC__\n# define roundup(x, y)  (__builtin_constant_p (y) && powerof2 (y)             \\\n                         ? (((x) + (y) - 1) & ~((y) - 1))                     \\\n                         : ((((x) + ((y) - 1)) / (y)) * (y)))\n#else\n# define roundup(x, y)  ((((x) + ((y) - 1)) / (y)) * (y))\n#endif\n#define powerof2(x)     ((((x) - 1) & (x)) == 0)\n\n/* Macros for min/max.  */\n#define MIN(a,b) (((a)<(b))?(a):(b))\n#define MAX(a,b) (((a)>(b))?(a):(b))\n\n\n#endif  /* sys/param.h */\n"}, "34": {"id": 34, "path": "/media/lavo07/lavo07/glibc/sysdeps/x86/dl-prop.h", "content": "/* Support for GNU properties.  x86 version.\n   Copyright (C) 2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n#ifndef _DL_PROP_H\n#define _DL_PROP_H\n\n#include <not-cancel.h>\n\nextern void _dl_cet_check (struct link_map *, const char *)\n    attribute_hidden;\nextern void _dl_cet_open_check (struct link_map *)\n    attribute_hidden;\n\nstatic inline void __attribute__ ((always_inline))\n_rtld_main_check (struct link_map *m, const char *program)\n{\n#if CET_ENABLED\n  _dl_cet_check (m, program);\n#endif\n}\n\nstatic inline void __attribute__ ((always_inline))\n_dl_open_check (struct link_map *m)\n{\n#if CET_ENABLED\n  _dl_cet_open_check (m);\n#endif\n}\n\nstatic inline void __attribute__ ((unused))\n_dl_process_cet_property_note (struct link_map *l,\n\t\t\t      const ElfW(Nhdr) *note,\n\t\t\t      const ElfW(Addr) size,\n\t\t\t      const ElfW(Addr) align)\n{\n#if CET_ENABLED\n  /* The NT_GNU_PROPERTY_TYPE_0 note must be aliged to 4 bytes in\n     32-bit objects and to 8 bytes in 64-bit objects.  Skip notes\n     with incorrect alignment.  */\n  if (align != (__ELF_NATIVE_CLASS / 8))\n    return;\n\n  const ElfW(Addr) start = (ElfW(Addr)) note;\n\n  while ((ElfW(Addr)) (note + 1) - start < size)\n    {\n      /* Find the NT_GNU_PROPERTY_TYPE_0 note.  */\n      if (note->n_namesz == 4\n\t  && note->n_type == NT_GNU_PROPERTY_TYPE_0\n\t  && memcmp (note + 1, \"GNU\", 4) == 0)\n\t{\n\t  /* Check for invalid property.  */\n\t  if (note->n_descsz < 8\n\t      || (note->n_descsz % sizeof (ElfW(Addr))) != 0)\n\t    break;\n\n\t  /* Start and end of property array.  */\n\t  unsigned char *ptr = (unsigned char *) (note + 1) + 4;\n\t  unsigned char *ptr_end = ptr + note->n_descsz;\n\n\t  do\n\t    {\n\t      unsigned int type = *(unsigned int *) ptr;\n\t      unsigned int datasz = *(unsigned int *) (ptr + 4);\n\n\t      ptr += 8;\n\t      if ((ptr + datasz) > ptr_end)\n\t\tbreak;\n\n\t      if (type == GNU_PROPERTY_X86_FEATURE_1_AND)\n\t\t{\n\t\t  /* The size of GNU_PROPERTY_X86_FEATURE_1_AND is 4\n\t\t     bytes.  When seeing GNU_PROPERTY_X86_FEATURE_1_AND,\n\t\t     we stop the search regardless if its size is correct\n\t\t     or not.  There is no point to continue if this note\n\t\t     is ill-formed.  */\n\t\t  if (datasz == 4)\n\t\t    {\n\t\t      unsigned int feature_1 = *(unsigned int *) ptr;\n\t\t      if ((feature_1 & GNU_PROPERTY_X86_FEATURE_1_IBT))\n\t\t\tl->l_cet |= lc_ibt;\n\t\t      if ((feature_1 & GNU_PROPERTY_X86_FEATURE_1_SHSTK))\n\t\t\tl->l_cet |= lc_shstk;\n\t\t    }\n\t\t  return;\n\t\t}\n\n\t      /* Check the next property item.  */\n\t      ptr += ALIGN_UP (datasz, sizeof (ElfW(Addr)));\n\t    }\n\t  while ((ptr_end - ptr) >= 8);\n\t}\n\n      /* NB: Note sections like .note.ABI-tag and .note.gnu.build-id are\n\t aligned to 4 bytes in 64-bit ELF objects.  */\n      note = ((const void *) note\n\t      + ELF_NOTE_NEXT_OFFSET (note->n_namesz, note->n_descsz,\n\t\t\t\t      align));\n    }\n#endif\n}\n\n#ifdef FILEBUF_SIZE\nstatic inline int __attribute__ ((unused))\n_dl_process_pt_note (struct link_map *l, const ElfW(Phdr) *ph,\n\t\t     int fd, struct filebuf *fbp)\n{\n# if CET_ENABLED\n  const ElfW(Nhdr) *note;\n  ElfW(Nhdr) *note_malloced = NULL;\n  ElfW(Addr) size = ph->p_filesz;\n\n  if (ph->p_offset + size <= (size_t) fbp->len)\n    note = (const void *) (fbp->buf + ph->p_offset);\n  else\n    {\n      if (size < __MAX_ALLOCA_CUTOFF)\n\tnote = alloca (size);\n      else\n\t{\n\t  note_malloced = malloc (size);\n\t  note = note_malloced;\n\t}\n      __lseek (fd, ph->p_offset, SEEK_SET);\n      if (__read_nocancel (fd, (void *) note, size) != size)\n\t{\n\t  if (note_malloced)\n\t    free (note_malloced);\n\t  return -1;\n\t}\n    }\n\n  _dl_process_cet_property_note (l, note, size, ph->p_align);\n  if (note_malloced)\n    free (note_malloced);\n# endif\n  return 0;\n}\n#endif\n\nstatic inline int __attribute__ ((unused))\n_rtld_process_pt_note (struct link_map *l, const ElfW(Phdr) *ph)\n{\n  const ElfW(Nhdr) *note = (const void *) (ph->p_vaddr + l->l_addr);\n  _dl_process_cet_property_note (l, note, ph->p_memsz, ph->p_align);\n  return 0;\n}\n\n#endif /* _DL_PROP_H */\n"}, "37": {"id": 37, "path": "/media/lavo07/lavo07/glibc/sysdeps/x86_64/dl-machine.h", "content": "/* Machine-dependent ELF dynamic relocation inline functions.  x86-64 version.\n   Copyright (C) 2001-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n   Contributed by Andreas Jaeger <aj@suse.de>.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n#ifndef dl_machine_h\n#define dl_machine_h\n\n#define ELF_MACHINE_NAME \"x86_64\"\n\n#include <sys/param.h>\n#include <sysdep.h>\n#include <tls.h>\n#include <dl-tlsdesc.h>\n#include <cpu-features.c>\n\n/* Return nonzero iff ELF header is compatible with the running host.  */\nstatic inline int __attribute__ ((unused))\nelf_machine_matches_host (const ElfW(Ehdr) *ehdr)\n{\n  return ehdr->e_machine == EM_X86_64;\n}\n\n\n/* Return the link-time address of _DYNAMIC.  Conveniently, this is the\n   first element of the GOT.  This must be inlined in a function which\n   uses global data.  */\nstatic inline ElfW(Addr) __attribute__ ((unused))\nelf_machine_dynamic (void)\n{\n  /* This produces an IP-relative reloc which is resolved at link time. */\n  extern const ElfW(Addr) _GLOBAL_OFFSET_TABLE_[] attribute_hidden;\n  return _GLOBAL_OFFSET_TABLE_[0];\n}\n\n\n/* Return the run-time load address of the shared object.  */\nstatic inline ElfW(Addr) __attribute__ ((unused))\nelf_machine_load_address (void)\n{\n  /* Compute the difference between the runtime address of _DYNAMIC as seen\n     by an IP-relative reference, and the link-time address found in the\n     special unrelocated first GOT entry.  */\n  extern ElfW(Dyn) _DYNAMIC[] attribute_hidden;\n  return (ElfW(Addr)) &_DYNAMIC - elf_machine_dynamic ();\n}\n\n/* Set up the loaded object described by L so its unrelocated PLT\n   entries will jump to the on-demand fixup code in dl-runtime.c.  */\n\nstatic inline int __attribute__ ((unused, always_inline))\nelf_machine_runtime_setup (struct link_map *l, int lazy, int profile)\n{\n  Elf64_Addr *got;\n  extern void _dl_runtime_resolve_fxsave (ElfW(Word)) attribute_hidden;\n  extern void _dl_runtime_resolve_xsave (ElfW(Word)) attribute_hidden;\n  extern void _dl_runtime_resolve_xsavec (ElfW(Word)) attribute_hidden;\n  extern void _dl_runtime_profile_sse (ElfW(Word)) attribute_hidden;\n  extern void _dl_runtime_profile_avx (ElfW(Word)) attribute_hidden;\n  extern void _dl_runtime_profile_avx512 (ElfW(Word)) attribute_hidden;\n\n  if (l->l_info[DT_JMPREL] && lazy)\n    {\n      /* The GOT entries for functions in the PLT have not yet been filled\n\t in.  Their initial contents will arrange when called to push an\n\t offset into the .rel.plt section, push _GLOBAL_OFFSET_TABLE_[1],\n\t and then jump to _GLOBAL_OFFSET_TABLE_[2].  */\n      got = (Elf64_Addr *) D_PTR (l, l_info[DT_PLTGOT]);\n      /* If a library is prelinked but we have to relocate anyway,\n\t we have to be able to undo the prelinking of .got.plt.\n\t The prelinker saved us here address of .plt + 0x16.  */\n      if (got[1])\n\t{\n\t  l->l_mach.plt = got[1] + l->l_addr;\n\t  l->l_mach.gotplt = (ElfW(Addr)) &got[3];\n\t}\n      /* Identify this shared object.  */\n      *(ElfW(Addr) *) (got + 1) = (ElfW(Addr)) l;\n\n      /* The got[2] entry contains the address of a function which gets\n\t called to get the address of a so far unresolved function and\n\t jump to it.  The profiling extension of the dynamic linker allows\n\t to intercept the calls to collect information.  In this case we\n\t don't store the address in the GOT so that all future calls also\n\t end in this function.  */\n      if (__glibc_unlikely (profile))\n\t{\n\t  if (HAS_ARCH_FEATURE (AVX512F_Usable))\n\t    *(ElfW(Addr) *) (got + 2) = (ElfW(Addr)) &_dl_runtime_profile_avx512;\n\t  else if (HAS_ARCH_FEATURE (AVX_Usable))\n\t    *(ElfW(Addr) *) (got + 2) = (ElfW(Addr)) &_dl_runtime_profile_avx;\n\t  else\n\t    *(ElfW(Addr) *) (got + 2) = (ElfW(Addr)) &_dl_runtime_profile_sse;\n\n\t  if (GLRO(dl_profile) != NULL\n\t      && _dl_name_match_p (GLRO(dl_profile), l))\n\t    /* This is the object we are looking for.  Say that we really\n\t       want profiling and the timers are started.  */\n\t    GL(dl_profile_map) = l;\n\t}\n      else\n\t{\n\t  /* This function will get called to fix up the GOT entry\n\t     indicated by the offset on the stack, and then jump to\n\t     the resolved address.  */\n\t  if (GLRO(dl_x86_cpu_features).xsave_state_size != 0)\n\t    *(ElfW(Addr) *) (got + 2)\n\t      = (HAS_ARCH_FEATURE (XSAVEC_Usable)\n\t\t ? (ElfW(Addr)) &_dl_runtime_resolve_xsavec\n\t\t : (ElfW(Addr)) &_dl_runtime_resolve_xsave);\n\t  else\n\t    *(ElfW(Addr) *) (got + 2)\n\t      = (ElfW(Addr)) &_dl_runtime_resolve_fxsave;\n\t}\n    }\n\n  if (l->l_info[ADDRIDX (DT_TLSDESC_GOT)] && lazy)\n    *(ElfW(Addr)*)(D_PTR (l, l_info[ADDRIDX (DT_TLSDESC_GOT)]) + l->l_addr)\n      = (ElfW(Addr)) &_dl_tlsdesc_resolve_rela;\n\n  return lazy;\n}\n\n/* Initial entry point code for the dynamic linker.\n   The C function `_dl_start' is the real entry point;\n   its return value is the user program's entry point.  */\n#define RTLD_START asm (\"\\n\\\n.text\\n\\\n\t.align 16\\n\\\n.globl _start\\n\\\n.globl _dl_start_user\\n\\\n_start:\\n\\\n\tmovq %rsp, %rdi\\n\\\n\tcall _dl_start\\n\\\n_dl_start_user:\\n\\\n\t# Save the user entry point address in %r12.\\n\\\n\tmovq %rax, %r12\\n\\\n\t# See if we were run as a command with the executable file\\n\\\n\t# name as an extra leading argument.\\n\\\n\tmovl _dl_skip_args(%rip), %eax\\n\\\n\t# Pop the original argument count.\\n\\\n\tpopq %rdx\\n\\\n\t# Adjust the stack pointer to skip _dl_skip_args words.\\n\\\n\tleaq (%rsp,%rax,8), %rsp\\n\\\n\t# Subtract _dl_skip_args from argc.\\n\\\n\tsubl %eax, %edx\\n\\\n\t# Push argc back on the stack.\\n\\\n\tpushq %rdx\\n\\\n\t# Call _dl_init (struct link_map *main_map, int argc, char **argv, char **env)\\n\\\n\t# argc -> rsi\\n\\\n\tmovq %rdx, %rsi\\n\\\n\t# Save %rsp value in %r13.\\n\\\n\tmovq %rsp, %r13\\n\\\n\t# And align stack for the _dl_init call. \\n\\\n\tandq $-16, %rsp\\n\\\n\t# _dl_loaded -> rdi\\n\\\n\tmovq _rtld_local(%rip), %rdi\\n\\\n\t# env -> rcx\\n\\\n\tleaq 16(%r13,%rdx,8), %rcx\\n\\\n\t# argv -> rdx\\n\\\n\tleaq 8(%r13), %rdx\\n\\\n\t# Clear %rbp to mark outermost frame obviously even for constructors.\\n\\\n\txorl %ebp, %ebp\\n\\\n\t# Call the function to run the initializers.\\n\\\n\tcall _dl_init\\n\\\n\t# Pass our finalizer function to the user in %rdx, as per ELF ABI.\\n\\\n\tleaq _dl_fini(%rip), %rdx\\n\\\n\t# And make sure %rsp points to argc stored on the stack.\\n\\\n\tmovq %r13, %rsp\\n\\\n\t# Jump to the user's entry point.\\n\\\n\tjmp *%r12\\n\\\n.previous\\n\\\n\");\n\n/* ELF_RTYPE_CLASS_PLT iff TYPE describes relocation of a PLT entry or\n   TLS variable, so undefined references should not be allowed to\n   define the value.\n   ELF_RTYPE_CLASS_COPY iff TYPE should not be allowed to resolve to one\n   of the main executable's symbols, as for a COPY reloc.\n   ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA iff TYPE describes relocation may\n   against protected data whose address be external due to copy relocation.\n */\n#define elf_machine_type_class(type)\t\t\t\t\t      \\\n  ((((type) == R_X86_64_JUMP_SLOT\t\t\t\t\t      \\\n     || (type) == R_X86_64_DTPMOD64\t\t\t\t\t      \\\n     || (type) == R_X86_64_DTPOFF64\t\t\t\t\t      \\\n     || (type) == R_X86_64_TPOFF64\t\t\t\t\t      \\\n     || (type) == R_X86_64_TLSDESC)\t\t\t\t\t      \\\n    * ELF_RTYPE_CLASS_PLT)\t\t\t\t\t\t      \\\n   | (((type) == R_X86_64_COPY) * ELF_RTYPE_CLASS_COPY)\t\t\t      \\\n   | (((type) == R_X86_64_GLOB_DAT) * ELF_RTYPE_CLASS_EXTERN_PROTECTED_DATA))\n\n/* A reloc type used for ld.so cmdline arg lookups to reject PLT entries.  */\n#define ELF_MACHINE_JMP_SLOT\tR_X86_64_JUMP_SLOT\n\n/* The relative ifunc relocation.  */\n// XXX This is a work-around for a broken linker.  Remove!\n#define ELF_MACHINE_IRELATIVE\tR_X86_64_IRELATIVE\n\n/* The x86-64 never uses Elf64_Rel/Elf32_Rel relocations.  */\n#define ELF_MACHINE_NO_REL 1\n#define ELF_MACHINE_NO_RELA 0\n\n/* We define an initialization function.  This is called very early in\n   _dl_sysdep_start.  */\n#define DL_PLATFORM_INIT dl_platform_init ()\n\nstatic inline void __attribute__ ((unused))\ndl_platform_init (void)\n{\n#if IS_IN (rtld)\n  /* init_cpu_features has been called early from __libc_start_main in\n     static executable.  */\n  init_cpu_features (&GLRO(dl_x86_cpu_features));\n#else\n  if (GLRO(dl_platform) != NULL && *GLRO(dl_platform) == '\\0')\n    /* Avoid an empty string which would disturb us.  */\n    GLRO(dl_platform) = NULL;\n#endif\n}\n\nstatic inline ElfW(Addr)\nelf_machine_fixup_plt (struct link_map *map, lookup_t t,\n\t\t       const ElfW(Sym) *refsym, const ElfW(Sym) *sym,\n\t\t       const ElfW(Rela) *reloc,\n\t\t       ElfW(Addr) *reloc_addr, ElfW(Addr) value)\n{\n  return *reloc_addr = value;\n}\n\n/* Return the final value of a PLT relocation.  On x86-64 the\n   JUMP_SLOT relocation ignores the addend.  */\nstatic inline ElfW(Addr)\nelf_machine_plt_value (struct link_map *map, const ElfW(Rela) *reloc,\n\t\t       ElfW(Addr) value)\n{\n  return value;\n}\n\n\n/* Names of the architecture-specific auditing callback functions.  */\n#define ARCH_LA_PLTENTER x86_64_gnu_pltenter\n#define ARCH_LA_PLTEXIT x86_64_gnu_pltexit\n\n#endif /* !dl_machine_h */\n\n#ifdef RESOLVE_MAP\n\n/* Perform the relocation specified by RELOC and SYM (which is fully resolved).\n   MAP is the object containing the reloc.  */\n\nauto inline void\n__attribute__ ((always_inline))\nelf_machine_rela (struct link_map *map, const ElfW(Rela) *reloc,\n\t\t  const ElfW(Sym) *sym, const struct r_found_version *version,\n\t\t  void *const reloc_addr_arg, int skip_ifunc)\n{\n  ElfW(Addr) *const reloc_addr = reloc_addr_arg;\n  const unsigned long int r_type = ELFW(R_TYPE) (reloc->r_info);\n\n# if !defined RTLD_BOOTSTRAP || !defined HAVE_Z_COMBRELOC\n  if (__glibc_unlikely (r_type == R_X86_64_RELATIVE))\n    {\n#  if !defined RTLD_BOOTSTRAP && !defined HAVE_Z_COMBRELOC\n      /* This is defined in rtld.c, but nowhere in the static libc.a;\n\t make the reference weak so static programs can still link.\n\t This declaration cannot be done when compiling rtld.c\n\t (i.e. #ifdef RTLD_BOOTSTRAP) because rtld.c contains the\n\t common defn for _dl_rtld_map, which is incompatible with a\n\t weak decl in the same file.  */\n#   ifndef SHARED\n      weak_extern (GL(dl_rtld_map));\n#   endif\n      if (map != &GL(dl_rtld_map)) /* Already done in rtld itself.  */\n#  endif\n\t*reloc_addr = map->l_addr + reloc->r_addend;\n    }\n  else\n# endif\n# if !defined RTLD_BOOTSTRAP\n  /* l_addr + r_addend may be > 0xffffffff and R_X86_64_RELATIVE64\n     relocation updates the whole 64-bit entry.  */\n  if (__glibc_unlikely (r_type == R_X86_64_RELATIVE64))\n    *(Elf64_Addr *) reloc_addr = (Elf64_Addr) map->l_addr + reloc->r_addend;\n  else\n# endif\n  if (__glibc_unlikely (r_type == R_X86_64_NONE))\n    return;\n  else\n    {\n# ifndef RTLD_BOOTSTRAP\n      const ElfW(Sym) *const refsym = sym;\n# endif\n      struct link_map *sym_map = RESOLVE_MAP (&sym, version, r_type);\n      ElfW(Addr) value = SYMBOL_ADDRESS (sym_map, sym, true);\n\n      if (sym != NULL\n\t  && __glibc_unlikely (ELFW(ST_TYPE) (sym->st_info) == STT_GNU_IFUNC)\n\t  && __glibc_likely (sym->st_shndx != SHN_UNDEF)\n\t  && __glibc_likely (!skip_ifunc))\n\t{\n# ifndef RTLD_BOOTSTRAP\n\t  if (sym_map != map\n\t      && sym_map->l_type != lt_executable\n\t      && !sym_map->l_relocated)\n\t    {\n\t      const char *strtab\n\t\t= (const char *) D_PTR (map, l_info[DT_STRTAB]);\n\t      _dl_error_printf (\"\\\n%s: Relink `%s' with `%s' for IFUNC symbol `%s'\\n\",\n\t\t\t\tRTLD_PROGNAME, map->l_name,\n\t\t\t\tsym_map->l_name,\n\t\t\t\tstrtab + refsym->st_name);\n\t    }\n# endif\n\t  value = ((ElfW(Addr) (*) (void)) value) ();\n\t}\n\n      switch (r_type)\n\t{\n# ifndef RTLD_BOOTSTRAP\n#  ifdef __ILP32__\n\tcase R_X86_64_SIZE64:\n\t  /* Set to symbol size plus addend.  */\n\t  *(Elf64_Addr *) (uintptr_t) reloc_addr\n\t    = (Elf64_Addr) sym->st_size + reloc->r_addend;\n\t  break;\n\n\tcase R_X86_64_SIZE32:\n#  else\n\tcase R_X86_64_SIZE64:\n#  endif\n\t  /* Set to symbol size plus addend.  */\n\t  value = sym->st_size;\n# endif\n\tcase R_X86_64_GLOB_DAT:\n\tcase R_X86_64_JUMP_SLOT:\n\t  *reloc_addr = value + reloc->r_addend;\n\t  break;\n\n# ifndef RESOLVE_CONFLICT_FIND_MAP\n\tcase R_X86_64_DTPMOD64:\n#  ifdef RTLD_BOOTSTRAP\n\t  /* During startup the dynamic linker is always the module\n\t     with index 1.\n\t     XXX If this relocation is necessary move before RESOLVE\n\t     call.  */\n\t  *reloc_addr = 1;\n#  else\n\t  /* Get the information from the link map returned by the\n\t     resolve function.  */\n\t  if (sym_map != NULL)\n\t    *reloc_addr = sym_map->l_tls_modid;\n#  endif\n\t  break;\n\tcase R_X86_64_DTPOFF64:\n#  ifndef RTLD_BOOTSTRAP\n\t  /* During relocation all TLS symbols are defined and used.\n\t     Therefore the offset is already correct.  */\n\t  if (sym != NULL)\n\t    {\n\t      value = sym->st_value + reloc->r_addend;\n#   ifdef __ILP32__\n\t      /* This relocation type computes a signed offset that is\n\t\t usually negative.  The symbol and addend values are 32\n\t\t bits but the GOT entry is 64 bits wide and the whole\n\t\t 64-bit entry is used as a signed quantity, so we need\n\t\t to sign-extend the computed value to 64 bits.  */\n\t      *(Elf64_Sxword *) reloc_addr = (Elf64_Sxword) (Elf32_Sword) value;\n#   else\n\t      *reloc_addr = value;\n#   endif\n\t    }\n#  endif\n\t  break;\n\tcase R_X86_64_TLSDESC:\n\t  {\n\t    struct tlsdesc volatile *td =\n\t      (struct tlsdesc volatile *)reloc_addr;\n\n#  ifndef RTLD_BOOTSTRAP\n\t    if (! sym)\n\t      {\n\t\ttd->arg = (void*)reloc->r_addend;\n\t\ttd->entry = _dl_tlsdesc_undefweak;\n\t      }\n\t    else\n#  endif\n\t      {\n#  ifndef RTLD_BOOTSTRAP\n#   ifndef SHARED\n\t\tCHECK_STATIC_TLS (map, sym_map);\n#   else\n\t\tif (!TRY_STATIC_TLS (map, sym_map))\n\t\t  {\n\t\t    td->arg = _dl_make_tlsdesc_dynamic\n\t\t      (sym_map, sym->st_value + reloc->r_addend);\n\t\t    td->entry = _dl_tlsdesc_dynamic;\n\t\t  }\n\t\telse\n#   endif\n#  endif\n\t\t  {\n\t\t    td->arg = (void*)(sym->st_value - sym_map->l_tls_offset\n\t\t\t\t      + reloc->r_addend);\n\t\t    td->entry = _dl_tlsdesc_return;\n\t\t  }\n\t      }\n\t    break;\n\t  }\n\tcase R_X86_64_TPOFF64:\n\t  /* The offset is negative, forward from the thread pointer.  */\n#  ifndef RTLD_BOOTSTRAP\n\t  if (sym != NULL)\n#  endif\n\t    {\n#  ifndef RTLD_BOOTSTRAP\n\t      CHECK_STATIC_TLS (map, sym_map);\n#  endif\n\t      /* We know the offset of the object the symbol is contained in.\n\t\t It is a negative value which will be added to the\n\t\t thread pointer.  */\n\t      value = (sym->st_value + reloc->r_addend\n\t\t       - sym_map->l_tls_offset);\n#  ifdef __ILP32__\n\t      /* The symbol and addend values are 32 bits but the GOT\n\t\t entry is 64 bits wide and the whole 64-bit entry is used\n\t\t as a signed quantity, so we need to sign-extend the\n\t\t computed value to 64 bits.  */\n\t      *(Elf64_Sxword *) reloc_addr = (Elf64_Sxword) (Elf32_Sword) value;\n#  else\n\t      *reloc_addr = value;\n#  endif\n\t    }\n\t  break;\n# endif\n\n# ifndef RTLD_BOOTSTRAP\n\tcase R_X86_64_64:\n\t  /* value + r_addend may be > 0xffffffff and R_X86_64_64\n\t     relocation updates the whole 64-bit entry.  */\n\t  *(Elf64_Addr *) reloc_addr = (Elf64_Addr) value + reloc->r_addend;\n\t  break;\n#  ifndef __ILP32__\n\tcase R_X86_64_SIZE32:\n\t  /* Set to symbol size plus addend.  */\n\t  value = sym->st_size;\n#  endif\n\tcase R_X86_64_32:\n\t  value += reloc->r_addend;\n\t  *(unsigned int *) reloc_addr = value;\n\n\t  const char *fmt;\n\t  if (__glibc_unlikely (value > UINT_MAX))\n\t    {\n\t      const char *strtab;\n\n\t      fmt = \"\\\n%s: Symbol `%s' causes overflow in R_X86_64_32 relocation\\n\";\n#  ifndef RESOLVE_CONFLICT_FIND_MAP\n\t    print_err:\n#  endif\n\t      strtab = (const char *) D_PTR (map, l_info[DT_STRTAB]);\n\n\t      _dl_error_printf (fmt, RTLD_PROGNAME, strtab + refsym->st_name);\n\t    }\n\t  break;\n#  ifndef RESOLVE_CONFLICT_FIND_MAP\n\t  /* Not needed for dl-conflict.c.  */\n\tcase R_X86_64_PC32:\n\t  value += reloc->r_addend - (ElfW(Addr)) reloc_addr;\n\t  *(unsigned int *) reloc_addr = value;\n\t  if (__glibc_unlikely (value != (int) value))\n\t    {\n\t      fmt = \"\\\n%s: Symbol `%s' causes overflow in R_X86_64_PC32 relocation\\n\";\n\t      goto print_err;\n\t    }\n\t  break;\n\tcase R_X86_64_COPY:\n\t  if (sym == NULL)\n\t    /* This can happen in trace mode if an object could not be\n\t       found.  */\n\t    break;\n\t  memcpy (reloc_addr_arg, (void *) value,\n\t\t  MIN (sym->st_size, refsym->st_size));\n\t  if (__glibc_unlikely (sym->st_size > refsym->st_size)\n\t      || (__glibc_unlikely (sym->st_size < refsym->st_size)\n\t\t  && GLRO(dl_verbose)))\n\t    {\n\t      fmt = \"\\\n%s: Symbol `%s' has different size in shared object, consider re-linking\\n\";\n\t      goto print_err;\n\t    }\n\t  break;\n#  endif\n\tcase R_X86_64_IRELATIVE:\n\t  value = map->l_addr + reloc->r_addend;\n\t  value = ((ElfW(Addr) (*) (void)) value) ();\n\t  *reloc_addr = value;\n\t  break;\n\tdefault:\n\t  _dl_reloc_bad_type (map, r_type, 0);\n\t  break;\n# endif\n\t}\n    }\n}\n\nauto inline void\n__attribute ((always_inline))\nelf_machine_rela_relative (ElfW(Addr) l_addr, const ElfW(Rela) *reloc,\n\t\t\t   void *const reloc_addr_arg)\n{\n  ElfW(Addr) *const reloc_addr = reloc_addr_arg;\n#if !defined RTLD_BOOTSTRAP\n  /* l_addr + r_addend may be > 0xffffffff and R_X86_64_RELATIVE64\n     relocation updates the whole 64-bit entry.  */\n  if (__glibc_unlikely (ELFW(R_TYPE) (reloc->r_info) == R_X86_64_RELATIVE64))\n    *(Elf64_Addr *) reloc_addr = (Elf64_Addr) l_addr + reloc->r_addend;\n  else\n#endif\n    {\n      assert (ELFW(R_TYPE) (reloc->r_info) == R_X86_64_RELATIVE);\n      *reloc_addr = l_addr + reloc->r_addend;\n    }\n}\n\nauto inline void\n__attribute ((always_inline))\nelf_machine_lazy_rel (struct link_map *map,\n\t\t      ElfW(Addr) l_addr, const ElfW(Rela) *reloc,\n\t\t      int skip_ifunc)\n{\n  ElfW(Addr) *const reloc_addr = (void *) (l_addr + reloc->r_offset);\n  const unsigned long int r_type = ELFW(R_TYPE) (reloc->r_info);\n\n  /* Check for unexpected PLT reloc type.  */\n  if (__glibc_likely (r_type == R_X86_64_JUMP_SLOT))\n    {\n      /* Prelink has been deprecated.  */\n      if (__glibc_likely (map->l_mach.plt == 0))\n\t*reloc_addr += l_addr;\n      else\n\t*reloc_addr =\n\t  map->l_mach.plt\n\t  + (((ElfW(Addr)) reloc_addr) - map->l_mach.gotplt) * 2;\n    }\n  else if (__glibc_likely (r_type == R_X86_64_TLSDESC))\n    {\n      struct tlsdesc volatile * __attribute__((__unused__)) td =\n\t(struct tlsdesc volatile *)reloc_addr;\n\n      td->arg = (void*)reloc;\n      td->entry = (void*)(D_PTR (map, l_info[ADDRIDX (DT_TLSDESC_PLT)])\n\t\t\t  + map->l_addr);\n    }\n  else if (__glibc_unlikely (r_type == R_X86_64_IRELATIVE))\n    {\n      ElfW(Addr) value = map->l_addr + reloc->r_addend;\n      if (__glibc_likely (!skip_ifunc))\n\tvalue = ((ElfW(Addr) (*) (void)) value) ();\n      *reloc_addr = value;\n    }\n  else\n    _dl_reloc_bad_type (map, r_type, 1);\n}\n\n#endif /* RESOLVE_MAP */\n"}}, "reports": [{"events": [{"location": {"col": 39, "file": 5, "line": 32}, "message": "() (fixit)"}, {"location": {"col": 18, "file": 5, "line": 32}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/do-rel.h", "reportHash": "c3262af6580e043fe1ebc21e45a0a695", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 48, "file": 5, "line": 32}, "message": "() (fixit)"}, {"location": {"col": 27, "file": 5, "line": 32}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/do-rel.h", "reportHash": "54c64fca558eeb4817ca0aa35302952b", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 1, "file": 5, "line": 45}, "message": "function definition is not allowed here"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/do-rel.h", "reportHash": "7b1cf44f78f2883d2dcafa8bcdb469b5", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 1, "file": 6, "line": 70}, "message": "illegal storage class on function"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/dynamic-link.h", "reportHash": "9087400c15a87075b52c8137988b84fc", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 1, "file": 6, "line": 74}, "message": "illegal storage class on function"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/dynamic-link.h", "reportHash": "9087400c15a87075b52c8137988b84fc", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 1, "file": 6, "line": 84}, "message": "illegal storage class on function"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/dynamic-link.h", "reportHash": "9087400c15a87075b52c8137988b84fc", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 13, "file": 6, "line": 126}, "message": "() (fixit)"}, {"location": {"col": 6, "file": 6, "line": 126}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/dynamic-link.h", "reportHash": "75953bd2384fb5c5954d3aaf707dfcf4", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 15, "file": 6, "line": 128}, "message": "() (fixit)"}, {"location": {"col": 8, "file": 6, "line": 128}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/dynamic-link.h", "reportHash": "254556f7662832fe7f884935fa554df3", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 14, "file": 6, "line": 131}, "message": "() (fixit)"}, {"location": {"col": 7, "file": 6, "line": 131}, "message": "macro argument should be enclosed in parentheses"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/dynamic-link.h", "reportHash": "e3162113492c3f67a694933a932bae83", "checkerName": "misc-macro-parentheses", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 1, "file": 7, "line": 32}, "message": "function definition is not allowed here"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/get-dynamic-info.h", "reportHash": "6d4c13bcfabc65cb96266215b87b7156", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 40, "file": 7, "line": 52}, "message": "logical expression is always false"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/get-dynamic-info.h", "reportHash": "477e45cf4348c3fe2f95904c390c56cc", "checkerName": "misc-redundant-expression", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 5, "file": 6, "line": 199}, "message": "expanded from macro 'ELF_DYNAMIC_RELOCATE'"}, {"location": {"col": 3, "file": 6, "line": 187}, "message": "expanded from macro 'ELF_DYNAMIC_DO_RELA'"}, {"location": {"col": 7, "file": 6, "line": 154}, "message": "expanded from macro '_ELF_DYNAMIC_DO_RELOC'"}, {"location": {"col": 7, "file": 8, "line": 506}, "message": "implicit declaration of function 'elf_dynamic_do_Rela' is invalid in C99"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "5a46911b7f5715a27d4e3a2a56170522", "checkerName": "clang-diagnostic-implicit-function-declaration", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 11, "file": 9, "line": 106}, "message": "expanded from macro 'assert'"}, {"location": {"col": 13, "file": 8, "line": 721}, "message": "comparison of integers of different signs: 'int' and 'size_t' (aka 'unsigned long')"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "ff60bc926cfce65a7041fbc5342a4743", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 28, "file": 10, "line": 38}, "message": "expanded from macro 'DL_SYSDEP_OSCHECK'"}, {"location": {"col": 3, "file": 8, "line": 1323}, "message": "comparison of integers of different signs: 'unsigned int' and 'int'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "ca96541b7e9dd0c1ecf8beecc68358ca", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 31, "file": 11, "line": 729}, "message": "expanded from macro '_dl_printf'"}, {"location": {"col": 38, "file": 8, "line": 1835}, "message": "invalid conversion specifier 'Z'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "47f8fffa1025cf3c3c3fb0ee192b137c", "checkerName": "clang-diagnostic-format-invalid-specifier", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 31, "file": 11, "line": 729}, "message": "expanded from macro '_dl_printf'"}, {"location": {"col": 47, "file": 8, "line": 1835}, "message": "invalid conversion specifier 'Z'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "fc83b79b677f8e3fced519d71e2998be", "checkerName": "clang-diagnostic-format-invalid-specifier", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 38, "file": 11, "line": 729}, "message": "expanded from macro '_dl_printf'"}, {"location": {"col": 6, "file": 8, "line": 1838}, "message": "data argument not used by format string"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "c200fa28595f584669ac4673c38809ce", "checkerName": "clang-diagnostic-format-extra-args", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 31, "file": 11, "line": 729}, "message": "expanded from macro '_dl_printf'"}, {"location": {"col": 24, "file": 8, "line": 1844}, "message": "invalid conversion specifier 'Z'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "f97a077f9c82d7b28fe0588595669d94", "checkerName": "clang-diagnostic-format-invalid-specifier", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 31, "file": 11, "line": 729}, "message": "expanded from macro '_dl_printf'"}, {"location": {"col": 33, "file": 8, "line": 1844}, "message": "invalid conversion specifier 'Z'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "1577731b9f002b104093016dd8422f3e", "checkerName": "clang-diagnostic-format-invalid-specifier", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 38, "file": 11, "line": 729}, "message": "expanded from macro '_dl_printf'"}, {"location": {"col": 8, "file": 8, "line": 1845}, "message": "data argument not used by format string"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "784a0774470532dac7bca6b6dd7126d5", "checkerName": "clang-diagnostic-format-extra-args", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 31, "file": 11, "line": 729}, "message": "expanded from macro '_dl_printf'"}, {"location": {"col": 32, "file": 8, "line": 1906}, "message": "invalid conversion specifier 'Z'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "ff8b1b5c6441f5aa71db1dc636054391", "checkerName": "clang-diagnostic-format-invalid-specifier", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 38, "file": 11, "line": 729}, "message": "expanded from macro '_dl_printf'"}, {"location": {"col": 6, "file": 8, "line": 1907}, "message": "data argument not used by format string"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "c200fa28595f584669ac4673c38809ce", "checkerName": "clang-diagnostic-format-extra-args", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 31, "file": 11, "line": 729}, "message": "expanded from macro '_dl_printf'"}, {"location": {"col": 38, "file": 8, "line": 1910}, "message": "invalid conversion specifier 'Z'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "0287edcc02706392071cf0e633d9fedd", "checkerName": "clang-diagnostic-format-invalid-specifier", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 38, "file": 11, "line": 729}, "message": "expanded from macro '_dl_printf'"}, {"location": {"col": 17, "file": 8, "line": 1911}, "message": "data argument not used by format string"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "1e30c7ecd62a6eb793e531e1c53de3f4", "checkerName": "clang-diagnostic-format-extra-args", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 31, "file": 11, "line": 729}, "message": "expanded from macro '_dl_printf'"}, {"location": {"col": 36, "file": 8, "line": 1929}, "message": "invalid conversion specifier 'Z'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "5c9d2f0b707629fcd91291af63bccb09", "checkerName": "clang-diagnostic-format-invalid-specifier", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 31, "file": 11, "line": 729}, "message": "expanded from macro '_dl_printf'"}, {"location": {"col": 57, "file": 8, "line": 1929}, "message": "invalid conversion specifier 'Z'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "7bcf3f2baf0233aa28b90625e0b3dbb1", "checkerName": "clang-diagnostic-format-invalid-specifier", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 38, "file": 11, "line": 729}, "message": "expanded from macro '_dl_printf'"}, {"location": {"col": 4, "file": 8, "line": 1931}, "message": "data argument not used by format string"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "d06a36284b2c62c87e584907d899a640", "checkerName": "clang-diagnostic-format-extra-args", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 21, "file": 8, "line": 2428}, "message": "&           [ (fixit)"}, {"location": {"col": 38, "file": 11, "line": 729}, "message": "expanded from macro '_dl_printf'"}, {"location": {"col": 19, "file": 8, "line": 2428}, "message": "use array indexing to silence this warning"}, {"location": {"col": 38, "file": 11, "line": 729}, "message": "expanded from macro '_dl_printf'"}, {"location": {"col": 19, "file": 8, "line": 2428}, "message": "adding 'const unsigned char' to a string does not append to the string"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "7c37890f2eba762d92cc0508645a5c55", "checkerName": "clang-diagnostic-string-plus-int", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 23, "file": 12, "line": 57}, "message": "expanded from macro 'HP_TIMING_PRINT'"}, {"location": {"col": 23, "file": 13, "line": 102}, "message": "expanded from macro 'MIN'"}, {"location": {"col": 7, "file": 8, "line": 2707}, "message": "comparison of integers of different signs: 'long' and 'size_t' (aka 'unsigned long')"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "b6515a3ba128f556db825154a8683a57", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 23, "file": 12, "line": 57}, "message": "expanded from macro 'HP_TIMING_PRINT'"}, {"location": {"col": 23, "file": 13, "line": 102}, "message": "expanded from macro 'MIN'"}, {"location": {"col": 7, "file": 8, "line": 2713}, "message": "comparison of integers of different signs: 'long' and 'size_t' (aka 'unsigned long')"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "ef52e76799abf0b6eb8431b01d13a74a", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 26, "file": 8, "line": 2734}, "message": "comparison of integers of different signs: 'Lmid_t' (aka 'long') and 'size_t' (aka 'unsigned long')"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "7be150658305e1f9ba67aa19c6b79632", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 23, "file": 12, "line": 57}, "message": "expanded from macro 'HP_TIMING_PRINT'"}, {"location": {"col": 23, "file": 13, "line": 102}, "message": "expanded from macro 'MIN'"}, {"location": {"col": 7, "file": 8, "line": 2776}, "message": "comparison of integers of different signs: 'long' and 'size_t' (aka 'unsigned long')"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/elf/rtld.c", "reportHash": "44dd7326cdc13f0947028b121a07ae42", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 53, "file": 10, "line": 74}, "message": "unused parameter 'stack_chk_guard'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/unix/sysv/linux/dl-osinfo.h", "reportHash": "b2b148c5bed153657889b8a605449812", "checkerName": "clang-diagnostic-unused-parameter", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 36, "file": 34, "line": 30}, "message": "unused parameter 'm'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/x86/dl-prop.h", "reportHash": "5b2bfb340d709d603c24852fa91a7b6d", "checkerName": "clang-diagnostic-unused-parameter", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 51, "file": 34, "line": 30}, "message": "unused parameter 'program'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/x86/dl-prop.h", "reportHash": "8b0f2f2121e9ebcc556754728ca5a5a8", "checkerName": "clang-diagnostic-unused-parameter", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 34, "file": 34, "line": 38}, "message": "unused parameter 'm'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/x86/dl-prop.h", "reportHash": "3b1b5d295e3b1a6ab77183d0357978ea", "checkerName": "clang-diagnostic-unused-parameter", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 49, "file": 34, "line": 46}, "message": "unused parameter 'l'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/x86/dl-prop.h", "reportHash": "8489ac185602445ec06b03b96c3dd5e4", "checkerName": "clang-diagnostic-unused-parameter", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 28, "file": 34, "line": 47}, "message": "unused parameter 'note'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/x86/dl-prop.h", "reportHash": "b24359b94325415a029f92b428c76936", "checkerName": "clang-diagnostic-unused-parameter", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 34, "line": 48}, "message": "unused parameter 'size'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/x86/dl-prop.h", "reportHash": "b10ed823cd3f7bd90d503a16d857207e", "checkerName": "clang-diagnostic-unused-parameter", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 34, "line": 49}, "message": "unused parameter 'align'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/x86/dl-prop.h", "reportHash": "454b88791aa589ad87ec802fa601137f", "checkerName": "clang-diagnostic-unused-parameter", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 41, "file": 37, "line": 237}, "message": "unused parameter 'map'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/x86_64/dl-machine.h", "reportHash": "0610afe418c15dcb0f486f9430bcf22b", "checkerName": "clang-diagnostic-unused-parameter", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 55, "file": 37, "line": 237}, "message": "unused parameter 't'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/x86_64/dl-machine.h", "reportHash": "a57c5427aca42354f5d6088e60e185f4", "checkerName": "clang-diagnostic-unused-parameter", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 27, "file": 37, "line": 238}, "message": "unused parameter 'refsym'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/x86_64/dl-machine.h", "reportHash": "70760047bbce440eb713e35a061abc05", "checkerName": "clang-diagnostic-unused-parameter", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 52, "file": 37, "line": 238}, "message": "unused parameter 'sym'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/x86_64/dl-machine.h", "reportHash": "f6515ac11346d5616abb17dd1ea0ddbb", "checkerName": "clang-diagnostic-unused-parameter", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 28, "file": 37, "line": 239}, "message": "unused parameter 'reloc'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/x86_64/dl-machine.h", "reportHash": "24326f4ec4f957a54847f9dda6a906ec", "checkerName": "clang-diagnostic-unused-parameter", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 41, "file": 37, "line": 248}, "message": "unused parameter 'map'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/x86_64/dl-machine.h", "reportHash": "242d18640ab044d3464add24f11d1b90", "checkerName": "clang-diagnostic-unused-parameter", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 64, "file": 37, "line": 248}, "message": "unused parameter 'reloc'"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/x86_64/dl-machine.h", "reportHash": "25cfd273e3e53b55ff9c2102b4b0ae18", "checkerName": "clang-diagnostic-unused-parameter", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 1, "file": 37, "line": 271}, "message": "function definition is not allowed here"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/x86_64/dl-machine.h", "reportHash": "41376a8005cc441d6945849160436b17", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 1, "file": 37, "line": 528}, "message": "function definition is not allowed here"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/x86_64/dl-machine.h", "reportHash": "41376a8005cc441d6945849160436b17", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 1, "file": 37, "line": 548}, "message": "function definition is not allowed here"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/sysdeps/x86_64/dl-machine.h", "reportHash": "41376a8005cc441d6945849160436b17", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
