<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"1": {"id": 1, "path": "/media/lavo07/lavo07/glibc/malloc/hooks.c", "content": "/* Malloc implementation for multiple threads without lock contention.\n   Copyright (C) 2001-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n   Contributed by Wolfram Gloger <wg@malloc.de>, 2001.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public License as\n   published by the Free Software Foundation; either version 2.1 of the\n   License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; see the file COPYING.LIB.  If\n   not, see <http://www.gnu.org/licenses/>.  */\n\n/* What to do if the standard debugging hooks are in place and a\n   corrupt pointer is detected: do nothing (0), print an error message\n   (1), or call abort() (2). */\n\n/* Hooks for debugging versions.  The initial hooks just call the\n   initialization routine, then do the normal work. */\n\nstatic void *\nmalloc_hook_ini (size_t sz, const void *caller)\n{\n  __malloc_hook = NULL;\n  ptmalloc_init ();\n  return __libc_malloc (sz);\n}\n\nstatic void *\nrealloc_hook_ini (void *ptr, size_t sz, const void *caller)\n{\n  __malloc_hook = NULL;\n  __realloc_hook = NULL;\n  ptmalloc_init ();\n  return __libc_realloc (ptr, sz);\n}\n\nstatic void *\nmemalign_hook_ini (size_t alignment, size_t sz, const void *caller)\n{\n  __memalign_hook = NULL;\n  ptmalloc_init ();\n  return __libc_memalign (alignment, sz);\n}\n\n/* Whether we are using malloc checking.  */\nstatic int using_malloc_checking;\n\n/* Activate a standard set of debugging hooks. */\nvoid\n__malloc_check_init (void)\n{\n  using_malloc_checking = 1;\n  __malloc_hook = malloc_check;\n  __free_hook = free_check;\n  __realloc_hook = realloc_check;\n  __memalign_hook = memalign_check;\n}\n\n/* A simple, standard set of debugging hooks.  Overhead is `only' one\n   byte per chunk; still this will catch most cases of double frees or\n   overruns.  The goal here is to avoid obscure crashes due to invalid\n   usage, unlike in the MALLOC_DEBUG code. */\n\nstatic unsigned char\nmagicbyte (const void *p)\n{\n  unsigned char magic;\n\n  magic = (((uintptr_t) p >> 3) ^ ((uintptr_t) p >> 11)) & 0xFF;\n  /* Do not return 1.  See the comment in mem2mem_check().  */\n  if (magic == 1)\n    ++magic;\n  return magic;\n}\n\n\n/* Visualize the chunk as being partitioned into blocks of 255 bytes from the\n   highest address of the chunk, downwards.  The end of each block tells\n   us the size of that block, up to the actual size of the requested\n   memory.  Our magic byte is right at the end of the requested size, so we\n   must reach it with this iteration, otherwise we have witnessed a memory\n   corruption.  */\nstatic size_t\nmalloc_check_get_size (mchunkptr p)\n{\n  size_t size;\n  unsigned char c;\n  unsigned char magic = magicbyte (p);\n\n  assert (using_malloc_checking == 1);\n\n  for (size = chunksize (p) - 1 + (chunk_is_mmapped (p) ? 0 : SIZE_SZ);\n       (c = ((unsigned char *) p)[size]) != magic;\n       size -= c)\n    {\n      if (c <= 0 || size < (c + 2 * SIZE_SZ))\n\tmalloc_printerr (\"malloc_check_get_size: memory corruption\");\n    }\n\n  /* chunk2mem size.  */\n  return size - 2 * SIZE_SZ;\n}\n\n/* Instrument a chunk with overrun detector byte(s) and convert it\n   into a user pointer with requested size req_sz. */\n\nstatic void *\nmem2mem_check (void *ptr, size_t req_sz)\n{\n  mchunkptr p;\n  unsigned char *m_ptr = ptr;\n  size_t max_sz, block_sz, i;\n  unsigned char magic;\n\n  if (!ptr)\n    return ptr;\n\n  p = mem2chunk (ptr);\n  magic = magicbyte (p);\n  max_sz = chunksize (p) - 2 * SIZE_SZ;\n  if (!chunk_is_mmapped (p))\n    max_sz += SIZE_SZ;\n  for (i = max_sz - 1; i > req_sz; i -= block_sz)\n    {\n      block_sz = MIN (i - req_sz, 0xff);\n      /* Don't allow the magic byte to appear in the chain of length bytes.\n         For the following to work, magicbyte cannot return 0x01.  */\n      if (block_sz == magic)\n        --block_sz;\n\n      m_ptr[i] = block_sz;\n    }\n  m_ptr[req_sz] = magic;\n  return (void *) m_ptr;\n}\n\n/* Convert a pointer to be free()d or realloc()ed to a valid chunk\n   pointer.  If the provided pointer is not valid, return NULL. */\n\nstatic mchunkptr\nmem2chunk_check (void *mem, unsigned char **magic_p)\n{\n  mchunkptr p;\n  INTERNAL_SIZE_T sz, c;\n  unsigned char magic;\n\n  if (!aligned_OK (mem))\n    return NULL;\n\n  p = mem2chunk (mem);\n  sz = chunksize (p);\n  magic = magicbyte (p);\n  if (!chunk_is_mmapped (p))\n    {\n      /* Must be a chunk in conventional heap memory. */\n      int contig = contiguous (&main_arena);\n      if ((contig &&\n           ((char *) p < mp_.sbrk_base ||\n            ((char *) p + sz) >= (mp_.sbrk_base + main_arena.system_mem))) ||\n          sz < MINSIZE || sz & MALLOC_ALIGN_MASK || !inuse (p) ||\n          (!prev_inuse (p) && ((prev_size (p) & MALLOC_ALIGN_MASK) != 0 ||\n                               (contig && (char *) prev_chunk (p) < mp_.sbrk_base) ||\n                               next_chunk (prev_chunk (p)) != p)))\n        return NULL;\n\n      for (sz += SIZE_SZ - 1; (c = ((unsigned char *) p)[sz]) != magic; sz -= c)\n        {\n          if (c == 0 || sz < (c + 2 * SIZE_SZ))\n            return NULL;\n        }\n    }\n  else\n    {\n      unsigned long offset, page_mask = GLRO (dl_pagesize) - 1;\n\n      /* mmap()ed chunks have MALLOC_ALIGNMENT or higher power-of-two\n         alignment relative to the beginning of a page.  Check this\n         first. */\n      offset = (unsigned long) mem & page_mask;\n      if ((offset != MALLOC_ALIGNMENT && offset != 0 && offset != 0x10 &&\n           offset != 0x20 && offset != 0x40 && offset != 0x80 && offset != 0x100 &&\n           offset != 0x200 && offset != 0x400 && offset != 0x800 && offset != 0x1000 &&\n           offset < 0x2000) ||\n          !chunk_is_mmapped (p) || prev_inuse (p) ||\n          ((((unsigned long) p - prev_size (p)) & page_mask) != 0) ||\n          ((prev_size (p) + sz) & page_mask) != 0)\n        return NULL;\n\n      for (sz -= 1; (c = ((unsigned char *) p)[sz]) != magic; sz -= c)\n        {\n          if (c == 0 || sz < (c + 2 * SIZE_SZ))\n            return NULL;\n        }\n    }\n  ((unsigned char *) p)[sz] ^= 0xFF;\n  if (magic_p)\n    *magic_p = (unsigned char *) p + sz;\n  return p;\n}\n\n/* Check for corruption of the top chunk.  */\nstatic void\ntop_check (void)\n{\n  mchunkptr t = top (&main_arena);\n\n  if (t == initial_top (&main_arena) ||\n      (!chunk_is_mmapped (t) &&\n       chunksize (t) >= MINSIZE &&\n       prev_inuse (t) &&\n       (!contiguous (&main_arena) ||\n        (char *) t + chunksize (t) == mp_.sbrk_base + main_arena.system_mem)))\n    return;\n\n  malloc_printerr (\"malloc: top chunk is corrupt\");\n}\n\nstatic void *\nmalloc_check (size_t sz, const void *caller)\n{\n  void *victim;\n\n  if (sz + 1 == 0)\n    {\n      __set_errno (ENOMEM);\n      return NULL;\n    }\n\n  __libc_lock_lock (main_arena.mutex);\n  top_check ();\n  victim = _int_malloc (&main_arena, sz + 1);\n  __libc_lock_unlock (main_arena.mutex);\n  return mem2mem_check (victim, sz);\n}\n\nstatic void\nfree_check (void *mem, const void *caller)\n{\n  mchunkptr p;\n\n  if (!mem)\n    return;\n\n  __libc_lock_lock (main_arena.mutex);\n  p = mem2chunk_check (mem, NULL);\n  if (!p)\n    malloc_printerr (\"free(): invalid pointer\");\n  if (chunk_is_mmapped (p))\n    {\n      __libc_lock_unlock (main_arena.mutex);\n      munmap_chunk (p);\n      return;\n    }\n  _int_free (&main_arena, p, 1);\n  __libc_lock_unlock (main_arena.mutex);\n}\n\nstatic void *\nrealloc_check (void *oldmem, size_t bytes, const void *caller)\n{\n  INTERNAL_SIZE_T nb;\n  void *newmem = 0;\n  unsigned char *magic_p;\n\n  if (bytes + 1 == 0)\n    {\n      __set_errno (ENOMEM);\n      return NULL;\n    }\n  if (oldmem == 0)\n    return malloc_check (bytes, NULL);\n\n  if (bytes == 0)\n    {\n      free_check (oldmem, NULL);\n      return NULL;\n    }\n  __libc_lock_lock (main_arena.mutex);\n  const mchunkptr oldp = mem2chunk_check (oldmem, &magic_p);\n  __libc_lock_unlock (main_arena.mutex);\n  if (!oldp)\n    malloc_printerr (\"realloc(): invalid pointer\");\n  const INTERNAL_SIZE_T oldsize = chunksize (oldp);\n\n  checked_request2size (bytes + 1, nb);\n  __libc_lock_lock (main_arena.mutex);\n\n  if (chunk_is_mmapped (oldp))\n    {\n#if HAVE_MREMAP\n      mchunkptr newp = mremap_chunk (oldp, nb);\n      if (newp)\n        newmem = chunk2mem (newp);\n      else\n#endif\n      {\n        /* Note the extra SIZE_SZ overhead. */\n        if (oldsize - SIZE_SZ >= nb)\n          newmem = oldmem; /* do nothing */\n        else\n          {\n            /* Must alloc, copy, free. */\n\t    top_check ();\n\t    newmem = _int_malloc (&main_arena, bytes + 1);\n            if (newmem)\n              {\n                memcpy (newmem, oldmem, oldsize - 2 * SIZE_SZ);\n                munmap_chunk (oldp);\n              }\n          }\n      }\n    }\n  else\n    {\n      top_check ();\n      INTERNAL_SIZE_T nb;\n      checked_request2size (bytes + 1, nb);\n      newmem = _int_realloc (&main_arena, oldp, oldsize, nb);\n    }\n\n  DIAG_PUSH_NEEDS_COMMENT;\n#if __GNUC_PREREQ (7, 0)\n  /* GCC 7 warns about magic_p may be used uninitialized.  But we never\n     reach here if magic_p is uninitialized.  */\n  DIAG_IGNORE_NEEDS_COMMENT (7, \"-Wmaybe-uninitialized\");\n#endif\n  /* mem2chunk_check changed the magic byte in the old chunk.\n     If newmem is NULL, then the old chunk will still be used though,\n     so we need to invert that change here.  */\n  if (newmem == NULL)\n    *magic_p ^= 0xFF;\n  DIAG_POP_NEEDS_COMMENT;\n\n  __libc_lock_unlock (main_arena.mutex);\n\n  return mem2mem_check (newmem, bytes);\n}\n\nstatic void *\nmemalign_check (size_t alignment, size_t bytes, const void *caller)\n{\n  void *mem;\n\n  if (alignment <= MALLOC_ALIGNMENT)\n    return malloc_check (bytes, NULL);\n\n  if (alignment < MINSIZE)\n    alignment = MINSIZE;\n\n  /* If the alignment is greater than SIZE_MAX / 2 + 1 it cannot be a\n     power of 2 and will cause overflow in the check below.  */\n  if (alignment > SIZE_MAX / 2 + 1)\n    {\n      __set_errno (EINVAL);\n      return 0;\n    }\n\n  /* Check for overflow.  */\n  if (bytes > SIZE_MAX - alignment - MINSIZE)\n    {\n      __set_errno (ENOMEM);\n      return 0;\n    }\n\n  /* Make sure alignment is power of 2.  */\n  if (!powerof2 (alignment))\n    {\n      size_t a = MALLOC_ALIGNMENT * 2;\n      while (a < alignment)\n        a <<= 1;\n      alignment = a;\n    }\n\n  __libc_lock_lock (main_arena.mutex);\n  top_check ();\n  mem = _int_memalign (&main_arena, alignment, bytes + 1);\n  __libc_lock_unlock (main_arena.mutex);\n  return mem2mem_check (mem, bytes);\n}\n\n#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_25)\n\n/* Support for restoring dumped heaps contained in historic Emacs\n   executables.  The heap saving feature (malloc_get_state) is no\n   longer implemented in this version of glibc, but we have a heap\n   rewriter in malloc_set_state which transforms the heap into a\n   version compatible with current malloc.  */\n\n#define MALLOC_STATE_MAGIC   0x444c4541l\n#define MALLOC_STATE_VERSION (0 * 0x100l + 5l) /* major*0x100 + minor */\n\nstruct malloc_save_state\n{\n  long magic;\n  long version;\n  mbinptr av[NBINS * 2 + 2];\n  char *sbrk_base;\n  int sbrked_mem_bytes;\n  unsigned long trim_threshold;\n  unsigned long top_pad;\n  unsigned int n_mmaps_max;\n  unsigned long mmap_threshold;\n  int check_action;\n  unsigned long max_sbrked_mem;\n  unsigned long max_total_mem;\t/* Always 0, for backwards compatibility.  */\n  unsigned int n_mmaps;\n  unsigned int max_n_mmaps;\n  unsigned long mmapped_mem;\n  unsigned long max_mmapped_mem;\n  int using_malloc_checking;\n  unsigned long max_fast;\n  unsigned long arena_test;\n  unsigned long arena_max;\n  unsigned long narenas;\n};\n\n/* Dummy implementation which always fails.  We need to provide this\n   symbol so that existing Emacs binaries continue to work with\n   BIND_NOW.  */\nvoid *\nattribute_compat_text_section\nmalloc_get_state (void)\n{\n  __set_errno (ENOSYS);\n  return NULL;\n}\ncompat_symbol (libc, malloc_get_state, malloc_get_state, GLIBC_2_0);\n\nint\nattribute_compat_text_section\nmalloc_set_state (void *msptr)\n{\n  struct malloc_save_state *ms = (struct malloc_save_state *) msptr;\n\n  if (ms->magic != MALLOC_STATE_MAGIC)\n    return -1;\n\n  /* Must fail if the major version is too high. */\n  if ((ms->version & ~0xffl) > (MALLOC_STATE_VERSION & ~0xffl))\n    return -2;\n\n  /* We do not need to perform locking here because malloc_set_state\n     must be called before the first call into the malloc subsytem\n     (usually via __malloc_initialize_hook).  pthread_create always\n     calls calloc and thus must be called only afterwards, so there\n     cannot be more than one thread when we reach this point.  */\n\n  /* Disable the malloc hooks (and malloc checking).  */\n  __malloc_hook = NULL;\n  __realloc_hook = NULL;\n  __free_hook = NULL;\n  __memalign_hook = NULL;\n  using_malloc_checking = 0;\n\n  /* Patch the dumped heap.  We no longer try to integrate into the\n     existing heap.  Instead, we mark the existing chunks as mmapped.\n     Together with the update to dumped_main_arena_start and\n     dumped_main_arena_end, realloc and free will recognize these\n     chunks as dumped fake mmapped chunks and never free them.  */\n\n  /* Find the chunk with the lowest address with the heap.  */\n  mchunkptr chunk = NULL;\n  {\n    size_t *candidate = (size_t *) ms->sbrk_base;\n    size_t *end = (size_t *) (ms->sbrk_base + ms->sbrked_mem_bytes);\n    while (candidate < end)\n      if (*candidate != 0)\n\t{\n\t  chunk = mem2chunk ((void *) (candidate + 1));\n\t  break;\n\t}\n      else\n\t++candidate;\n  }\n  if (chunk == NULL)\n    return 0;\n\n  /* Iterate over the dumped heap and patch the chunks so that they\n     are treated as fake mmapped chunks.  */\n  mchunkptr top = ms->av[2];\n  while (chunk < top)\n    {\n      if (inuse (chunk))\n\t{\n\t  /* Mark chunk as mmapped, to trigger the fallback path.  */\n\t  size_t size = chunksize (chunk);\n\t  set_head (chunk, size | IS_MMAPPED);\n\t}\n      chunk = next_chunk (chunk);\n    }\n\n  /* The dumped fake mmapped chunks all lie in this address range.  */\n  dumped_main_arena_start = (mchunkptr) ms->sbrk_base;\n  dumped_main_arena_end = top;\n\n  return 0;\n}\ncompat_symbol (libc, malloc_set_state, malloc_set_state, GLIBC_2_0);\n\n#endif\t/* SHLIB_COMPAT */\n\n/*\n * Local variables:\n * c-basic-offset: 2\n * End:\n */\n"}, "2": {"id": 2, "path": "/media/lavo07/lavo07/glibc/malloc/malloc.c", "content": "/* Malloc implementation for multiple threads without lock contention.\n   Copyright (C) 1996-2018 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n   Contributed by Wolfram Gloger <wg@malloc.de>\n   and Doug Lea <dl@cs.oswego.edu>, 2001.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public License as\n   published by the Free Software Foundation; either version 2.1 of the\n   License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; see the file COPYING.LIB.  If\n   not, see <http://www.gnu.org/licenses/>.  */\n\n/*\n  This is a version (aka ptmalloc2) of malloc/free/realloc written by\n  Doug Lea and adapted to multiple threads/arenas by Wolfram Gloger.\n\n  There have been substantial changes made after the integration into\n  glibc in all parts of the code.  Do not look for much commonality\n  with the ptmalloc2 version.\n\n* Version ptmalloc2-20011215\n  based on:\n  VERSION 2.7.0 Sun Mar 11 14:14:06 2001  Doug Lea  (dl at gee)\n\n* Quickstart\n\n  In order to compile this implementation, a Makefile is provided with\n  the ptmalloc2 distribution, which has pre-defined targets for some\n  popular systems (e.g. \"make posix\" for Posix threads).  All that is\n  typically required with regard to compiler flags is the selection of\n  the thread package via defining one out of USE_PTHREADS, USE_THR or\n  USE_SPROC.  Check the thread-m.h file for what effects this has.\n  Many/most systems will additionally require USE_TSD_DATA_HACK to be\n  defined, so this is the default for \"make posix\".\n\n* Why use this malloc?\n\n  This is not the fastest, most space-conserving, most portable, or\n  most tunable malloc ever written. However it is among the fastest\n  while also being among the most space-conserving, portable and tunable.\n  Consistent balance across these factors results in a good general-purpose\n  allocator for malloc-intensive programs.\n\n  The main properties of the algorithms are:\n  * For large (>= 512 bytes) requests, it is a pure best-fit allocator,\n    with ties normally decided via FIFO (i.e. least recently used).\n  * For small (<= 64 bytes by default) requests, it is a caching\n    allocator, that maintains pools of quickly recycled chunks.\n  * In between, and for combinations of large and small requests, it does\n    the best it can trying to meet both goals at once.\n  * For very large requests (>= 128KB by default), it relies on system\n    memory mapping facilities, if supported.\n\n  For a longer but slightly out of date high-level description, see\n     http://gee.cs.oswego.edu/dl/html/malloc.html\n\n  You may already by default be using a C library containing a malloc\n  that is  based on some version of this malloc (for example in\n  linux). You might still want to use the one in this file in order to\n  customize settings or to avoid overheads associated with library\n  versions.\n\n* Contents, described in more detail in \"description of public routines\" below.\n\n  Standard (ANSI/SVID/...)  functions:\n    malloc(size_t n);\n    calloc(size_t n_elements, size_t element_size);\n    free(void* p);\n    realloc(void* p, size_t n);\n    memalign(size_t alignment, size_t n);\n    valloc(size_t n);\n    mallinfo()\n    mallopt(int parameter_number, int parameter_value)\n\n  Additional functions:\n    independent_calloc(size_t n_elements, size_t size, void* chunks[]);\n    independent_comalloc(size_t n_elements, size_t sizes[], void* chunks[]);\n    pvalloc(size_t n);\n    malloc_trim(size_t pad);\n    malloc_usable_size(void* p);\n    malloc_stats();\n\n* Vital statistics:\n\n  Supported pointer representation:       4 or 8 bytes\n  Supported size_t  representation:       4 or 8 bytes\n       Note that size_t is allowed to be 4 bytes even if pointers are 8.\n       You can adjust this by defining INTERNAL_SIZE_T\n\n  Alignment:                              2 * sizeof(size_t) (default)\n       (i.e., 8 byte alignment with 4byte size_t). This suffices for\n       nearly all current machines and C compilers. However, you can\n       define MALLOC_ALIGNMENT to be wider than this if necessary.\n\n  Minimum overhead per allocated chunk:   4 or 8 bytes\n       Each malloced chunk has a hidden word of overhead holding size\n       and status information.\n\n  Minimum allocated size: 4-byte ptrs:  16 bytes    (including 4 overhead)\n\t\t\t  8-byte ptrs:  24/32 bytes (including, 4/8 overhead)\n\n       When a chunk is freed, 12 (for 4byte ptrs) or 20 (for 8 byte\n       ptrs but 4 byte size) or 24 (for 8/8) additional bytes are\n       needed; 4 (8) for a trailing size field and 8 (16) bytes for\n       free list pointers. Thus, the minimum allocatable size is\n       16/24/32 bytes.\n\n       Even a request for zero bytes (i.e., malloc(0)) returns a\n       pointer to something of the minimum allocatable size.\n\n       The maximum overhead wastage (i.e., number of extra bytes\n       allocated than were requested in malloc) is less than or equal\n       to the minimum size, except for requests >= mmap_threshold that\n       are serviced via mmap(), where the worst case wastage is 2 *\n       sizeof(size_t) bytes plus the remainder from a system page (the\n       minimal mmap unit); typically 4096 or 8192 bytes.\n\n  Maximum allocated size:  4-byte size_t: 2^32 minus about two pages\n\t\t\t   8-byte size_t: 2^64 minus about two pages\n\n       It is assumed that (possibly signed) size_t values suffice to\n       represent chunk sizes. `Possibly signed' is due to the fact\n       that `size_t' may be defined on a system as either a signed or\n       an unsigned type. The ISO C standard says that it must be\n       unsigned, but a few systems are known not to adhere to this.\n       Additionally, even when size_t is unsigned, sbrk (which is by\n       default used to obtain memory from system) accepts signed\n       arguments, and may not be able to handle size_t-wide arguments\n       with negative sign bit.  Generally, values that would\n       appear as negative after accounting for overhead and alignment\n       are supported only via mmap(), which does not have this\n       limitation.\n\n       Requests for sizes outside the allowed range will perform an optional\n       failure action and then return null. (Requests may also\n       also fail because a system is out of memory.)\n\n  Thread-safety: thread-safe\n\n  Compliance: I believe it is compliant with the 1997 Single Unix Specification\n       Also SVID/XPG, ANSI C, and probably others as well.\n\n* Synopsis of compile-time options:\n\n    People have reported using previous versions of this malloc on all\n    versions of Unix, sometimes by tweaking some of the defines\n    below. It has been tested most extensively on Solaris and Linux.\n    People also report using it in stand-alone embedded systems.\n\n    The implementation is in straight, hand-tuned ANSI C.  It is not\n    at all modular. (Sorry!)  It uses a lot of macros.  To be at all\n    usable, this code should be compiled using an optimizing compiler\n    (for example gcc -O3) that can simplify expressions and control\n    paths. (FAQ: some macros import variables as arguments rather than\n    declare locals because people reported that some debuggers\n    otherwise get confused.)\n\n    OPTION                     DEFAULT VALUE\n\n    Compilation Environment options:\n\n    HAVE_MREMAP                0\n\n    Changing default word sizes:\n\n    INTERNAL_SIZE_T            size_t\n\n    Configuration and functionality options:\n\n    USE_PUBLIC_MALLOC_WRAPPERS NOT defined\n    USE_MALLOC_LOCK            NOT defined\n    MALLOC_DEBUG               NOT defined\n    REALLOC_ZERO_BYTES_FREES   1\n    TRIM_FASTBINS              0\n\n    Options for customizing MORECORE:\n\n    MORECORE                   sbrk\n    MORECORE_FAILURE           -1\n    MORECORE_CONTIGUOUS        1\n    MORECORE_CANNOT_TRIM       NOT defined\n    MORECORE_CLEARS            1\n    MMAP_AS_MORECORE_SIZE      (1024 * 1024)\n\n    Tuning options that are also dynamically changeable via mallopt:\n\n    DEFAULT_MXFAST             64 (for 32bit), 128 (for 64bit)\n    DEFAULT_TRIM_THRESHOLD     128 * 1024\n    DEFAULT_TOP_PAD            0\n    DEFAULT_MMAP_THRESHOLD     128 * 1024\n    DEFAULT_MMAP_MAX           65536\n\n    There are several other #defined constants and macros that you\n    probably don't want to touch unless you are extending or adapting malloc.  */\n\n/*\n  void* is the pointer type that malloc should say it returns\n*/\n\n#ifndef void\n#define void      void\n#endif /*void*/\n\n#include <stddef.h>   /* for size_t */\n#include <stdlib.h>   /* for getenv(), abort() */\n#include <unistd.h>   /* for __libc_enable_secure */\n\n#include <atomic.h>\n#include <_itoa.h>\n#include <bits/wordsize.h>\n#include <sys/sysinfo.h>\n\n#include <ldsodefs.h>\n\n#include <unistd.h>\n#include <stdio.h>    /* needed for malloc_stats */\n#include <errno.h>\n#include <assert.h>\n\n#include <shlib-compat.h>\n\n/* For uintptr_t.  */\n#include <stdint.h>\n\n/* For va_arg, va_start, va_end.  */\n#include <stdarg.h>\n\n/* For MIN, MAX, powerof2.  */\n#include <sys/param.h>\n\n/* For ALIGN_UP et. al.  */\n#include <libc-pointer-arith.h>\n\n/* For DIAG_PUSH/POP_NEEDS_COMMENT et al.  */\n#include <libc-diag.h>\n\n#include <malloc/malloc-internal.h>\n\n/* For SINGLE_THREAD_P.  */\n#include <sysdep-cancel.h>\n\n/*\n  Debugging:\n\n  Because freed chunks may be overwritten with bookkeeping fields, this\n  malloc will often die when freed memory is overwritten by user\n  programs.  This can be very effective (albeit in an annoying way)\n  in helping track down dangling pointers.\n\n  If you compile with -DMALLOC_DEBUG, a number of assertion checks are\n  enabled that will catch more memory errors. You probably won't be\n  able to make much sense of the actual assertion errors, but they\n  should help you locate incorrectly overwritten memory.  The checking\n  is fairly extensive, and will slow down execution\n  noticeably. Calling malloc_stats or mallinfo with MALLOC_DEBUG set\n  will attempt to check every non-mmapped allocated and free chunk in\n  the course of computing the summmaries. (By nature, mmapped regions\n  cannot be checked very much automatically.)\n\n  Setting MALLOC_DEBUG may also be helpful if you are trying to modify\n  this code. The assertions in the check routines spell out in more\n  detail the assumptions and invariants underlying the algorithms.\n\n  Setting MALLOC_DEBUG does NOT provide an automated mechanism for\n  checking that all accesses to malloced memory stay within their\n  bounds. However, there are several add-ons and adaptations of this\n  or other mallocs available that do this.\n*/\n\n#ifndef MALLOC_DEBUG\n#define MALLOC_DEBUG 0\n#endif\n\n#ifndef NDEBUG\n# define __assert_fail(assertion, file, line, function)\t\t\t\\\n\t __malloc_assert(assertion, file, line, function)\n\nextern const char *__progname;\n\nstatic void\n__malloc_assert (const char *assertion, const char *file, unsigned int line,\n\t\t const char *function)\n{\n  (void) __fxprintf (NULL, \"%s%s%s:%u: %s%sAssertion `%s' failed.\\n\",\n\t\t     __progname, __progname[0] ? \": \" : \"\",\n\t\t     file, line,\n\t\t     function ? function : \"\", function ? \": \" : \"\",\n\t\t     assertion);\n  fflush (stderr);\n  abort ();\n}\n#endif\n\n#if USE_TCACHE\n/* We want 64 entries.  This is an arbitrary limit, which tunables can reduce.  */\n# define TCACHE_MAX_BINS\t\t64\n# define MAX_TCACHE_SIZE\ttidx2usize (TCACHE_MAX_BINS-1)\n\n/* Only used to pre-fill the tunables.  */\n# define tidx2usize(idx)\t(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)\n\n/* When \"x\" is from chunksize().  */\n# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)\n/* When \"x\" is a user-provided size.  */\n# define usize2tidx(x) csize2tidx (request2size (x))\n\n/* With rounding and alignment, the bins are...\n   idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)\n   idx 1   bytes 25..40 or 13..20\n   idx 2   bytes 41..56 or 21..28\n   etc.  */\n\n/* This is another arbitrary limit, which tunables can change.  Each\n   tcache bin will hold at most this number of chunks.  */\n# define TCACHE_FILL_COUNT 7\n#endif\n\n\n/*\n  REALLOC_ZERO_BYTES_FREES should be set if a call to\n  realloc with zero bytes should be the same as a call to free.\n  This is required by the C standard. Otherwise, since this malloc\n  returns a unique pointer for malloc(0), so does realloc(p, 0).\n*/\n\n#ifndef REALLOC_ZERO_BYTES_FREES\n#define REALLOC_ZERO_BYTES_FREES 1\n#endif\n\n/*\n  TRIM_FASTBINS controls whether free() of a very small chunk can\n  immediately lead to trimming. Setting to true (1) can reduce memory\n  footprint, but will almost always slow down programs that use a lot\n  of small chunks.\n\n  Define this only if you are willing to give up some speed to more\n  aggressively reduce system-level memory footprint when releasing\n  memory in programs that use many small chunks.  You can get\n  essentially the same effect by setting MXFAST to 0, but this can\n  lead to even greater slowdowns in programs using many small chunks.\n  TRIM_FASTBINS is an in-between compile-time option, that disables\n  only those chunks bordering topmost memory from being placed in\n  fastbins.\n*/\n\n#ifndef TRIM_FASTBINS\n#define TRIM_FASTBINS  0\n#endif\n\n\n/* Definition for getting more memory from the OS.  */\n#define MORECORE         (*__morecore)\n#define MORECORE_FAILURE 0\nvoid * __default_morecore (ptrdiff_t);\nvoid *(*__morecore)(ptrdiff_t) = __default_morecore;\n\n\n#include <string.h>\n\n/*\n  MORECORE-related declarations. By default, rely on sbrk\n*/\n\n\n/*\n  MORECORE is the name of the routine to call to obtain more memory\n  from the system.  See below for general guidance on writing\n  alternative MORECORE functions, as well as a version for WIN32 and a\n  sample version for pre-OSX macos.\n*/\n\n#ifndef MORECORE\n#define MORECORE sbrk\n#endif\n\n/*\n  MORECORE_FAILURE is the value returned upon failure of MORECORE\n  as well as mmap. Since it cannot be an otherwise valid memory address,\n  and must reflect values of standard sys calls, you probably ought not\n  try to redefine it.\n*/\n\n#ifndef MORECORE_FAILURE\n#define MORECORE_FAILURE (-1)\n#endif\n\n/*\n  If MORECORE_CONTIGUOUS is true, take advantage of fact that\n  consecutive calls to MORECORE with positive arguments always return\n  contiguous increasing addresses.  This is true of unix sbrk.  Even\n  if not defined, when regions happen to be contiguous, malloc will\n  permit allocations spanning regions obtained from different\n  calls. But defining this when applicable enables some stronger\n  consistency checks and space efficiencies.\n*/\n\n#ifndef MORECORE_CONTIGUOUS\n#define MORECORE_CONTIGUOUS 1\n#endif\n\n/*\n  Define MORECORE_CANNOT_TRIM if your version of MORECORE\n  cannot release space back to the system when given negative\n  arguments. This is generally necessary only if you are using\n  a hand-crafted MORECORE function that cannot handle negative arguments.\n*/\n\n/* #define MORECORE_CANNOT_TRIM */\n\n/*  MORECORE_CLEARS           (default 1)\n     The degree to which the routine mapped to MORECORE zeroes out\n     memory: never (0), only for newly allocated space (1) or always\n     (2).  The distinction between (1) and (2) is necessary because on\n     some systems, if the application first decrements and then\n     increments the break value, the contents of the reallocated space\n     are unspecified.\n */\n\n#ifndef MORECORE_CLEARS\n# define MORECORE_CLEARS 1\n#endif\n\n\n/*\n   MMAP_AS_MORECORE_SIZE is the minimum mmap size argument to use if\n   sbrk fails, and mmap is used as a backup.  The value must be a\n   multiple of page size.  This backup strategy generally applies only\n   when systems have \"holes\" in address space, so sbrk cannot perform\n   contiguous expansion, but there is still space available on system.\n   On systems for which this is known to be useful (i.e. most linux\n   kernels), this occurs only when programs allocate huge amounts of\n   memory.  Between this, and the fact that mmap regions tend to be\n   limited, the size should be large, to avoid too many mmap calls and\n   thus avoid running out of kernel resources.  */\n\n#ifndef MMAP_AS_MORECORE_SIZE\n#define MMAP_AS_MORECORE_SIZE (1024 * 1024)\n#endif\n\n/*\n  Define HAVE_MREMAP to make realloc() use mremap() to re-allocate\n  large blocks.\n*/\n\n#ifndef HAVE_MREMAP\n#define HAVE_MREMAP 0\n#endif\n\n/* We may need to support __malloc_initialize_hook for backwards\n   compatibility.  */\n\n#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_24)\n# define HAVE_MALLOC_INIT_HOOK 1\n#else\n# define HAVE_MALLOC_INIT_HOOK 0\n#endif\n\n\n/*\n  This version of malloc supports the standard SVID/XPG mallinfo\n  routine that returns a struct containing usage properties and\n  statistics. It should work on any SVID/XPG compliant system that has\n  a /usr/include/malloc.h defining struct mallinfo. (If you'd like to\n  install such a thing yourself, cut out the preliminary declarations\n  as described above and below and save them in a malloc.h file. But\n  there's no compelling reason to bother to do this.)\n\n  The main declaration needed is the mallinfo struct that is returned\n  (by-copy) by mallinfo().  The SVID/XPG malloinfo struct contains a\n  bunch of fields that are not even meaningful in this version of\n  malloc.  These fields are are instead filled by mallinfo() with\n  other numbers that might be of interest.\n*/\n\n\n/* ---------- description of public routines ------------ */\n\n/*\n  malloc(size_t n)\n  Returns a pointer to a newly allocated chunk of at least n bytes, or null\n  if no space is available. Additionally, on failure, errno is\n  set to ENOMEM on ANSI C systems.\n\n  If n is zero, malloc returns a minumum-sized chunk. (The minimum\n  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit\n  systems.)  On most systems, size_t is an unsigned type, so calls\n  with negative arguments are interpreted as requests for huge amounts\n  of space, which will often fail. The maximum supported value of n\n  differs across systems, but is in all cases less than the maximum\n  representable value of a size_t.\n*/\nvoid*  __libc_malloc(size_t);\nlibc_hidden_proto (__libc_malloc)\n\n/*\n  free(void* p)\n  Releases the chunk of memory pointed to by p, that had been previously\n  allocated using malloc or a related routine such as realloc.\n  It has no effect if p is null. It can have arbitrary (i.e., bad!)\n  effects if p has already been freed.\n\n  Unless disabled (using mallopt), freeing very large spaces will\n  when possible, automatically trigger operations that give\n  back unused memory to the system, thus reducing program footprint.\n*/\nvoid     __libc_free(void*);\nlibc_hidden_proto (__libc_free)\n\n/*\n  calloc(size_t n_elements, size_t element_size);\n  Returns a pointer to n_elements * element_size bytes, with all locations\n  set to zero.\n*/\nvoid*  __libc_calloc(size_t, size_t);\n\n/*\n  realloc(void* p, size_t n)\n  Returns a pointer to a chunk of size n that contains the same data\n  as does chunk p up to the minimum of (n, p's size) bytes, or null\n  if no space is available.\n\n  The returned pointer may or may not be the same as p. The algorithm\n  prefers extending p when possible, otherwise it employs the\n  equivalent of a malloc-copy-free sequence.\n\n  If p is null, realloc is equivalent to malloc.\n\n  If space is not available, realloc returns null, errno is set (if on\n  ANSI) and p is NOT freed.\n\n  if n is for fewer bytes than already held by p, the newly unused\n  space is lopped off and freed if possible.  Unless the #define\n  REALLOC_ZERO_BYTES_FREES is set, realloc with a size argument of\n  zero (re)allocates a minimum-sized chunk.\n\n  Large chunks that were internally obtained via mmap will always be\n  grown using malloc-copy-free sequences unless the system supports\n  MREMAP (currently only linux).\n\n  The old unix realloc convention of allowing the last-free'd chunk\n  to be used as an argument to realloc is not supported.\n*/\nvoid*  __libc_realloc(void*, size_t);\nlibc_hidden_proto (__libc_realloc)\n\n/*\n  memalign(size_t alignment, size_t n);\n  Returns a pointer to a newly allocated chunk of n bytes, aligned\n  in accord with the alignment argument.\n\n  The alignment argument should be a power of two. If the argument is\n  not a power of two, the nearest greater power is used.\n  8-byte alignment is guaranteed by normal malloc calls, so don't\n  bother calling memalign with an argument of 8 or less.\n\n  Overreliance on memalign is a sure way to fragment space.\n*/\nvoid*  __libc_memalign(size_t, size_t);\nlibc_hidden_proto (__libc_memalign)\n\n/*\n  valloc(size_t n);\n  Equivalent to memalign(pagesize, n), where pagesize is the page\n  size of the system. If the pagesize is unknown, 4096 is used.\n*/\nvoid*  __libc_valloc(size_t);\n\n\n\n/*\n  mallopt(int parameter_number, int parameter_value)\n  Sets tunable parameters The format is to provide a\n  (parameter-number, parameter-value) pair.  mallopt then sets the\n  corresponding parameter to the argument value if it can (i.e., so\n  long as the value is meaningful), and returns 1 if successful else\n  0.  SVID/XPG/ANSI defines four standard param numbers for mallopt,\n  normally defined in malloc.h.  Only one of these (M_MXFAST) is used\n  in this malloc. The others (M_NLBLKS, M_GRAIN, M_KEEP) don't apply,\n  so setting them has no effect. But this malloc also supports four\n  other options in mallopt. See below for details.  Briefly, supported\n  parameters are as follows (listed defaults are for \"typical\"\n  configurations).\n\n  Symbol            param #   default    allowed param values\n  M_MXFAST          1         64         0-80  (0 disables fastbins)\n  M_TRIM_THRESHOLD -1         128*1024   any   (-1U disables trimming)\n  M_TOP_PAD        -2         0          any\n  M_MMAP_THRESHOLD -3         128*1024   any   (or 0 if no MMAP support)\n  M_MMAP_MAX       -4         65536      any   (0 disables use of mmap)\n*/\nint      __libc_mallopt(int, int);\nlibc_hidden_proto (__libc_mallopt)\n\n\n/*\n  mallinfo()\n  Returns (by copy) a struct containing various summary statistics:\n\n  arena:     current total non-mmapped bytes allocated from system\n  ordblks:   the number of free chunks\n  smblks:    the number of fastbin blocks (i.e., small chunks that\n\t       have been freed but not use resused or consolidated)\n  hblks:     current number of mmapped regions\n  hblkhd:    total bytes held in mmapped regions\n  usmblks:   always 0\n  fsmblks:   total bytes held in fastbin blocks\n  uordblks:  current total allocated space (normal or mmapped)\n  fordblks:  total free space\n  keepcost:  the maximum number of bytes that could ideally be released\n\t       back to system via malloc_trim. (\"ideally\" means that\n\t       it ignores page restrictions etc.)\n\n  Because these fields are ints, but internal bookkeeping may\n  be kept as longs, the reported values may wrap around zero and\n  thus be inaccurate.\n*/\nstruct mallinfo __libc_mallinfo(void);\n\n\n/*\n  pvalloc(size_t n);\n  Equivalent to valloc(minimum-page-that-holds(n)), that is,\n  round up n to nearest pagesize.\n */\nvoid*  __libc_pvalloc(size_t);\n\n/*\n  malloc_trim(size_t pad);\n\n  If possible, gives memory back to the system (via negative\n  arguments to sbrk) if there is unused memory at the `high' end of\n  the malloc pool. You can call this after freeing large blocks of\n  memory to potentially reduce the system-level memory requirements\n  of a program. However, it cannot guarantee to reduce memory. Under\n  some allocation patterns, some large free blocks of memory will be\n  locked between two used chunks, so they cannot be given back to\n  the system.\n\n  The `pad' argument to malloc_trim represents the amount of free\n  trailing space to leave untrimmed. If this argument is zero,\n  only the minimum amount of memory to maintain internal data\n  structures will be left (one page or less). Non-zero arguments\n  can be supplied to maintain enough trailing space to service\n  future expected allocations without having to re-obtain memory\n  from the system.\n\n  Malloc_trim returns 1 if it actually released any memory, else 0.\n  On systems that do not support \"negative sbrks\", it will always\n  return 0.\n*/\nint      __malloc_trim(size_t);\n\n/*\n  malloc_usable_size(void* p);\n\n  Returns the number of bytes you can actually use in\n  an allocated chunk, which may be more than you requested (although\n  often not) due to alignment and minimum size constraints.\n  You can use this many bytes without worrying about\n  overwriting other allocated objects. This is not a particularly great\n  programming practice. malloc_usable_size can be more useful in\n  debugging and assertions, for example:\n\n  p = malloc(n);\n  assert(malloc_usable_size(p) >= 256);\n\n*/\nsize_t   __malloc_usable_size(void*);\n\n/*\n  malloc_stats();\n  Prints on stderr the amount of space obtained from the system (both\n  via sbrk and mmap), the maximum amount (which may be more than\n  current if malloc_trim and/or munmap got called), and the current\n  number of bytes allocated via malloc (or realloc, etc) but not yet\n  freed. Note that this is the number of bytes allocated, not the\n  number requested. It will be larger than the number requested\n  because of alignment and bookkeeping overhead. Because it includes\n  alignment wastage as being in use, this figure may be greater than\n  zero even when no user-level chunks are allocated.\n\n  The reported current and maximum system memory can be inaccurate if\n  a program makes other calls to system memory allocation functions\n  (normally sbrk) outside of malloc.\n\n  malloc_stats prints only the most commonly interesting statistics.\n  More information can be obtained by calling mallinfo.\n\n*/\nvoid     __malloc_stats(void);\n\n/*\n  posix_memalign(void **memptr, size_t alignment, size_t size);\n\n  POSIX wrapper like memalign(), checking for validity of size.\n*/\nint      __posix_memalign(void **, size_t, size_t);\n\n/* mallopt tuning options */\n\n/*\n  M_MXFAST is the maximum request size used for \"fastbins\", special bins\n  that hold returned chunks without consolidating their spaces. This\n  enables future requests for chunks of the same size to be handled\n  very quickly, but can increase fragmentation, and thus increase the\n  overall memory footprint of a program.\n\n  This malloc manages fastbins very conservatively yet still\n  efficiently, so fragmentation is rarely a problem for values less\n  than or equal to the default.  The maximum supported value of MXFAST\n  is 80. You wouldn't want it any higher than this anyway.  Fastbins\n  are designed especially for use with many small structs, objects or\n  strings -- the default handles structs/objects/arrays with sizes up\n  to 8 4byte fields, or small strings representing words, tokens,\n  etc. Using fastbins for larger objects normally worsens\n  fragmentation without improving speed.\n\n  M_MXFAST is set in REQUEST size units. It is internally used in\n  chunksize units, which adds padding and alignment.  You can reduce\n  M_MXFAST to 0 to disable all use of fastbins.  This causes the malloc\n  algorithm to be a closer approximation of fifo-best-fit in all cases,\n  not just for larger requests, but will generally cause it to be\n  slower.\n*/\n\n\n/* M_MXFAST is a standard SVID/XPG tuning option, usually listed in malloc.h */\n#ifndef M_MXFAST\n#define M_MXFAST            1\n#endif\n\n#ifndef DEFAULT_MXFAST\n#define DEFAULT_MXFAST     (64 * SIZE_SZ / 4)\n#endif\n\n\n/*\n  M_TRIM_THRESHOLD is the maximum amount of unused top-most memory\n  to keep before releasing via malloc_trim in free().\n\n  Automatic trimming is mainly useful in long-lived programs.\n  Because trimming via sbrk can be slow on some systems, and can\n  sometimes be wasteful (in cases where programs immediately\n  afterward allocate more large chunks) the value should be high\n  enough so that your overall system performance would improve by\n  releasing this much memory.\n\n  The trim threshold and the mmap control parameters (see below)\n  can be traded off with one another. Trimming and mmapping are\n  two different ways of releasing unused memory back to the\n  system. Between these two, it is often possible to keep\n  system-level demands of a long-lived program down to a bare\n  minimum. For example, in one test suite of sessions measuring\n  the XF86 X server on Linux, using a trim threshold of 128K and a\n  mmap threshold of 192K led to near-minimal long term resource\n  consumption.\n\n  If you are using this malloc in a long-lived program, it should\n  pay to experiment with these values.  As a rough guide, you\n  might set to a value close to the average size of a process\n  (program) running on your system.  Releasing this much memory\n  would allow such a process to run in memory.  Generally, it's\n  worth it to tune for trimming rather tham memory mapping when a\n  program undergoes phases where several large chunks are\n  allocated and released in ways that can reuse each other's\n  storage, perhaps mixed with phases where there are no such\n  chunks at all.  And in well-behaved long-lived programs,\n  controlling release of large blocks via trimming versus mapping\n  is usually faster.\n\n  However, in most programs, these parameters serve mainly as\n  protection against the system-level effects of carrying around\n  massive amounts of unneeded memory. Since frequent calls to\n  sbrk, mmap, and munmap otherwise degrade performance, the default\n  parameters are set to relatively high values that serve only as\n  safeguards.\n\n  The trim value It must be greater than page size to have any useful\n  effect.  To disable trimming completely, you can set to\n  (unsigned long)(-1)\n\n  Trim settings interact with fastbin (MXFAST) settings: Unless\n  TRIM_FASTBINS is defined, automatic trimming never takes place upon\n  freeing a chunk with size less than or equal to MXFAST. Trimming is\n  instead delayed until subsequent freeing of larger chunks. However,\n  you can still force an attempted trim by calling malloc_trim.\n\n  Also, trimming is not generally possible in cases where\n  the main arena is obtained via mmap.\n\n  Note that the trick some people use of mallocing a huge space and\n  then freeing it at program startup, in an attempt to reserve system\n  memory, doesn't have the intended effect under automatic trimming,\n  since that memory will immediately be returned to the system.\n*/\n\n#define M_TRIM_THRESHOLD       -1\n\n#ifndef DEFAULT_TRIM_THRESHOLD\n#define DEFAULT_TRIM_THRESHOLD (128 * 1024)\n#endif\n\n/*\n  M_TOP_PAD is the amount of extra `padding' space to allocate or\n  retain whenever sbrk is called. It is used in two ways internally:\n\n  * When sbrk is called to extend the top of the arena to satisfy\n  a new malloc request, this much padding is added to the sbrk\n  request.\n\n  * When malloc_trim is called automatically from free(),\n  it is used as the `pad' argument.\n\n  In both cases, the actual amount of padding is rounded\n  so that the end of the arena is always a system page boundary.\n\n  The main reason for using padding is to avoid calling sbrk so\n  often. Having even a small pad greatly reduces the likelihood\n  that nearly every malloc request during program start-up (or\n  after trimming) will invoke sbrk, which needlessly wastes\n  time.\n\n  Automatic rounding-up to page-size units is normally sufficient\n  to avoid measurable overhead, so the default is 0.  However, in\n  systems where sbrk is relatively slow, it can pay to increase\n  this value, at the expense of carrying around more memory than\n  the program needs.\n*/\n\n#define M_TOP_PAD              -2\n\n#ifndef DEFAULT_TOP_PAD\n#define DEFAULT_TOP_PAD        (0)\n#endif\n\n/*\n  MMAP_THRESHOLD_MAX and _MIN are the bounds on the dynamically\n  adjusted MMAP_THRESHOLD.\n*/\n\n#ifndef DEFAULT_MMAP_THRESHOLD_MIN\n#define DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)\n#endif\n\n#ifndef DEFAULT_MMAP_THRESHOLD_MAX\n  /* For 32-bit platforms we cannot increase the maximum mmap\n     threshold much because it is also the minimum value for the\n     maximum heap size and its alignment.  Going above 512k (i.e., 1M\n     for new heaps) wastes too much address space.  */\n# if __WORDSIZE == 32\n#  define DEFAULT_MMAP_THRESHOLD_MAX (512 * 1024)\n# else\n#  define DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long))\n# endif\n#endif\n\n/*\n  M_MMAP_THRESHOLD is the request size threshold for using mmap()\n  to service a request. Requests of at least this size that cannot\n  be allocated using already-existing space will be serviced via mmap.\n  (If enough normal freed space already exists it is used instead.)\n\n  Using mmap segregates relatively large chunks of memory so that\n  they can be individually obtained and released from the host\n  system. A request serviced through mmap is never reused by any\n  other request (at least not directly; the system may just so\n  happen to remap successive requests to the same locations).\n\n  Segregating space in this way has the benefits that:\n\n   1. Mmapped space can ALWAYS be individually released back\n      to the system, which helps keep the system level memory\n      demands of a long-lived program low.\n   2. Mapped memory can never become `locked' between\n      other chunks, as can happen with normally allocated chunks, which\n      means that even trimming via malloc_trim would not release them.\n   3. On some systems with \"holes\" in address spaces, mmap can obtain\n      memory that sbrk cannot.\n\n  However, it has the disadvantages that:\n\n   1. The space cannot be reclaimed, consolidated, and then\n      used to service later requests, as happens with normal chunks.\n   2. It can lead to more wastage because of mmap page alignment\n      requirements\n   3. It causes malloc performance to be more dependent on host\n      system memory management support routines which may vary in\n      implementation quality and may impose arbitrary\n      limitations. Generally, servicing a request via normal\n      malloc steps is faster than going through a system's mmap.\n\n  The advantages of mmap nearly always outweigh disadvantages for\n  \"large\" chunks, but the value of \"large\" varies across systems.  The\n  default is an empirically derived value that works well in most\n  systems.\n\n\n  Update in 2006:\n  The above was written in 2001. Since then the world has changed a lot.\n  Memory got bigger. Applications got bigger. The virtual address space\n  layout in 32 bit linux changed.\n\n  In the new situation, brk() and mmap space is shared and there are no\n  artificial limits on brk size imposed by the kernel. What is more,\n  applications have started using transient allocations larger than the\n  128Kb as was imagined in 2001.\n\n  The price for mmap is also high now; each time glibc mmaps from the\n  kernel, the kernel is forced to zero out the memory it gives to the\n  application. Zeroing memory is expensive and eats a lot of cache and\n  memory bandwidth. This has nothing to do with the efficiency of the\n  virtual memory system, by doing mmap the kernel just has no choice but\n  to zero.\n\n  In 2001, the kernel had a maximum size for brk() which was about 800\n  megabytes on 32 bit x86, at that point brk() would hit the first\n  mmaped shared libaries and couldn't expand anymore. With current 2.6\n  kernels, the VA space layout is different and brk() and mmap\n  both can span the entire heap at will.\n\n  Rather than using a static threshold for the brk/mmap tradeoff,\n  we are now using a simple dynamic one. The goal is still to avoid\n  fragmentation. The old goals we kept are\n  1) try to get the long lived large allocations to use mmap()\n  2) really large allocations should always use mmap()\n  and we're adding now:\n  3) transient allocations should use brk() to avoid forcing the kernel\n     having to zero memory over and over again\n\n  The implementation works with a sliding threshold, which is by default\n  limited to go between 128Kb and 32Mb (64Mb for 64 bitmachines) and starts\n  out at 128Kb as per the 2001 default.\n\n  This allows us to satisfy requirement 1) under the assumption that long\n  lived allocations are made early in the process' lifespan, before it has\n  started doing dynamic allocations of the same size (which will\n  increase the threshold).\n\n  The upperbound on the threshold satisfies requirement 2)\n\n  The threshold goes up in value when the application frees memory that was\n  allocated with the mmap allocator. The idea is that once the application\n  starts freeing memory of a certain size, it's highly probable that this is\n  a size the application uses for transient allocations. This estimator\n  is there to satisfy the new third requirement.\n\n*/\n\n#define M_MMAP_THRESHOLD      -3\n\n#ifndef DEFAULT_MMAP_THRESHOLD\n#define DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN\n#endif\n\n/*\n  M_MMAP_MAX is the maximum number of requests to simultaneously\n  service using mmap. This parameter exists because\n  some systems have a limited number of internal tables for\n  use by mmap, and using more than a few of them may degrade\n  performance.\n\n  The default is set to a value that serves only as a safeguard.\n  Setting to 0 disables use of mmap for servicing large requests.\n*/\n\n#define M_MMAP_MAX             -4\n\n#ifndef DEFAULT_MMAP_MAX\n#define DEFAULT_MMAP_MAX       (65536)\n#endif\n\n#include <malloc.h>\n\n#ifndef RETURN_ADDRESS\n#define RETURN_ADDRESS(X_) (NULL)\n#endif\n\n/* Forward declarations.  */\nstruct malloc_chunk;\ntypedef struct malloc_chunk* mchunkptr;\n\n/* Internal routines.  */\n\nstatic void*  _int_malloc(mstate, size_t);\nstatic void     _int_free(mstate, mchunkptr, int);\nstatic void*  _int_realloc(mstate, mchunkptr, INTERNAL_SIZE_T,\n\t\t\t   INTERNAL_SIZE_T);\nstatic void*  _int_memalign(mstate, size_t, size_t);\nstatic void*  _mid_memalign(size_t, size_t, void *);\n\nstatic void malloc_printerr(const char *str) __attribute__ ((noreturn));\n\nstatic void* mem2mem_check(void *p, size_t sz);\nstatic void top_check(void);\nstatic void munmap_chunk(mchunkptr p);\n#if HAVE_MREMAP\nstatic mchunkptr mremap_chunk(mchunkptr p, size_t new_size);\n#endif\n\nstatic void*   malloc_check(size_t sz, const void *caller);\nstatic void      free_check(void* mem, const void *caller);\nstatic void*   realloc_check(void* oldmem, size_t bytes,\n\t\t\t       const void *caller);\nstatic void*   memalign_check(size_t alignment, size_t bytes,\n\t\t\t\tconst void *caller);\n\n/* ------------------ MMAP support ------------------  */\n\n\n#include <fcntl.h>\n#include <sys/mman.h>\n\n#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)\n# define MAP_ANONYMOUS MAP_ANON\n#endif\n\n#ifndef MAP_NORESERVE\n# define MAP_NORESERVE 0\n#endif\n\n#define MMAP(addr, size, prot, flags) \\\n __mmap((addr), (size), (prot), (flags)|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0)\n\n\n/*\n  -----------------------  Chunk representations -----------------------\n*/\n\n\n/*\n  This struct declaration is misleading (but accurate and necessary).\n  It declares a \"view\" into memory allowing access to necessary\n  fields at known offsets from a given base. See explanation below.\n*/\n\nstruct malloc_chunk {\n\n  INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */\n  INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */\n\n  struct malloc_chunk* fd;         /* double links -- used only if free. */\n  struct malloc_chunk* bk;\n\n  /* Only used for large blocks: pointer to next larger size.  */\n  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */\n  struct malloc_chunk* bk_nextsize;\n};\n\n\n/*\n   malloc_chunk details:\n\n    (The following includes lightly edited explanations by Colin Plumb.)\n\n    Chunks of memory are maintained using a `boundary tag' method as\n    described in e.g., Knuth or Standish.  (See the paper by Paul\n    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a\n    survey of such techniques.)  Sizes of free chunks are stored both\n    in the front of each chunk and at the end.  This makes\n    consolidating fragmented chunks into bigger chunks very fast.  The\n    size fields also hold bits representing whether chunks are free or\n    in use.\n\n    An allocated chunk looks like this:\n\n\n    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t    |             Size of previous chunk, if unallocated (P clear)  |\n\t    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t    |             Size of chunk, in bytes                     |A|M|P|\n      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t    |             User data starts here...                          .\n\t    .                                                               .\n\t    .             (malloc_usable_size() bytes)                      .\n\t    .                                                               |\nnextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t    |             (size of chunk, but used for application data)    |\n\t    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t    |             Size of next chunk, in bytes                |A|0|1|\n\t    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n    Where \"chunk\" is the front of the chunk for the purpose of most of\n    the malloc code, but \"mem\" is the pointer that is returned to the\n    user.  \"Nextchunk\" is the beginning of the next contiguous chunk.\n\n    Chunks always begin on even word boundaries, so the mem portion\n    (which is returned to the user) is also on an even word boundary, and\n    thus at least double-word aligned.\n\n    Free chunks are stored in circular doubly-linked lists, and look like this:\n\n    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t    |             Size of previous chunk, if unallocated (P clear)  |\n\t    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    `head:' |             Size of chunk, in bytes                     |A|0|P|\n      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t    |             Forward pointer to next chunk in list             |\n\t    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t    |             Back pointer to previous chunk in list            |\n\t    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t    |             Unused space (may be 0 bytes long)                .\n\t    .                                                               .\n\t    .                                                               |\nnextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    `foot:' |             Size of chunk, in bytes                           |\n\t    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t    |             Size of next chunk, in bytes                |A|0|0|\n\t    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n    The P (PREV_INUSE) bit, stored in the unused low-order bit of the\n    chunk size (which is always a multiple of two words), is an in-use\n    bit for the *previous* chunk.  If that bit is *clear*, then the\n    word before the current chunk size contains the previous chunk\n    size, and can be used to find the front of the previous chunk.\n    The very first chunk allocated always has this bit set,\n    preventing access to non-existent (or non-owned) memory. If\n    prev_inuse is set for any given chunk, then you CANNOT determine\n    the size of the previous chunk, and might even get a memory\n    addressing fault when trying to do so.\n\n    The A (NON_MAIN_ARENA) bit is cleared for chunks on the initial,\n    main arena, described by the main_arena variable.  When additional\n    threads are spawned, each thread receives its own arena (up to a\n    configurable limit, after which arenas are reused for multiple\n    threads), and the chunks in these arenas have the A bit set.  To\n    find the arena for a chunk on such a non-main arena, heap_for_ptr\n    performs a bit mask operation and indirection through the ar_ptr\n    member of the per-heap header heap_info (see arena.c).\n\n    Note that the `foot' of the current chunk is actually represented\n    as the prev_size of the NEXT chunk. This makes it easier to\n    deal with alignments etc but can be very confusing when trying\n    to extend or adapt this code.\n\n    The three exceptions to all this are:\n\n     1. The special chunk `top' doesn't bother using the\n\ttrailing size field since there is no next contiguous chunk\n\tthat would have to index off it. After initialization, `top'\n\tis forced to always exist.  If it would become less than\n\tMINSIZE bytes long, it is replenished.\n\n     2. Chunks allocated via mmap, which have the second-lowest-order\n\tbit M (IS_MMAPPED) set in their size fields.  Because they are\n\tallocated one-by-one, each must contain its own trailing size\n\tfield.  If the M bit is set, the other bits are ignored\n\t(because mmapped chunks are neither in an arena, nor adjacent\n\tto a freed chunk).  The M bit is also used for chunks which\n\toriginally came from a dumped heap via malloc_set_state in\n\thooks.c.\n\n     3. Chunks in fastbins are treated as allocated chunks from the\n\tpoint of view of the chunk allocator.  They are consolidated\n\twith their neighbors only in bulk, in malloc_consolidate.\n*/\n\n/*\n  ---------- Size and alignment checks and conversions ----------\n*/\n\n/* conversion from malloc headers to user pointers, and back */\n\n#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))\n#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))\n\n/* The smallest possible chunk */\n#define MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))\n\n/* The smallest size we can malloc is an aligned minimal chunk */\n\n#define MINSIZE  \\\n  (unsigned long)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK))\n\n/* Check if m has acceptable alignment */\n\n#define aligned_OK(m)  (((unsigned long)(m) & MALLOC_ALIGN_MASK) == 0)\n\n#define misaligned_chunk(p) \\\n  ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem (p)) \\\n   & MALLOC_ALIGN_MASK)\n\n\n/*\n   Check if a request is so large that it would wrap around zero when\n   padded and aligned. To simplify some other code, the bound is made\n   low enough so that adding MINSIZE will also not wrap around zero.\n */\n\n#define REQUEST_OUT_OF_RANGE(req)                                 \\\n  ((unsigned long) (req) >=\t\t\t\t\t\t      \\\n   (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))\n\n/* pad request bytes into a usable size -- internal version */\n\n#define request2size(req)                                         \\\n  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE)  ?             \\\n   MINSIZE :                                                      \\\n   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)\n\n/* Same, except also perform an argument and result check.  First, we check\n   that the padding done by request2size didn't result in an integer\n   overflow.  Then we check (using REQUEST_OUT_OF_RANGE) that the resulting\n   size isn't so large that a later alignment would lead to another integer\n   overflow.  */\n#define checked_request2size(req, sz) \\\n({\t\t\t\t    \\\n  (sz) = request2size (req);\t    \\\n  if (((sz) < (req))\t\t    \\\n      || REQUEST_OUT_OF_RANGE (sz)) \\\n    {\t\t\t\t    \\\n      __set_errno (ENOMEM);\t    \\\n      return 0;\t\t\t    \\\n    }\t\t\t\t    \\\n})\n\n/*\n   --------------- Physical chunk operations ---------------\n */\n\n\n/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */\n#define PREV_INUSE 0x1\n\n/* extract inuse bit of previous chunk */\n#define prev_inuse(p)       ((p)->mchunk_size & PREV_INUSE)\n\n\n/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */\n#define IS_MMAPPED 0x2\n\n/* check for mmap()'ed chunk */\n#define chunk_is_mmapped(p) ((p)->mchunk_size & IS_MMAPPED)\n\n\n/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained\n   from a non-main arena.  This is only set immediately before handing\n   the chunk to the user, if necessary.  */\n#define NON_MAIN_ARENA 0x4\n\n/* Check for chunk from main arena.  */\n#define chunk_main_arena(p) (((p)->mchunk_size & NON_MAIN_ARENA) == 0)\n\n/* Mark a chunk as not being on the main arena.  */\n#define set_non_main_arena(p) ((p)->mchunk_size |= NON_MAIN_ARENA)\n\n\n/*\n   Bits to mask off when extracting size\n\n   Note: IS_MMAPPED is intentionally not masked off from size field in\n   macros for which mmapped chunks should never be seen. This should\n   cause helpful core dumps to occur if it is tried by accident by\n   people extending or adapting this malloc.\n */\n#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)\n\n/* Get size, ignoring use bits */\n#define chunksize(p) (chunksize_nomask (p) & ~(SIZE_BITS))\n\n/* Like chunksize, but do not mask SIZE_BITS.  */\n#define chunksize_nomask(p)         ((p)->mchunk_size)\n\n/* Ptr to next physical malloc_chunk. */\n#define next_chunk(p) ((mchunkptr) (((char *) (p)) + chunksize (p)))\n\n/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */\n#define prev_size(p) ((p)->mchunk_prev_size)\n\n/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */\n#define set_prev_size(p, sz) ((p)->mchunk_prev_size = (sz))\n\n/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */\n#define prev_chunk(p) ((mchunkptr) (((char *) (p)) - prev_size (p)))\n\n/* Treat space at ptr + offset as a chunk */\n#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))\n\n/* extract p's inuse bit */\n#define inuse(p)\t\t\t\t\t\t\t      \\\n  ((((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size) & PREV_INUSE)\n\n/* set/clear chunk as being inuse without otherwise disturbing */\n#define set_inuse(p)\t\t\t\t\t\t\t      \\\n  ((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size |= PREV_INUSE\n\n#define clear_inuse(p)\t\t\t\t\t\t\t      \\\n  ((mchunkptr) (((char *) (p)) + chunksize (p)))->mchunk_size &= ~(PREV_INUSE)\n\n\n/* check/set/clear inuse bits in known places */\n#define inuse_bit_at_offset(p, s)\t\t\t\t\t      \\\n  (((mchunkptr) (((char *) (p)) + (s)))->mchunk_size & PREV_INUSE)\n\n#define set_inuse_bit_at_offset(p, s)\t\t\t\t\t      \\\n  (((mchunkptr) (((char *) (p)) + (s)))->mchunk_size |= PREV_INUSE)\n\n#define clear_inuse_bit_at_offset(p, s)\t\t\t\t\t      \\\n  (((mchunkptr) (((char *) (p)) + (s)))->mchunk_size &= ~(PREV_INUSE))\n\n\n/* Set size at head, without disturbing its use bit */\n#define set_head_size(p, s)  ((p)->mchunk_size = (((p)->mchunk_size & SIZE_BITS) | (s)))\n\n/* Set size/use field */\n#define set_head(p, s)       ((p)->mchunk_size = (s))\n\n/* Set size at footer (only when chunk is not in use) */\n#define set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))->mchunk_prev_size = (s))\n\n\n#pragma GCC poison mchunk_size\n#pragma GCC poison mchunk_prev_size\n\n/*\n   -------------------- Internal data structures --------------------\n\n   All internal state is held in an instance of malloc_state defined\n   below. There are no other static variables, except in two optional\n   cases:\n * If USE_MALLOC_LOCK is defined, the mALLOC_MUTEx declared above.\n * If mmap doesn't support MAP_ANONYMOUS, a dummy file descriptor\n     for mmap.\n\n   Beware of lots of tricks that minimize the total bookkeeping space\n   requirements. The result is a little over 1K bytes (for 4byte\n   pointers and size_t.)\n */\n\n/*\n   Bins\n\n    An array of bin headers for free chunks. Each bin is doubly\n    linked.  The bins are approximately proportionally (log) spaced.\n    There are a lot of these bins (128). This may look excessive, but\n    works very well in practice.  Most bins hold sizes that are\n    unusual as malloc request sizes, but are more usual for fragments\n    and consolidated sets of chunks, which is what these bins hold, so\n    they can be found quickly.  All procedures maintain the invariant\n    that no consolidated chunk physically borders another one, so each\n    chunk in a list is known to be preceeded and followed by either\n    inuse chunks or the ends of memory.\n\n    Chunks in bins are kept in size order, with ties going to the\n    approximately least recently used chunk. Ordering isn't needed\n    for the small bins, which all contain the same-sized chunks, but\n    facilitates best-fit allocation for larger chunks. These lists\n    are just sequential. Keeping them in order almost never requires\n    enough traversal to warrant using fancier ordered data\n    structures.\n\n    Chunks of the same size are linked with the most\n    recently freed at the front, and allocations are taken from the\n    back.  This results in LRU (FIFO) allocation order, which tends\n    to give each chunk an equal opportunity to be consolidated with\n    adjacent freed chunks, resulting in larger free chunks and less\n    fragmentation.\n\n    To simplify use in double-linked lists, each bin header acts\n    as a malloc_chunk. This avoids special-casing for headers.\n    But to conserve space and improve locality, we allocate\n    only the fd/bk pointers of bins, and then use repositioning tricks\n    to treat these as the fields of a malloc_chunk*.\n */\n\ntypedef struct malloc_chunk *mbinptr;\n\n/* addressing -- note that bin_at(0) does not exist */\n#define bin_at(m, i) \\\n  (mbinptr) (((char *) &((m)->bins[((i) - 1) * 2]))\t\t\t      \\\n             - offsetof (struct malloc_chunk, fd))\n\n/* analog of ++bin */\n#define next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) << 1)))\n\n/* Reminders about list directionality within bins */\n#define first(b)     ((b)->fd)\n#define last(b)      ((b)->bk)\n\n/* Take a chunk off a bin list */\n#define unlink(AV, P, BK, FD) {                                            \\\n    if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \\\n      malloc_printerr (\"corrupted size vs. prev_size\");\t\t\t      \\\n    FD = P->fd;\t\t\t\t\t\t\t\t      \\\n    BK = P->bk;\t\t\t\t\t\t\t\t      \\\n    if (__builtin_expect (FD->bk != P || BK->fd != P, 0))\t\t      \\\n      malloc_printerr (\"corrupted double-linked list\");\t\t\t      \\\n    else {\t\t\t\t\t\t\t\t      \\\n        FD->bk = BK;\t\t\t\t\t\t\t      \\\n        BK->fd = FD;\t\t\t\t\t\t\t      \\\n        if (!in_smallbin_range (chunksize_nomask (P))\t\t\t      \\\n            && __builtin_expect (P->fd_nextsize != NULL, 0)) {\t\t      \\\n\t    if (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)\t      \\\n\t\t|| __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    \\\n\t      malloc_printerr (\"corrupted double-linked list (not small)\");   \\\n            if (FD->fd_nextsize == NULL) {\t\t\t\t      \\\n                if (P->fd_nextsize == P)\t\t\t\t      \\\n                  FD->fd_nextsize = FD->bk_nextsize = FD;\t\t      \\\n                else {\t\t\t\t\t\t\t      \\\n                    FD->fd_nextsize = P->fd_nextsize;\t\t\t      \\\n                    FD->bk_nextsize = P->bk_nextsize;\t\t\t      \\\n                    P->fd_nextsize->bk_nextsize = FD;\t\t\t      \\\n                    P->bk_nextsize->fd_nextsize = FD;\t\t\t      \\\n                  }\t\t\t\t\t\t\t      \\\n              } else {\t\t\t\t\t\t\t      \\\n                P->fd_nextsize->bk_nextsize = P->bk_nextsize;\t\t      \\\n                P->bk_nextsize->fd_nextsize = P->fd_nextsize;\t\t      \\\n              }\t\t\t\t\t\t\t\t      \\\n          }\t\t\t\t\t\t\t\t      \\\n      }\t\t\t\t\t\t\t\t\t      \\\n}\n\n/*\n   Indexing\n\n    Bins for sizes < 512 bytes contain chunks of all the same size, spaced\n    8 bytes apart. Larger bins are approximately logarithmically spaced:\n\n    64 bins of size       8\n    32 bins of size      64\n    16 bins of size     512\n     8 bins of size    4096\n     4 bins of size   32768\n     2 bins of size  262144\n     1 bin  of size what's left\n\n    There is actually a little bit of slop in the numbers in bin_index\n    for the sake of speed. This makes no difference elsewhere.\n\n    The bins top out around 1MB because we expect to service large\n    requests via mmap.\n\n    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be\n    a valid chunk size the small bins are bumped up one.\n */\n\n#define NBINS             128\n#define NSMALLBINS         64\n#define SMALLBIN_WIDTH    MALLOC_ALIGNMENT\n#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT > 2 * SIZE_SZ)\n#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)\n\n#define in_smallbin_range(sz)  \\\n  ((unsigned long) (sz) < (unsigned long) MIN_LARGE_SIZE)\n\n#define smallbin_index(sz) \\\n  ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) >> 4) : (((unsigned) (sz)) >> 3))\\\n   + SMALLBIN_CORRECTION)\n\n#define largebin_index_32(sz)                                                \\\n  (((((unsigned long) (sz)) >> 6) <= 38) ?  56 + (((unsigned long) (sz)) >> 6) :\\\n   ((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\\\n   ((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\\\n   ((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\\\n   ((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\\\n   126)\n\n#define largebin_index_32_big(sz)                                            \\\n  (((((unsigned long) (sz)) >> 6) <= 45) ?  49 + (((unsigned long) (sz)) >> 6) :\\\n   ((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\\\n   ((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\\\n   ((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\\\n   ((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\\\n   126)\n\n// XXX It remains to be seen whether it is good to keep the widths of\n// XXX the buckets the same or whether it should be scaled by a factor\n// XXX of two as well.\n#define largebin_index_64(sz)                                                \\\n  (((((unsigned long) (sz)) >> 6) <= 48) ?  48 + (((unsigned long) (sz)) >> 6) :\\\n   ((((unsigned long) (sz)) >> 9) <= 20) ?  91 + (((unsigned long) (sz)) >> 9) :\\\n   ((((unsigned long) (sz)) >> 12) <= 10) ? 110 + (((unsigned long) (sz)) >> 12) :\\\n   ((((unsigned long) (sz)) >> 15) <= 4) ? 119 + (((unsigned long) (sz)) >> 15) :\\\n   ((((unsigned long) (sz)) >> 18) <= 2) ? 124 + (((unsigned long) (sz)) >> 18) :\\\n   126)\n\n#define largebin_index(sz) \\\n  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \\\n   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \\\n   : largebin_index_32 (sz))\n\n#define bin_index(sz) \\\n  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))\n\n\n/*\n   Unsorted chunks\n\n    All remainders from chunk splits, as well as all returned chunks,\n    are first placed in the \"unsorted\" bin. They are then placed\n    in regular bins after malloc gives them ONE chance to be used before\n    binning. So, basically, the unsorted_chunks list acts as a queue,\n    with chunks being placed on it in free (and malloc_consolidate),\n    and taken off (to be either used or placed in bins) in malloc.\n\n    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it\n    does not have to be taken into account in size comparisons.\n */\n\n/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */\n#define unsorted_chunks(M)          (bin_at (M, 1))\n\n/*\n   Top\n\n    The top-most available chunk (i.e., the one bordering the end of\n    available memory) is treated specially. It is never included in\n    any bin, is used only if no other chunk is available, and is\n    released back to the system if it is very large (see\n    M_TRIM_THRESHOLD).  Because top initially\n    points to its own bin with initial zero size, thus forcing\n    extension on the first malloc request, we avoid having any special\n    code in malloc to check whether it even exists yet. But we still\n    need to do so when getting memory from system, so we make\n    initial_top treat the bin as a legal but unusable chunk during the\n    interval between initialization and the first call to\n    sysmalloc. (This is somewhat delicate, since it relies on\n    the 2 preceding words to be zero during this interval as well.)\n */\n\n/* Conveniently, the unsorted bin can be used as dummy top on first call */\n#define initial_top(M)              (unsorted_chunks (M))\n\n/*\n   Binmap\n\n    To help compensate for the large number of bins, a one-level index\n    structure is used for bin-by-bin searching.  `binmap' is a\n    bitvector recording whether bins are definitely empty so they can\n    be skipped over during during traversals.  The bits are NOT always\n    cleared as soon as bins are empty, but instead only\n    when they are noticed to be empty during traversal in malloc.\n */\n\n/* Conservatively use 32 bits per map word, even if on 64bit system */\n#define BINMAPSHIFT      5\n#define BITSPERMAP       (1U << BINMAPSHIFT)\n#define BINMAPSIZE       (NBINS / BITSPERMAP)\n\n#define idx2block(i)     ((i) >> BINMAPSHIFT)\n#define idx2bit(i)       ((1U << ((i) & ((1U << BINMAPSHIFT) - 1))))\n\n#define mark_bin(m, i)    ((m)->binmap[idx2block (i)] |= idx2bit (i))\n#define unmark_bin(m, i)  ((m)->binmap[idx2block (i)] &= ~(idx2bit (i)))\n#define get_binmap(m, i)  ((m)->binmap[idx2block (i)] & idx2bit (i))\n\n/*\n   Fastbins\n\n    An array of lists holding recently freed small chunks.  Fastbins\n    are not doubly linked.  It is faster to single-link them, and\n    since chunks are never removed from the middles of these lists,\n    double linking is not necessary. Also, unlike regular bins, they\n    are not even processed in FIFO order (they use faster LIFO) since\n    ordering doesn't much matter in the transient contexts in which\n    fastbins are normally used.\n\n    Chunks in fastbins keep their inuse bit set, so they cannot\n    be consolidated with other free chunks. malloc_consolidate\n    releases all chunks in fastbins and consolidates them with\n    other free chunks.\n */\n\ntypedef struct malloc_chunk *mfastbinptr;\n#define fastbin(ar_ptr, idx) ((ar_ptr)->fastbinsY[idx])\n\n/* offset 2 to use otherwise unindexable first 2 bins */\n#define fastbin_index(sz) \\\n  ((((unsigned int) (sz)) >> (SIZE_SZ == 8 ? 4 : 3)) - 2)\n\n\n/* The maximum fastbin request size we support */\n#define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)\n\n#define NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)\n\n/*\n   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()\n   that triggers automatic consolidation of possibly-surrounding\n   fastbin chunks. This is a heuristic, so the exact value should not\n   matter too much. It is defined at half the default trim threshold as a\n   compromise heuristic to only attempt consolidation if it is likely\n   to lead to trimming. However, it is not dynamically tunable, since\n   consolidation reduces fragmentation surrounding large chunks even\n   if trimming is not used.\n */\n\n#define FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)\n\n/*\n   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous\n   regions.  Otherwise, contiguity is exploited in merging together,\n   when possible, results from consecutive MORECORE calls.\n\n   The initial value comes from MORECORE_CONTIGUOUS, but is\n   changed dynamically if mmap is ever used as an sbrk substitute.\n */\n\n#define NONCONTIGUOUS_BIT     (2U)\n\n#define contiguous(M)          (((M)->flags & NONCONTIGUOUS_BIT) == 0)\n#define noncontiguous(M)       (((M)->flags & NONCONTIGUOUS_BIT) != 0)\n#define set_noncontiguous(M)   ((M)->flags |= NONCONTIGUOUS_BIT)\n#define set_contiguous(M)      ((M)->flags &= ~NONCONTIGUOUS_BIT)\n\n/* Maximum size of memory handled in fastbins.  */\nstatic INTERNAL_SIZE_T global_max_fast;\n\n/*\n   Set value of max_fast.\n   Use impossibly small value if 0.\n   Precondition: there are no existing fastbin chunks in the main arena.\n   Since do_check_malloc_state () checks this, we call malloc_consolidate ()\n   before changing max_fast.  Note other arenas will leak their fast bin\n   entries if max_fast is reduced.\n */\n\n#define set_max_fast(s) \\\n  global_max_fast = (((s) == 0)\t\t\t\t\t\t      \\\n                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) & ~MALLOC_ALIGN_MASK))\n\nstatic inline INTERNAL_SIZE_T\nget_max_fast (void)\n{\n  /* Tell the GCC optimizers that global_max_fast is never larger\n     than MAX_FAST_SIZE.  This avoids out-of-bounds array accesses in\n     _int_malloc after constant propagation of the size parameter.\n     (The code never executes because malloc preserves the\n     global_max_fast invariant, but the optimizers may not recognize\n     this.)  */\n  if (global_max_fast > MAX_FAST_SIZE)\n    __builtin_unreachable ();\n  return global_max_fast;\n}\n\n/*\n   ----------- Internal state representation and initialization -----------\n */\n\n/*\n   have_fastchunks indicates that there are probably some fastbin chunks.\n   It is set true on entering a chunk into any fastbin, and cleared early in\n   malloc_consolidate.  The value is approximate since it may be set when there\n   are no fastbin chunks, or it may be clear even if there are fastbin chunks\n   available.  Given it's sole purpose is to reduce number of redundant calls to\n   malloc_consolidate, it does not affect correctness.  As a result we can safely\n   use relaxed atomic accesses.\n */\n\n\nstruct malloc_state\n{\n  /* Serialize access.  */\n  __libc_lock_define (, mutex);\n\n  /* Flags (formerly in max_fast).  */\n  int flags;\n\n  /* Set if the fastbin chunks contain recently inserted free blocks.  */\n  /* Note this is a bool but not all targets support atomics on booleans.  */\n  int have_fastchunks;\n\n  /* Fastbins */\n  mfastbinptr fastbinsY[NFASTBINS];\n\n  /* Base of the topmost chunk -- not otherwise kept in a bin */\n  mchunkptr top;\n\n  /* The remainder from the most recent split of a small request */\n  mchunkptr last_remainder;\n\n  /* Normal bins packed as described above */\n  mchunkptr bins[NBINS * 2 - 2];\n\n  /* Bitmap of bins */\n  unsigned int binmap[BINMAPSIZE];\n\n  /* Linked list */\n  struct malloc_state *next;\n\n  /* Linked list for free arenas.  Access to this field is serialized\n     by free_list_lock in arena.c.  */\n  struct malloc_state *next_free;\n\n  /* Number of threads attached to this arena.  0 if the arena is on\n     the free list.  Access to this field is serialized by\n     free_list_lock in arena.c.  */\n  INTERNAL_SIZE_T attached_threads;\n\n  /* Memory allocated from the system in this arena.  */\n  INTERNAL_SIZE_T system_mem;\n  INTERNAL_SIZE_T max_system_mem;\n};\n\nstruct malloc_par\n{\n  /* Tunable parameters */\n  unsigned long trim_threshold;\n  INTERNAL_SIZE_T top_pad;\n  INTERNAL_SIZE_T mmap_threshold;\n  INTERNAL_SIZE_T arena_test;\n  INTERNAL_SIZE_T arena_max;\n\n  /* Memory map support */\n  int n_mmaps;\n  int n_mmaps_max;\n  int max_n_mmaps;\n  /* the mmap_threshold is dynamic, until the user sets\n     it manually, at which point we need to disable any\n     dynamic behavior. */\n  int no_dyn_threshold;\n\n  /* Statistics */\n  INTERNAL_SIZE_T mmapped_mem;\n  INTERNAL_SIZE_T max_mmapped_mem;\n\n  /* First address handed out by MORECORE/sbrk.  */\n  char *sbrk_base;\n\n#if USE_TCACHE\n  /* Maximum number of buckets to use.  */\n  size_t tcache_bins;\n  size_t tcache_max_bytes;\n  /* Maximum number of chunks in each bucket.  */\n  size_t tcache_count;\n  /* Maximum number of chunks to remove from the unsorted list, which\n     aren't used to prefill the cache.  */\n  size_t tcache_unsorted_limit;\n#endif\n};\n\n/* There are several instances of this struct (\"arenas\") in this\n   malloc.  If you are adapting this malloc in a way that does NOT use\n   a static or mmapped malloc_state, you MUST explicitly zero-fill it\n   before using. This malloc relies on the property that malloc_state\n   is initialized to all zeroes (as is true of C statics).  */\n\nstatic struct malloc_state main_arena =\n{\n  .mutex = _LIBC_LOCK_INITIALIZER,\n  .next = &main_arena,\n  .attached_threads = 1\n};\n\n/* These variables are used for undumping support.  Chunked are marked\n   as using mmap, but we leave them alone if they fall into this\n   range.  NB: The chunk size for these chunks only includes the\n   initial size field (of SIZE_SZ bytes), there is no trailing size\n   field (unlike with regular mmapped chunks).  */\nstatic mchunkptr dumped_main_arena_start; /* Inclusive.  */\nstatic mchunkptr dumped_main_arena_end;   /* Exclusive.  */\n\n/* True if the pointer falls into the dumped arena.  Use this after\n   chunk_is_mmapped indicates a chunk is mmapped.  */\n#define DUMPED_MAIN_ARENA_CHUNK(p) \\\n  ((p) >= dumped_main_arena_start && (p) < dumped_main_arena_end)\n\n/* There is only one instance of the malloc parameters.  */\n\nstatic struct malloc_par mp_ =\n{\n  .top_pad = DEFAULT_TOP_PAD,\n  .n_mmaps_max = DEFAULT_MMAP_MAX,\n  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,\n  .trim_threshold = DEFAULT_TRIM_THRESHOLD,\n#define NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))\n  .arena_test = NARENAS_FROM_NCORES (1)\n#if USE_TCACHE\n  ,\n  .tcache_count = TCACHE_FILL_COUNT,\n  .tcache_bins = TCACHE_MAX_BINS,\n  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS-1),\n  .tcache_unsorted_limit = 0 /* No limit.  */\n#endif\n};\n\n/*\n   Initialize a malloc_state struct.\n\n   This is called from ptmalloc_init () or from _int_new_arena ()\n   when creating a new arena.\n */\n\nstatic void\nmalloc_init_state (mstate av)\n{\n  int i;\n  mbinptr bin;\n\n  /* Establish circular links for normal bins */\n  for (i = 1; i < NBINS; ++i)\n    {\n      bin = bin_at (av, i);\n      bin->fd = bin->bk = bin;\n    }\n\n#if MORECORE_CONTIGUOUS\n  if (av != &main_arena)\n#endif\n  set_noncontiguous (av);\n  if (av == &main_arena)\n    set_max_fast (DEFAULT_MXFAST);\n  atomic_store_relaxed (&av->have_fastchunks, false);\n\n  av->top = initial_top (av);\n}\n\n/*\n   Other internal utilities operating on mstates\n */\n\nstatic void *sysmalloc (INTERNAL_SIZE_T, mstate);\nstatic int      systrim (size_t, mstate);\nstatic void     malloc_consolidate (mstate);\n\n\n/* -------------- Early definitions for debugging hooks ---------------- */\n\n/* Define and initialize the hook variables.  These weak definitions must\n   appear before any use of the variables in a function (arena.c uses one).  */\n#ifndef weak_variable\n/* In GNU libc we want the hook variables to be weak definitions to\n   avoid a problem with Emacs.  */\n# define weak_variable weak_function\n#endif\n\n/* Forward declarations.  */\nstatic void *malloc_hook_ini (size_t sz,\n                              const void *caller) __THROW;\nstatic void *realloc_hook_ini (void *ptr, size_t sz,\n                               const void *caller) __THROW;\nstatic void *memalign_hook_ini (size_t alignment, size_t sz,\n                                const void *caller) __THROW;\n\n#if HAVE_MALLOC_INIT_HOOK\nvoid weak_variable (*__malloc_initialize_hook) (void) = NULL;\ncompat_symbol (libc, __malloc_initialize_hook,\n\t       __malloc_initialize_hook, GLIBC_2_0);\n#endif\n\nvoid weak_variable (*__free_hook) (void *__ptr,\n                                   const void *) = NULL;\nvoid *weak_variable (*__malloc_hook)\n  (size_t __size, const void *) = malloc_hook_ini;\nvoid *weak_variable (*__realloc_hook)\n  (void *__ptr, size_t __size, const void *)\n  = realloc_hook_ini;\nvoid *weak_variable (*__memalign_hook)\n  (size_t __alignment, size_t __size, const void *)\n  = memalign_hook_ini;\nvoid weak_variable (*__after_morecore_hook) (void) = NULL;\n\n/* This function is called from the arena shutdown hook, to free the\n   thread cache (if it exists).  */\nstatic void tcache_thread_shutdown (void);\n\n/* ------------------ Testing support ----------------------------------*/\n\nstatic int perturb_byte;\n\nstatic void\nalloc_perturb (char *p, size_t n)\n{\n  if (__glibc_unlikely (perturb_byte))\n    memset (p, perturb_byte ^ 0xff, n);\n}\n\nstatic void\nfree_perturb (char *p, size_t n)\n{\n  if (__glibc_unlikely (perturb_byte))\n    memset (p, perturb_byte, n);\n}\n\n\n\n#include <stap-probe.h>\n\n/* ------------------- Support for multiple arenas -------------------- */\n#include \"arena.c\"\n\n/*\n   Debugging support\n\n   These routines make a number of assertions about the states\n   of data structures that should be true at all times. If any\n   are not true, it's very likely that a user program has somehow\n   trashed memory. (It's also possible that there is a coding error\n   in malloc. In which case, please report it!)\n */\n\n#if !MALLOC_DEBUG\n\n# define check_chunk(A, P)\n# define check_free_chunk(A, P)\n# define check_inuse_chunk(A, P)\n# define check_remalloced_chunk(A, P, N)\n# define check_malloced_chunk(A, P, N)\n# define check_malloc_state(A)\n\n#else\n\n# define check_chunk(A, P)              do_check_chunk (A, P)\n# define check_free_chunk(A, P)         do_check_free_chunk (A, P)\n# define check_inuse_chunk(A, P)        do_check_inuse_chunk (A, P)\n# define check_remalloced_chunk(A, P, N) do_check_remalloced_chunk (A, P, N)\n# define check_malloced_chunk(A, P, N)   do_check_malloced_chunk (A, P, N)\n# define check_malloc_state(A)         do_check_malloc_state (A)\n\n/*\n   Properties of all chunks\n */\n\nstatic void\ndo_check_chunk (mstate av, mchunkptr p)\n{\n  unsigned long sz = chunksize (p);\n  /* min and max possible addresses assuming contiguous allocation */\n  char *max_address = (char *) (av->top) + chunksize (av->top);\n  char *min_address = max_address - av->system_mem;\n\n  if (!chunk_is_mmapped (p))\n    {\n      /* Has legal address ... */\n      if (p != av->top)\n        {\n          if (contiguous (av))\n            {\n              assert (((char *) p) >= min_address);\n              assert (((char *) p + sz) <= ((char *) (av->top)));\n            }\n        }\n      else\n        {\n          /* top size is always at least MINSIZE */\n          assert ((unsigned long) (sz) >= MINSIZE);\n          /* top predecessor always marked inuse */\n          assert (prev_inuse (p));\n        }\n    }\n  else if (!DUMPED_MAIN_ARENA_CHUNK (p))\n    {\n      /* address is outside main heap  */\n      if (contiguous (av) && av->top != initial_top (av))\n        {\n          assert (((char *) p) < min_address || ((char *) p) >= max_address);\n        }\n      /* chunk is page-aligned */\n      assert (((prev_size (p) + sz) & (GLRO (dl_pagesize) - 1)) == 0);\n      /* mem is aligned */\n      assert (aligned_OK (chunk2mem (p)));\n    }\n}\n\n/*\n   Properties of free chunks\n */\n\nstatic void\ndo_check_free_chunk (mstate av, mchunkptr p)\n{\n  INTERNAL_SIZE_T sz = chunksize_nomask (p) & ~(PREV_INUSE | NON_MAIN_ARENA);\n  mchunkptr next = chunk_at_offset (p, sz);\n\n  do_check_chunk (av, p);\n\n  /* Chunk must claim to be free ... */\n  assert (!inuse (p));\n  assert (!chunk_is_mmapped (p));\n\n  /* Unless a special marker, must have OK fields */\n  if ((unsigned long) (sz) >= MINSIZE)\n    {\n      assert ((sz & MALLOC_ALIGN_MASK) == 0);\n      assert (aligned_OK (chunk2mem (p)));\n      /* ... matching footer field */\n      assert (prev_size (next_chunk (p)) == sz);\n      /* ... and is fully consolidated */\n      assert (prev_inuse (p));\n      assert (next == av->top || inuse (next));\n\n      /* ... and has minimally sane links */\n      assert (p->fd->bk == p);\n      assert (p->bk->fd == p);\n    }\n  else /* markers are always of size SIZE_SZ */\n    assert (sz == SIZE_SZ);\n}\n\n/*\n   Properties of inuse chunks\n */\n\nstatic void\ndo_check_inuse_chunk (mstate av, mchunkptr p)\n{\n  mchunkptr next;\n\n  do_check_chunk (av, p);\n\n  if (chunk_is_mmapped (p))\n    return; /* mmapped chunks have no next/prev */\n\n  /* Check whether it claims to be in use ... */\n  assert (inuse (p));\n\n  next = next_chunk (p);\n\n  /* ... and is surrounded by OK chunks.\n     Since more things can be checked with free chunks than inuse ones,\n     if an inuse chunk borders them and debug is on, it's worth doing them.\n   */\n  if (!prev_inuse (p))\n    {\n      /* Note that we cannot even look at prev unless it is not inuse */\n      mchunkptr prv = prev_chunk (p);\n      assert (next_chunk (prv) == p);\n      do_check_free_chunk (av, prv);\n    }\n\n  if (next == av->top)\n    {\n      assert (prev_inuse (next));\n      assert (chunksize (next) >= MINSIZE);\n    }\n  else if (!inuse (next))\n    do_check_free_chunk (av, next);\n}\n\n/*\n   Properties of chunks recycled from fastbins\n */\n\nstatic void\ndo_check_remalloced_chunk (mstate av, mchunkptr p, INTERNAL_SIZE_T s)\n{\n  INTERNAL_SIZE_T sz = chunksize_nomask (p) & ~(PREV_INUSE | NON_MAIN_ARENA);\n\n  if (!chunk_is_mmapped (p))\n    {\n      assert (av == arena_for_chunk (p));\n      if (chunk_main_arena (p))\n        assert (av == &main_arena);\n      else\n        assert (av != &main_arena);\n    }\n\n  do_check_inuse_chunk (av, p);\n\n  /* Legal size ... */\n  assert ((sz & MALLOC_ALIGN_MASK) == 0);\n  assert ((unsigned long) (sz) >= MINSIZE);\n  /* ... and alignment */\n  assert (aligned_OK (chunk2mem (p)));\n  /* chunk is less than MINSIZE more than request */\n  assert ((long) (sz) - (long) (s) >= 0);\n  assert ((long) (sz) - (long) (s + MINSIZE) < 0);\n}\n\n/*\n   Properties of nonrecycled chunks at the point they are malloced\n */\n\nstatic void\ndo_check_malloced_chunk (mstate av, mchunkptr p, INTERNAL_SIZE_T s)\n{\n  /* same as recycled case ... */\n  do_check_remalloced_chunk (av, p, s);\n\n  /*\n     ... plus,  must obey implementation invariant that prev_inuse is\n     always true of any allocated chunk; i.e., that each allocated\n     chunk borders either a previously allocated and still in-use\n     chunk, or the base of its memory arena. This is ensured\n     by making all allocations from the `lowest' part of any found\n     chunk.  This does not necessarily hold however for chunks\n     recycled via fastbins.\n   */\n\n  assert (prev_inuse (p));\n}\n\n\n/*\n   Properties of malloc_state.\n\n   This may be useful for debugging malloc, as well as detecting user\n   programmer errors that somehow write into malloc_state.\n\n   If you are extending or experimenting with this malloc, you can\n   probably figure out how to hack this routine to print out or\n   display chunk addresses, sizes, bins, and other instrumentation.\n */\n\nstatic void\ndo_check_malloc_state (mstate av)\n{\n  int i;\n  mchunkptr p;\n  mchunkptr q;\n  mbinptr b;\n  unsigned int idx;\n  INTERNAL_SIZE_T size;\n  unsigned long total = 0;\n  int max_fast_bin;\n\n  /* internal size_t must be no wider than pointer type */\n  assert (sizeof (INTERNAL_SIZE_T) <= sizeof (char *));\n\n  /* alignment is a power of 2 */\n  assert ((MALLOC_ALIGNMENT & (MALLOC_ALIGNMENT - 1)) == 0);\n\n  /* Check the arena is initialized. */\n  assert (av->top != 0);\n\n  /* No memory has been allocated yet, so doing more tests is not possible.  */\n  if (av->top == initial_top (av))\n    return;\n\n  /* pagesize is a power of 2 */\n  assert (powerof2(GLRO (dl_pagesize)));\n\n  /* A contiguous main_arena is consistent with sbrk_base.  */\n  if (av == &main_arena && contiguous (av))\n    assert ((char *) mp_.sbrk_base + av->system_mem ==\n            (char *) av->top + chunksize (av->top));\n\n  /* properties of fastbins */\n\n  /* max_fast is in allowed range */\n  assert ((get_max_fast () & ~1) <= request2size (MAX_FAST_SIZE));\n\n  max_fast_bin = fastbin_index (get_max_fast ());\n\n  for (i = 0; i < NFASTBINS; ++i)\n    {\n      p = fastbin (av, i);\n\n      /* The following test can only be performed for the main arena.\n         While mallopt calls malloc_consolidate to get rid of all fast\n         bins (especially those larger than the new maximum) this does\n         only happen for the main arena.  Trying to do this for any\n         other arena would mean those arenas have to be locked and\n         malloc_consolidate be called for them.  This is excessive.  And\n         even if this is acceptable to somebody it still cannot solve\n         the problem completely since if the arena is locked a\n         concurrent malloc call might create a new arena which then\n         could use the newly invalid fast bins.  */\n\n      /* all bins past max_fast are empty */\n      if (av == &main_arena && i > max_fast_bin)\n        assert (p == 0);\n\n      while (p != 0)\n        {\n          /* each chunk claims to be inuse */\n          do_check_inuse_chunk (av, p);\n          total += chunksize (p);\n          /* chunk belongs in this bin */\n          assert (fastbin_index (chunksize (p)) == i);\n          p = p->fd;\n        }\n    }\n\n  /* check normal bins */\n  for (i = 1; i < NBINS; ++i)\n    {\n      b = bin_at (av, i);\n\n      /* binmap is accurate (except for bin 1 == unsorted_chunks) */\n      if (i >= 2)\n        {\n          unsigned int binbit = get_binmap (av, i);\n          int empty = last (b) == b;\n          if (!binbit)\n            assert (empty);\n          else if (!empty)\n            assert (binbit);\n        }\n\n      for (p = last (b); p != b; p = p->bk)\n        {\n          /* each chunk claims to be free */\n          do_check_free_chunk (av, p);\n          size = chunksize (p);\n          total += size;\n          if (i >= 2)\n            {\n              /* chunk belongs in bin */\n              idx = bin_index (size);\n              assert (idx == i);\n              /* lists are sorted */\n              assert (p->bk == b ||\n                      (unsigned long) chunksize (p->bk) >= (unsigned long) chunksize (p));\n\n              if (!in_smallbin_range (size))\n                {\n                  if (p->fd_nextsize != NULL)\n                    {\n                      if (p->fd_nextsize == p)\n                        assert (p->bk_nextsize == p);\n                      else\n                        {\n                          if (p->fd_nextsize == first (b))\n                            assert (chunksize (p) < chunksize (p->fd_nextsize));\n                          else\n                            assert (chunksize (p) > chunksize (p->fd_nextsize));\n\n                          if (p == first (b))\n                            assert (chunksize (p) > chunksize (p->bk_nextsize));\n                          else\n                            assert (chunksize (p) < chunksize (p->bk_nextsize));\n                        }\n                    }\n                  else\n                    assert (p->bk_nextsize == NULL);\n                }\n            }\n          else if (!in_smallbin_range (size))\n            assert (p->fd_nextsize == NULL && p->bk_nextsize == NULL);\n          /* chunk is followed by a legal chain of inuse chunks */\n          for (q = next_chunk (p);\n               (q != av->top && inuse (q) &&\n                (unsigned long) (chunksize (q)) >= MINSIZE);\n               q = next_chunk (q))\n            do_check_inuse_chunk (av, q);\n        }\n    }\n\n  /* top chunk is OK */\n  check_chunk (av, av->top);\n}\n#endif\n\n\n/* ----------------- Support for debugging hooks -------------------- */\n#include \"hooks.c\"\n\n\n/* ----------- Routines dealing with system allocation -------------- */\n\n/*\n   sysmalloc handles malloc cases requiring more memory from the system.\n   On entry, it is assumed that av->top does not have enough\n   space to service request for nb bytes, thus requiring that av->top\n   be extended or replaced.\n */\n\nstatic void *\nsysmalloc (INTERNAL_SIZE_T nb, mstate av)\n{\n  mchunkptr old_top;              /* incoming value of av->top */\n  INTERNAL_SIZE_T old_size;       /* its size */\n  char *old_end;                  /* its end address */\n\n  long size;                      /* arg to first MORECORE or mmap call */\n  char *brk;                      /* return value from MORECORE */\n\n  long correction;                /* arg to 2nd MORECORE call */\n  char *snd_brk;                  /* 2nd return val */\n\n  INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of new space */\n  INTERNAL_SIZE_T end_misalign;   /* partial page left at end of new space */\n  char *aligned_brk;              /* aligned offset into brk */\n\n  mchunkptr p;                    /* the allocated/returned chunk */\n  mchunkptr remainder;            /* remainder from allocation */\n  unsigned long remainder_size;   /* its size */\n\n\n  size_t pagesize = GLRO (dl_pagesize);\n  bool tried_mmap = false;\n\n\n  /*\n     If have mmap, and the request size meets the mmap threshold, and\n     the system supports mmap, and there are few enough currently\n     allocated mmapped regions, try to directly map this request\n     rather than expanding top.\n   */\n\n  if (av == NULL\n      || ((unsigned long) (nb) >= (unsigned long) (mp_.mmap_threshold)\n\t  && (mp_.n_mmaps < mp_.n_mmaps_max)))\n    {\n      char *mm;           /* return value from mmap call*/\n\n    try_mmap:\n      /*\n         Round up size to nearest page.  For mmapped chunks, the overhead\n         is one SIZE_SZ unit larger than for normal chunks, because there\n         is no following chunk whose prev_size field could be used.\n\n         See the front_misalign handling below, for glibc there is no\n         need for further alignments unless we have have high alignment.\n       */\n      if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)\n        size = ALIGN_UP (nb + SIZE_SZ, pagesize);\n      else\n        size = ALIGN_UP (nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);\n      tried_mmap = true;\n\n      /* Don't try if size wraps around 0 */\n      if ((unsigned long) (size) > (unsigned long) (nb))\n        {\n          mm = (char *) (MMAP (0, size, PROT_READ | PROT_WRITE, 0));\n\n          if (mm != MAP_FAILED)\n            {\n              /*\n                 The offset to the start of the mmapped region is stored\n                 in the prev_size field of the chunk. This allows us to adjust\n                 returned start address to meet alignment requirements here\n                 and in memalign(), and still be able to compute proper\n                 address argument for later munmap in free() and realloc().\n               */\n\n              if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)\n                {\n                  /* For glibc, chunk2mem increases the address by 2*SIZE_SZ and\n                     MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap'ed area is page\n                     aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */\n                  assert (((INTERNAL_SIZE_T) chunk2mem (mm) & MALLOC_ALIGN_MASK) == 0);\n                  front_misalign = 0;\n                }\n              else\n                front_misalign = (INTERNAL_SIZE_T) chunk2mem (mm) & MALLOC_ALIGN_MASK;\n              if (front_misalign > 0)\n                {\n                  correction = MALLOC_ALIGNMENT - front_misalign;\n                  p = (mchunkptr) (mm + correction);\n\t\t  set_prev_size (p, correction);\n                  set_head (p, (size - correction) | IS_MMAPPED);\n                }\n              else\n                {\n                  p = (mchunkptr) mm;\n\t\t  set_prev_size (p, 0);\n                  set_head (p, size | IS_MMAPPED);\n                }\n\n              /* update statistics */\n\n              int new = atomic_exchange_and_add (&mp_.n_mmaps, 1) + 1;\n              atomic_max (&mp_.max_n_mmaps, new);\n\n              unsigned long sum;\n              sum = atomic_exchange_and_add (&mp_.mmapped_mem, size) + size;\n              atomic_max (&mp_.max_mmapped_mem, sum);\n\n              check_chunk (av, p);\n\n              return chunk2mem (p);\n            }\n        }\n    }\n\n  /* There are no usable arenas and mmap also failed.  */\n  if (av == NULL)\n    return 0;\n\n  /* Record incoming configuration of top */\n\n  old_top = av->top;\n  old_size = chunksize (old_top);\n  old_end = (char *) (chunk_at_offset (old_top, old_size));\n\n  brk = snd_brk = (char *) (MORECORE_FAILURE);\n\n  /*\n     If not the first time through, we require old_size to be\n     at least MINSIZE and to have prev_inuse set.\n   */\n\n  assert ((old_top == initial_top (av) && old_size == 0) ||\n          ((unsigned long) (old_size) >= MINSIZE &&\n           prev_inuse (old_top) &&\n           ((unsigned long) old_end & (pagesize - 1)) == 0));\n\n  /* Precondition: not enough current space to satisfy nb request */\n  assert ((unsigned long) (old_size) < (unsigned long) (nb + MINSIZE));\n\n\n  if (av != &main_arena)\n    {\n      heap_info *old_heap, *heap;\n      size_t old_heap_size;\n\n      /* First try to extend the current heap. */\n      old_heap = heap_for_ptr (old_top);\n      old_heap_size = old_heap->size;\n      if ((long) (MINSIZE + nb - old_size) > 0\n          && grow_heap (old_heap, MINSIZE + nb - old_size) == 0)\n        {\n          av->system_mem += old_heap->size - old_heap_size;\n          set_head (old_top, (((char *) old_heap + old_heap->size) - (char *) old_top)\n                    | PREV_INUSE);\n        }\n      else if ((heap = new_heap (nb + (MINSIZE + sizeof (*heap)), mp_.top_pad)))\n        {\n          /* Use a newly allocated heap.  */\n          heap->ar_ptr = av;\n          heap->prev = old_heap;\n          av->system_mem += heap->size;\n          /* Set up the new top.  */\n          top (av) = chunk_at_offset (heap, sizeof (*heap));\n          set_head (top (av), (heap->size - sizeof (*heap)) | PREV_INUSE);\n\n          /* Setup fencepost and free the old top chunk with a multiple of\n             MALLOC_ALIGNMENT in size. */\n          /* The fencepost takes at least MINSIZE bytes, because it might\n             become the top chunk again later.  Note that a footer is set\n             up, too, although the chunk is marked in use. */\n          old_size = (old_size - MINSIZE) & ~MALLOC_ALIGN_MASK;\n          set_head (chunk_at_offset (old_top, old_size + 2 * SIZE_SZ), 0 | PREV_INUSE);\n          if (old_size >= MINSIZE)\n            {\n              set_head (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ) | PREV_INUSE);\n              set_foot (chunk_at_offset (old_top, old_size), (2 * SIZE_SZ));\n              set_head (old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);\n              _int_free (av, old_top, 1);\n            }\n          else\n            {\n              set_head (old_top, (old_size + 2 * SIZE_SZ) | PREV_INUSE);\n              set_foot (old_top, (old_size + 2 * SIZE_SZ));\n            }\n        }\n      else if (!tried_mmap)\n        /* We can at least try to use to mmap memory.  */\n        goto try_mmap;\n    }\n  else     /* av == main_arena */\n\n\n    { /* Request enough space for nb + pad + overhead */\n      size = nb + mp_.top_pad + MINSIZE;\n\n      /*\n         If contiguous, we can subtract out existing space that we hope to\n         combine with new space. We add it back later only if\n         we don't actually get contiguous space.\n       */\n\n      if (contiguous (av))\n        size -= old_size;\n\n      /*\n         Round to a multiple of page size.\n         If MORECORE is not contiguous, this ensures that we only call it\n         with whole-page arguments.  And if MORECORE is contiguous and\n         this is not first time through, this preserves page-alignment of\n         previous calls. Otherwise, we correct to page-align below.\n       */\n\n      size = ALIGN_UP (size, pagesize);\n\n      /*\n         Don't try to call MORECORE if argument is so big as to appear\n         negative. Note that since mmap takes size_t arg, it may succeed\n         below even if we cannot call MORECORE.\n       */\n\n      if (size > 0)\n        {\n          brk = (char *) (MORECORE (size));\n          LIBC_PROBE (memory_sbrk_more, 2, brk, size);\n        }\n\n      if (brk != (char *) (MORECORE_FAILURE))\n        {\n          /* Call the `morecore' hook if necessary.  */\n          void (*hook) (void) = atomic_forced_read (__after_morecore_hook);\n          if (__builtin_expect (hook != NULL, 0))\n            (*hook)();\n        }\n      else\n        {\n          /*\n             If have mmap, try using it as a backup when MORECORE fails or\n             cannot be used. This is worth doing on systems that have \"holes\" in\n             address space, so sbrk cannot extend to give contiguous space, but\n             space is available elsewhere.  Note that we ignore mmap max count\n             and threshold limits, since the space will not be used as a\n             segregated mmap region.\n           */\n\n          /* Cannot merge with old top, so add its size back in */\n          if (contiguous (av))\n            size = ALIGN_UP (size + old_size, pagesize);\n\n          /* If we are relying on mmap as backup, then use larger units */\n          if ((unsigned long) (size) < (unsigned long) (MMAP_AS_MORECORE_SIZE))\n            size = MMAP_AS_MORECORE_SIZE;\n\n          /* Don't try if size wraps around 0 */\n          if ((unsigned long) (size) > (unsigned long) (nb))\n            {\n              char *mbrk = (char *) (MMAP (0, size, PROT_READ | PROT_WRITE, 0));\n\n              if (mbrk != MAP_FAILED)\n                {\n                  /* We do not need, and cannot use, another sbrk call to find end */\n                  brk = mbrk;\n                  snd_brk = brk + size;\n\n                  /*\n                     Record that we no longer have a contiguous sbrk region.\n                     After the first time mmap is used as backup, we do not\n                     ever rely on contiguous space since this could incorrectly\n                     bridge regions.\n                   */\n                  set_noncontiguous (av);\n                }\n            }\n        }\n\n      if (brk != (char *) (MORECORE_FAILURE))\n        {\n          if (mp_.sbrk_base == 0)\n            mp_.sbrk_base = brk;\n          av->system_mem += size;\n\n          /*\n             If MORECORE extends previous space, we can likewise extend top size.\n           */\n\n          if (brk == old_end && snd_brk == (char *) (MORECORE_FAILURE))\n            set_head (old_top, (size + old_size) | PREV_INUSE);\n\n          else if (contiguous (av) && old_size && brk < old_end)\n\t    /* Oops!  Someone else killed our space..  Can't touch anything.  */\n\t    malloc_printerr (\"break adjusted to free malloc space\");\n\n          /*\n             Otherwise, make adjustments:\n\n           * If the first time through or noncontiguous, we need to call sbrk\n              just to find out where the end of memory lies.\n\n           * We need to ensure that all returned chunks from malloc will meet\n              MALLOC_ALIGNMENT\n\n           * If there was an intervening foreign sbrk, we need to adjust sbrk\n              request size to account for fact that we will not be able to\n              combine new space with existing space in old_top.\n\n           * Almost all systems internally allocate whole pages at a time, in\n              which case we might as well use the whole last page of request.\n              So we allocate enough more memory to hit a page boundary now,\n              which in turn causes future contiguous calls to page-align.\n           */\n\n          else\n            {\n              front_misalign = 0;\n              end_misalign = 0;\n              correction = 0;\n              aligned_brk = brk;\n\n              /* handle contiguous cases */\n              if (contiguous (av))\n                {\n                  /* Count foreign sbrk as system_mem.  */\n                  if (old_size)\n                    av->system_mem += brk - old_end;\n\n                  /* Guarantee alignment of first new chunk made from this space */\n\n                  front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) & MALLOC_ALIGN_MASK;\n                  if (front_misalign > 0)\n                    {\n                      /*\n                         Skip over some bytes to arrive at an aligned position.\n                         We don't need to specially mark these wasted front bytes.\n                         They will never be accessed anyway because\n                         prev_inuse of av->top (and any chunk created from its start)\n                         is always true after initialization.\n                       */\n\n                      correction = MALLOC_ALIGNMENT - front_misalign;\n                      aligned_brk += correction;\n                    }\n\n                  /*\n                     If this isn't adjacent to existing space, then we will not\n                     be able to merge with old_top space, so must add to 2nd request.\n                   */\n\n                  correction += old_size;\n\n                  /* Extend the end address to hit a page boundary */\n                  end_misalign = (INTERNAL_SIZE_T) (brk + size + correction);\n                  correction += (ALIGN_UP (end_misalign, pagesize)) - end_misalign;\n\n                  assert (correction >= 0);\n                  snd_brk = (char *) (MORECORE (correction));\n\n                  /*\n                     If can't allocate correction, try to at least find out current\n                     brk.  It might be enough to proceed without failing.\n\n                     Note that if second sbrk did NOT fail, we assume that space\n                     is contiguous with first sbrk. This is a safe assumption unless\n                     program is multithreaded but doesn't use locks and a foreign sbrk\n                     occurred between our first and second calls.\n                   */\n\n                  if (snd_brk == (char *) (MORECORE_FAILURE))\n                    {\n                      correction = 0;\n                      snd_brk = (char *) (MORECORE (0));\n                    }\n                  else\n                    {\n                      /* Call the `morecore' hook if necessary.  */\n                      void (*hook) (void) = atomic_forced_read (__after_morecore_hook);\n                      if (__builtin_expect (hook != NULL, 0))\n                        (*hook)();\n                    }\n                }\n\n              /* handle non-contiguous cases */\n              else\n                {\n                  if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)\n                    /* MORECORE/mmap must correctly align */\n                    assert (((unsigned long) chunk2mem (brk) & MALLOC_ALIGN_MASK) == 0);\n                  else\n                    {\n                      front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) & MALLOC_ALIGN_MASK;\n                      if (front_misalign > 0)\n                        {\n                          /*\n                             Skip over some bytes to arrive at an aligned position.\n                             We don't need to specially mark these wasted front bytes.\n                             They will never be accessed anyway because\n                             prev_inuse of av->top (and any chunk created from its start)\n                             is always true after initialization.\n                           */\n\n                          aligned_brk += MALLOC_ALIGNMENT - front_misalign;\n                        }\n                    }\n\n                  /* Find out current end of memory */\n                  if (snd_brk == (char *) (MORECORE_FAILURE))\n                    {\n                      snd_brk = (char *) (MORECORE (0));\n                    }\n                }\n\n              /* Adjust top based on results of second sbrk */\n              if (snd_brk != (char *) (MORECORE_FAILURE))\n                {\n                  av->top = (mchunkptr) aligned_brk;\n                  set_head (av->top, (snd_brk - aligned_brk + correction) | PREV_INUSE);\n                  av->system_mem += correction;\n\n                  /*\n                     If not the first time through, we either have a\n                     gap due to foreign sbrk or a non-contiguous region.  Insert a\n                     double fencepost at old_top to prevent consolidation with space\n                     we don't own. These fenceposts are artificial chunks that are\n                     marked as inuse and are in any case too small to use.  We need\n                     two to make sizes and alignments work out.\n                   */\n\n                  if (old_size != 0)\n                    {\n                      /*\n                         Shrink old_top to insert fenceposts, keeping size a\n                         multiple of MALLOC_ALIGNMENT. We know there is at least\n                         enough space in old_top to do this.\n                       */\n                      old_size = (old_size - 4 * SIZE_SZ) & ~MALLOC_ALIGN_MASK;\n                      set_head (old_top, old_size | PREV_INUSE);\n\n                      /*\n                         Note that the following assignments completely overwrite\n                         old_top when old_size was previously MINSIZE.  This is\n                         intentional. We need the fencepost, even if old_top otherwise gets\n                         lost.\n                       */\n\t\t      set_head (chunk_at_offset (old_top, old_size),\n\t\t\t\t(2 * SIZE_SZ) | PREV_INUSE);\n\t\t      set_head (chunk_at_offset (old_top, old_size + 2 * SIZE_SZ),\n\t\t\t\t(2 * SIZE_SZ) | PREV_INUSE);\n\n                      /* If possible, release the rest. */\n                      if (old_size >= MINSIZE)\n                        {\n                          _int_free (av, old_top, 1);\n                        }\n                    }\n                }\n            }\n        }\n    } /* if (av !=  &main_arena) */\n\n  if ((unsigned long) av->system_mem > (unsigned long) (av->max_system_mem))\n    av->max_system_mem = av->system_mem;\n  check_malloc_state (av);\n\n  /* finally, do the allocation */\n  p = av->top;\n  size = chunksize (p);\n\n  /* check that one of the above allocation paths succeeded */\n  if ((unsigned long) (size) >= (unsigned long) (nb + MINSIZE))\n    {\n      remainder_size = size - nb;\n      remainder = chunk_at_offset (p, nb);\n      av->top = remainder;\n      set_head (p, nb | PREV_INUSE | (av != &main_arena ? NON_MAIN_ARENA : 0));\n      set_head (remainder, remainder_size | PREV_INUSE);\n      check_malloced_chunk (av, p, nb);\n      return chunk2mem (p);\n    }\n\n  /* catch all failure paths */\n  __set_errno (ENOMEM);\n  return 0;\n}\n\n\n/*\n   systrim is an inverse of sorts to sysmalloc.  It gives memory back\n   to the system (via negative arguments to sbrk) if there is unused\n   memory at the `high' end of the malloc pool. It is called\n   automatically by free() when top space exceeds the trim\n   threshold. It is also called by the public malloc_trim routine.  It\n   returns 1 if it actually released any memory, else 0.\n */\n\nstatic int\nsystrim (size_t pad, mstate av)\n{\n  long top_size;         /* Amount of top-most memory */\n  long extra;            /* Amount to release */\n  long released;         /* Amount actually released */\n  char *current_brk;     /* address returned by pre-check sbrk call */\n  char *new_brk;         /* address returned by post-check sbrk call */\n  size_t pagesize;\n  long top_area;\n\n  pagesize = GLRO (dl_pagesize);\n  top_size = chunksize (av->top);\n\n  top_area = top_size - MINSIZE - 1;\n  if (top_area <= pad)\n    return 0;\n\n  /* Release in pagesize units and round down to the nearest page.  */\n  extra = ALIGN_DOWN(top_area - pad, pagesize);\n\n  if (extra == 0)\n    return 0;\n\n  /*\n     Only proceed if end of memory is where we last set it.\n     This avoids problems if there were foreign sbrk calls.\n   */\n  current_brk = (char *) (MORECORE (0));\n  if (current_brk == (char *) (av->top) + top_size)\n    {\n      /*\n         Attempt to release memory. We ignore MORECORE return value,\n         and instead call again to find out where new end of memory is.\n         This avoids problems if first call releases less than we asked,\n         of if failure somehow altered brk value. (We could still\n         encounter problems if it altered brk in some very bad way,\n         but the only thing we can do is adjust anyway, which will cause\n         some downstream failure.)\n       */\n\n      MORECORE (-extra);\n      /* Call the `morecore' hook if necessary.  */\n      void (*hook) (void) = atomic_forced_read (__after_morecore_hook);\n      if (__builtin_expect (hook != NULL, 0))\n        (*hook)();\n      new_brk = (char *) (MORECORE (0));\n\n      LIBC_PROBE (memory_sbrk_less, 2, new_brk, extra);\n\n      if (new_brk != (char *) MORECORE_FAILURE)\n        {\n          released = (long) (current_brk - new_brk);\n\n          if (released != 0)\n            {\n              /* Success. Adjust top. */\n              av->system_mem -= released;\n              set_head (av->top, (top_size - released) | PREV_INUSE);\n              check_malloc_state (av);\n              return 1;\n            }\n        }\n    }\n  return 0;\n}\n\nstatic void\nmunmap_chunk (mchunkptr p)\n{\n  INTERNAL_SIZE_T size = chunksize (p);\n\n  assert (chunk_is_mmapped (p));\n\n  /* Do nothing if the chunk is a faked mmapped chunk in the dumped\n     main arena.  We never free this memory.  */\n  if (DUMPED_MAIN_ARENA_CHUNK (p))\n    return;\n\n  uintptr_t block = (uintptr_t) p - prev_size (p);\n  size_t total_size = prev_size (p) + size;\n  /* Unfortunately we have to do the compilers job by hand here.  Normally\n     we would test BLOCK and TOTAL-SIZE separately for compliance with the\n     page size.  But gcc does not recognize the optimization possibility\n     (in the moment at least) so we combine the two values into one before\n     the bit test.  */\n  if (__builtin_expect (((block | total_size) & (GLRO (dl_pagesize) - 1)) != 0, 0))\n    malloc_printerr (\"munmap_chunk(): invalid pointer\");\n\n  atomic_decrement (&mp_.n_mmaps);\n  atomic_add (&mp_.mmapped_mem, -total_size);\n\n  /* If munmap failed the process virtual memory address space is in a\n     bad shape.  Just leave the block hanging around, the process will\n     terminate shortly anyway since not much can be done.  */\n  __munmap ((char *) block, total_size);\n}\n\n#if HAVE_MREMAP\n\nstatic mchunkptr\nmremap_chunk (mchunkptr p, size_t new_size)\n{\n  size_t pagesize = GLRO (dl_pagesize);\n  INTERNAL_SIZE_T offset = prev_size (p);\n  INTERNAL_SIZE_T size = chunksize (p);\n  char *cp;\n\n  assert (chunk_is_mmapped (p));\n  assert (((size + offset) & (GLRO (dl_pagesize) - 1)) == 0);\n\n  /* Note the extra SIZE_SZ overhead as in mmap_chunk(). */\n  new_size = ALIGN_UP (new_size + offset + SIZE_SZ, pagesize);\n\n  /* No need to remap if the number of pages does not change.  */\n  if (size + offset == new_size)\n    return p;\n\n  cp = (char *) __mremap ((char *) p - offset, size + offset, new_size,\n                          MREMAP_MAYMOVE);\n\n  if (cp == MAP_FAILED)\n    return 0;\n\n  p = (mchunkptr) (cp + offset);\n\n  assert (aligned_OK (chunk2mem (p)));\n\n  assert (prev_size (p) == offset);\n  set_head (p, (new_size - offset) | IS_MMAPPED);\n\n  INTERNAL_SIZE_T new;\n  new = atomic_exchange_and_add (&mp_.mmapped_mem, new_size - size - offset)\n        + new_size - size - offset;\n  atomic_max (&mp_.max_mmapped_mem, new);\n  return p;\n}\n#endif /* HAVE_MREMAP */\n\n/*------------------------ Public wrappers. --------------------------------*/\n\n#if USE_TCACHE\n\n/* We overlay this structure on the user-data portion of a chunk when\n   the chunk is stored in the per-thread cache.  */\ntypedef struct tcache_entry\n{\n  struct tcache_entry *next;\n} tcache_entry;\n\n/* There is one of these for each thread, which contains the\n   per-thread cache (hence \"tcache_perthread_struct\").  Keeping\n   overall size low is mildly important.  Note that COUNTS and ENTRIES\n   are redundant (we could have just counted the linked list each\n   time), this is for performance reasons.  */\ntypedef struct tcache_perthread_struct\n{\n  char counts[TCACHE_MAX_BINS];\n  tcache_entry *entries[TCACHE_MAX_BINS];\n} tcache_perthread_struct;\n\nstatic __thread bool tcache_shutting_down = false;\nstatic __thread tcache_perthread_struct *tcache = NULL;\n\n/* Caller must ensure that we know tc_idx is valid and there's room\n   for more chunks.  */\nstatic __always_inline void\ntcache_put (mchunkptr chunk, size_t tc_idx)\n{\n  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);\n  assert (tc_idx < TCACHE_MAX_BINS);\n  e->next = tcache->entries[tc_idx];\n  tcache->entries[tc_idx] = e;\n  ++(tcache->counts[tc_idx]);\n}\n\n/* Caller must ensure that we know tc_idx is valid and there's\n   available chunks to remove.  */\nstatic __always_inline void *\ntcache_get (size_t tc_idx)\n{\n  tcache_entry *e = tcache->entries[tc_idx];\n  assert (tc_idx < TCACHE_MAX_BINS);\n  assert (tcache->entries[tc_idx] > 0);\n  tcache->entries[tc_idx] = e->next;\n  --(tcache->counts[tc_idx]);\n  return (void *) e;\n}\n\nstatic void\ntcache_thread_shutdown (void)\n{\n  int i;\n  tcache_perthread_struct *tcache_tmp = tcache;\n\n  if (!tcache)\n    return;\n\n  /* Disable the tcache and prevent it from being reinitialized.  */\n  tcache = NULL;\n  tcache_shutting_down = true;\n\n  /* Free all of the entries and the tcache itself back to the arena\n     heap for coalescing.  */\n  for (i = 0; i < TCACHE_MAX_BINS; ++i)\n    {\n      while (tcache_tmp->entries[i])\n\t{\n\t  tcache_entry *e = tcache_tmp->entries[i];\n\t  tcache_tmp->entries[i] = e->next;\n\t  __libc_free (e);\n\t}\n    }\n\n  __libc_free (tcache_tmp);\n}\n\nstatic void\ntcache_init(void)\n{\n  mstate ar_ptr;\n  void *victim = 0;\n  const size_t bytes = sizeof (tcache_perthread_struct);\n\n  if (tcache_shutting_down)\n    return;\n\n  arena_get (ar_ptr, bytes);\n  victim = _int_malloc (ar_ptr, bytes);\n  if (!victim && ar_ptr != NULL)\n    {\n      ar_ptr = arena_get_retry (ar_ptr, bytes);\n      victim = _int_malloc (ar_ptr, bytes);\n    }\n\n\n  if (ar_ptr != NULL)\n    __libc_lock_unlock (ar_ptr->mutex);\n\n  /* In a low memory situation, we may not be able to allocate memory\n     - in which case, we just keep trying later.  However, we\n     typically do this very early, so either there is sufficient\n     memory, or there isn't enough memory to do non-trivial\n     allocations anyway.  */\n  if (victim)\n    {\n      tcache = (tcache_perthread_struct *) victim;\n      memset (tcache, 0, sizeof (tcache_perthread_struct));\n    }\n\n}\n\n# define MAYBE_INIT_TCACHE() \\\n  if (__glibc_unlikely (tcache == NULL)) \\\n    tcache_init();\n\n#else  /* !USE_TCACHE */\n# define MAYBE_INIT_TCACHE()\n\nstatic void\ntcache_thread_shutdown (void)\n{\n  /* Nothing to do if there is no thread cache.  */\n}\n\n#endif /* !USE_TCACHE  */\n\nvoid *\n__libc_malloc (size_t bytes)\n{\n  mstate ar_ptr;\n  void *victim;\n\n  void *(*hook) (size_t, const void *)\n    = atomic_forced_read (__malloc_hook);\n  if (__builtin_expect (hook != NULL, 0))\n    return (*hook)(bytes, RETURN_ADDRESS (0));\n#if USE_TCACHE\n  /* int_free also calls request2size, be careful to not pad twice.  */\n  size_t tbytes;\n  checked_request2size (bytes, tbytes);\n  size_t tc_idx = csize2tidx (tbytes);\n\n  MAYBE_INIT_TCACHE ();\n\n  DIAG_PUSH_NEEDS_COMMENT;\n  if (tc_idx < mp_.tcache_bins\n      /*&& tc_idx < TCACHE_MAX_BINS*/ /* to appease gcc */\n      && tcache\n      && tcache->entries[tc_idx] != NULL)\n    {\n      return tcache_get (tc_idx);\n    }\n  DIAG_POP_NEEDS_COMMENT;\n#endif\n\n  if (SINGLE_THREAD_P)\n    {\n      victim = _int_malloc (&main_arena, bytes);\n      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||\n\t      &main_arena == arena_for_chunk (mem2chunk (victim)));\n      return victim;\n    }\n\n  arena_get (ar_ptr, bytes);\n\n  victim = _int_malloc (ar_ptr, bytes);\n  /* Retry with another arena only if we were able to find a usable arena\n     before.  */\n  if (!victim && ar_ptr != NULL)\n    {\n      LIBC_PROBE (memory_malloc_retry, 1, bytes);\n      ar_ptr = arena_get_retry (ar_ptr, bytes);\n      victim = _int_malloc (ar_ptr, bytes);\n    }\n\n  if (ar_ptr != NULL)\n    __libc_lock_unlock (ar_ptr->mutex);\n\n  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||\n          ar_ptr == arena_for_chunk (mem2chunk (victim)));\n  return victim;\n}\nlibc_hidden_def (__libc_malloc)\n\nvoid\n__libc_free (void *mem)\n{\n  mstate ar_ptr;\n  mchunkptr p;                          /* chunk corresponding to mem */\n\n  void (*hook) (void *, const void *)\n    = atomic_forced_read (__free_hook);\n  if (__builtin_expect (hook != NULL, 0))\n    {\n      (*hook)(mem, RETURN_ADDRESS (0));\n      return;\n    }\n\n  if (mem == 0)                              /* free(0) has no effect */\n    return;\n\n  p = mem2chunk (mem);\n\n  if (chunk_is_mmapped (p))                       /* release mmapped memory. */\n    {\n      /* See if the dynamic brk/mmap threshold needs adjusting.\n\t Dumped fake mmapped chunks do not affect the threshold.  */\n      if (!mp_.no_dyn_threshold\n          && chunksize_nomask (p) > mp_.mmap_threshold\n          && chunksize_nomask (p) <= DEFAULT_MMAP_THRESHOLD_MAX\n\t  && !DUMPED_MAIN_ARENA_CHUNK (p))\n        {\n          mp_.mmap_threshold = chunksize (p);\n          mp_.trim_threshold = 2 * mp_.mmap_threshold;\n          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,\n                      mp_.mmap_threshold, mp_.trim_threshold);\n        }\n      munmap_chunk (p);\n      return;\n    }\n\n  MAYBE_INIT_TCACHE ();\n\n  ar_ptr = arena_for_chunk (p);\n  _int_free (ar_ptr, p, 0);\n}\nlibc_hidden_def (__libc_free)\n\nvoid *\n__libc_realloc (void *oldmem, size_t bytes)\n{\n  mstate ar_ptr;\n  INTERNAL_SIZE_T nb;         /* padded request size */\n\n  void *newp;             /* chunk to return */\n\n  void *(*hook) (void *, size_t, const void *) =\n    atomic_forced_read (__realloc_hook);\n  if (__builtin_expect (hook != NULL, 0))\n    return (*hook)(oldmem, bytes, RETURN_ADDRESS (0));\n\n#if REALLOC_ZERO_BYTES_FREES\n  if (bytes == 0 && oldmem != NULL)\n    {\n      __libc_free (oldmem); return 0;\n    }\n#endif\n\n  /* realloc of null is supposed to be same as malloc */\n  if (oldmem == 0)\n    return __libc_malloc (bytes);\n\n  /* chunk corresponding to oldmem */\n  const mchunkptr oldp = mem2chunk (oldmem);\n  /* its size */\n  const INTERNAL_SIZE_T oldsize = chunksize (oldp);\n\n  if (chunk_is_mmapped (oldp))\n    ar_ptr = NULL;\n  else\n    {\n      MAYBE_INIT_TCACHE ();\n      ar_ptr = arena_for_chunk (oldp);\n    }\n\n  /* Little security check which won't hurt performance: the allocator\n     never wrapps around at the end of the address space.  Therefore\n     we can exclude some size values which might appear here by\n     accident or by \"design\" from some intruder.  We need to bypass\n     this check for dumped fake mmap chunks from the old main arena\n     because the new malloc may provide additional alignment.  */\n  if ((__builtin_expect ((uintptr_t) oldp > (uintptr_t) -oldsize, 0)\n       || __builtin_expect (misaligned_chunk (oldp), 0))\n      && !DUMPED_MAIN_ARENA_CHUNK (oldp))\n      malloc_printerr (\"realloc(): invalid pointer\");\n\n  checked_request2size (bytes, nb);\n\n  if (chunk_is_mmapped (oldp))\n    {\n      /* If this is a faked mmapped chunk from the dumped main arena,\n\t always make a copy (and do not free the old chunk).  */\n      if (DUMPED_MAIN_ARENA_CHUNK (oldp))\n\t{\n\t  /* Must alloc, copy, free. */\n\t  void *newmem = __libc_malloc (bytes);\n\t  if (newmem == 0)\n\t    return NULL;\n\t  /* Copy as many bytes as are available from the old chunk\n\t     and fit into the new size.  NB: The overhead for faked\n\t     mmapped chunks is only SIZE_SZ, not 2 * SIZE_SZ as for\n\t     regular mmapped chunks.  */\n\t  if (bytes > oldsize - SIZE_SZ)\n\t    bytes = oldsize - SIZE_SZ;\n\t  memcpy (newmem, oldmem, bytes);\n\t  return newmem;\n\t}\n\n      void *newmem;\n\n#if HAVE_MREMAP\n      newp = mremap_chunk (oldp, nb);\n      if (newp)\n        return chunk2mem (newp);\n#endif\n      /* Note the extra SIZE_SZ overhead. */\n      if (oldsize - SIZE_SZ >= nb)\n        return oldmem;                         /* do nothing */\n\n      /* Must alloc, copy, free. */\n      newmem = __libc_malloc (bytes);\n      if (newmem == 0)\n        return 0;              /* propagate failure */\n\n      memcpy (newmem, oldmem, oldsize - 2 * SIZE_SZ);\n      munmap_chunk (oldp);\n      return newmem;\n    }\n\n  if (SINGLE_THREAD_P)\n    {\n      newp = _int_realloc (ar_ptr, oldp, oldsize, nb);\n      assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||\n\t      ar_ptr == arena_for_chunk (mem2chunk (newp)));\n\n      return newp;\n    }\n\n  __libc_lock_lock (ar_ptr->mutex);\n\n  newp = _int_realloc (ar_ptr, oldp, oldsize, nb);\n\n  __libc_lock_unlock (ar_ptr->mutex);\n  assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||\n          ar_ptr == arena_for_chunk (mem2chunk (newp)));\n\n  if (newp == NULL)\n    {\n      /* Try harder to allocate memory in other arenas.  */\n      LIBC_PROBE (memory_realloc_retry, 2, bytes, oldmem);\n      newp = __libc_malloc (bytes);\n      if (newp != NULL)\n        {\n          memcpy (newp, oldmem, oldsize - SIZE_SZ);\n          _int_free (ar_ptr, oldp, 0);\n        }\n    }\n\n  return newp;\n}\nlibc_hidden_def (__libc_realloc)\n\nvoid *\n__libc_memalign (size_t alignment, size_t bytes)\n{\n  void *address = RETURN_ADDRESS (0);\n  return _mid_memalign (alignment, bytes, address);\n}\n\nstatic void *\n_mid_memalign (size_t alignment, size_t bytes, void *address)\n{\n  mstate ar_ptr;\n  void *p;\n\n  void *(*hook) (size_t, size_t, const void *) =\n    atomic_forced_read (__memalign_hook);\n  if (__builtin_expect (hook != NULL, 0))\n    return (*hook)(alignment, bytes, address);\n\n  /* If we need less alignment than we give anyway, just relay to malloc.  */\n  if (alignment <= MALLOC_ALIGNMENT)\n    return __libc_malloc (bytes);\n\n  /* Otherwise, ensure that it is at least a minimum chunk size */\n  if (alignment < MINSIZE)\n    alignment = MINSIZE;\n\n  /* If the alignment is greater than SIZE_MAX / 2 + 1 it cannot be a\n     power of 2 and will cause overflow in the check below.  */\n  if (alignment > SIZE_MAX / 2 + 1)\n    {\n      __set_errno (EINVAL);\n      return 0;\n    }\n\n  /* Check for overflow.  */\n  if (bytes > SIZE_MAX - alignment - MINSIZE)\n    {\n      __set_errno (ENOMEM);\n      return 0;\n    }\n\n\n  /* Make sure alignment is power of 2.  */\n  if (!powerof2 (alignment))\n    {\n      size_t a = MALLOC_ALIGNMENT * 2;\n      while (a < alignment)\n        a <<= 1;\n      alignment = a;\n    }\n\n  if (SINGLE_THREAD_P)\n    {\n      p = _int_memalign (&main_arena, alignment, bytes);\n      assert (!p || chunk_is_mmapped (mem2chunk (p)) ||\n\t      &main_arena == arena_for_chunk (mem2chunk (p)));\n\n      return p;\n    }\n\n  arena_get (ar_ptr, bytes + alignment + MINSIZE);\n\n  p = _int_memalign (ar_ptr, alignment, bytes);\n  if (!p && ar_ptr != NULL)\n    {\n      LIBC_PROBE (memory_memalign_retry, 2, bytes, alignment);\n      ar_ptr = arena_get_retry (ar_ptr, bytes);\n      p = _int_memalign (ar_ptr, alignment, bytes);\n    }\n\n  if (ar_ptr != NULL)\n    __libc_lock_unlock (ar_ptr->mutex);\n\n  assert (!p || chunk_is_mmapped (mem2chunk (p)) ||\n          ar_ptr == arena_for_chunk (mem2chunk (p)));\n  return p;\n}\n/* For ISO C11.  */\nweak_alias (__libc_memalign, aligned_alloc)\nlibc_hidden_def (__libc_memalign)\n\nvoid *\n__libc_valloc (size_t bytes)\n{\n  if (__malloc_initialized < 0)\n    ptmalloc_init ();\n\n  void *address = RETURN_ADDRESS (0);\n  size_t pagesize = GLRO (dl_pagesize);\n  return _mid_memalign (pagesize, bytes, address);\n}\n\nvoid *\n__libc_pvalloc (size_t bytes)\n{\n  if (__malloc_initialized < 0)\n    ptmalloc_init ();\n\n  void *address = RETURN_ADDRESS (0);\n  size_t pagesize = GLRO (dl_pagesize);\n  size_t rounded_bytes = ALIGN_UP (bytes, pagesize);\n\n  /* Check for overflow.  */\n  if (bytes > SIZE_MAX - 2 * pagesize - MINSIZE)\n    {\n      __set_errno (ENOMEM);\n      return 0;\n    }\n\n  return _mid_memalign (pagesize, rounded_bytes, address);\n}\n\nvoid *\n__libc_calloc (size_t n, size_t elem_size)\n{\n  mstate av;\n  mchunkptr oldtop, p;\n  INTERNAL_SIZE_T bytes, sz, csz, oldtopsize;\n  void *mem;\n  unsigned long clearsize;\n  unsigned long nclears;\n  INTERNAL_SIZE_T *d;\n\n  /* size_t is unsigned so the behavior on overflow is defined.  */\n  bytes = n * elem_size;\n#define HALF_INTERNAL_SIZE_T \\\n  (((INTERNAL_SIZE_T) 1) << (8 * sizeof (INTERNAL_SIZE_T) / 2))\n  if (__builtin_expect ((n | elem_size) >= HALF_INTERNAL_SIZE_T, 0))\n    {\n      if (elem_size != 0 && bytes / elem_size != n)\n        {\n          __set_errno (ENOMEM);\n          return 0;\n        }\n    }\n\n  void *(*hook) (size_t, const void *) =\n    atomic_forced_read (__malloc_hook);\n  if (__builtin_expect (hook != NULL, 0))\n    {\n      sz = bytes;\n      mem = (*hook)(sz, RETURN_ADDRESS (0));\n      if (mem == 0)\n        return 0;\n\n      return memset (mem, 0, sz);\n    }\n\n  sz = bytes;\n\n  MAYBE_INIT_TCACHE ();\n\n  if (SINGLE_THREAD_P)\n    av = &main_arena;\n  else\n    arena_get (av, sz);\n\n  if (av)\n    {\n      /* Check if we hand out the top chunk, in which case there may be no\n\t need to clear. */\n#if MORECORE_CLEARS\n      oldtop = top (av);\n      oldtopsize = chunksize (top (av));\n# if MORECORE_CLEARS < 2\n      /* Only newly allocated memory is guaranteed to be cleared.  */\n      if (av == &main_arena &&\n\t  oldtopsize < mp_.sbrk_base + av->max_system_mem - (char *) oldtop)\n\toldtopsize = (mp_.sbrk_base + av->max_system_mem - (char *) oldtop);\n# endif\n      if (av != &main_arena)\n\t{\n\t  heap_info *heap = heap_for_ptr (oldtop);\n\t  if (oldtopsize < (char *) heap + heap->mprotect_size - (char *) oldtop)\n\t    oldtopsize = (char *) heap + heap->mprotect_size - (char *) oldtop;\n\t}\n#endif\n    }\n  else\n    {\n      /* No usable arenas.  */\n      oldtop = 0;\n      oldtopsize = 0;\n    }\n  mem = _int_malloc (av, sz);\n\n  assert (!mem || chunk_is_mmapped (mem2chunk (mem)) ||\n          av == arena_for_chunk (mem2chunk (mem)));\n\n  if (!SINGLE_THREAD_P)\n    {\n      if (mem == 0 && av != NULL)\n\t{\n\t  LIBC_PROBE (memory_calloc_retry, 1, sz);\n\t  av = arena_get_retry (av, sz);\n\t  mem = _int_malloc (av, sz);\n\t}\n\n      if (av != NULL)\n\t__libc_lock_unlock (av->mutex);\n    }\n\n  /* Allocation failed even after a retry.  */\n  if (mem == 0)\n    return 0;\n\n  p = mem2chunk (mem);\n\n  /* Two optional cases in which clearing not necessary */\n  if (chunk_is_mmapped (p))\n    {\n      if (__builtin_expect (perturb_byte, 0))\n        return memset (mem, 0, sz);\n\n      return mem;\n    }\n\n  csz = chunksize (p);\n\n#if MORECORE_CLEARS\n  if (perturb_byte == 0 && (p == oldtop && csz > oldtopsize))\n    {\n      /* clear only the bytes from non-freshly-sbrked memory */\n      csz = oldtopsize;\n    }\n#endif\n\n  /* Unroll clear of <= 36 bytes (72 if 8byte sizes).  We know that\n     contents have an odd number of INTERNAL_SIZE_T-sized words;\n     minimally 3.  */\n  d = (INTERNAL_SIZE_T *) mem;\n  clearsize = csz - SIZE_SZ;\n  nclears = clearsize / sizeof (INTERNAL_SIZE_T);\n  assert (nclears >= 3);\n\n  if (nclears > 9)\n    return memset (d, 0, clearsize);\n\n  else\n    {\n      *(d + 0) = 0;\n      *(d + 1) = 0;\n      *(d + 2) = 0;\n      if (nclears > 4)\n        {\n          *(d + 3) = 0;\n          *(d + 4) = 0;\n          if (nclears > 6)\n            {\n              *(d + 5) = 0;\n              *(d + 6) = 0;\n              if (nclears > 8)\n                {\n                  *(d + 7) = 0;\n                  *(d + 8) = 0;\n                }\n            }\n        }\n    }\n\n  return mem;\n}\n\n/*\n   ------------------------------ malloc ------------------------------\n */\n\nstatic void *\n_int_malloc (mstate av, size_t bytes)\n{\n  INTERNAL_SIZE_T nb;               /* normalized request size */\n  unsigned int idx;                 /* associated bin index */\n  mbinptr bin;                      /* associated bin */\n\n  mchunkptr victim;                 /* inspected/selected chunk */\n  INTERNAL_SIZE_T size;             /* its size */\n  int victim_index;                 /* its bin index */\n\n  mchunkptr remainder;              /* remainder from a split */\n  unsigned long remainder_size;     /* its size */\n\n  unsigned int block;               /* bit map traverser */\n  unsigned int bit;                 /* bit map traverser */\n  unsigned int map;                 /* current word of binmap */\n\n  mchunkptr fwd;                    /* misc temp for linking */\n  mchunkptr bck;                    /* misc temp for linking */\n\n#if USE_TCACHE\n  size_t tcache_unsorted_count;\t    /* count of unsorted chunks processed */\n#endif\n\n  /*\n     Convert request size to internal form by adding SIZE_SZ bytes\n     overhead plus possibly more to obtain necessary alignment and/or\n     to obtain a size of at least MINSIZE, the smallest allocatable\n     size. Also, checked_request2size traps (returning 0) request sizes\n     that are so large that they wrap around zero when padded and\n     aligned.\n   */\n\n  checked_request2size (bytes, nb);\n\n  /* There are no usable arenas.  Fall back to sysmalloc to get a chunk from\n     mmap.  */\n  if (__glibc_unlikely (av == NULL))\n    {\n      void *p = sysmalloc (nb, av);\n      if (p != NULL)\n\talloc_perturb (p, bytes);\n      return p;\n    }\n\n  /*\n     If the size qualifies as a fastbin, first check corresponding bin.\n     This code is safe to execute even if av is not yet initialized, so we\n     can try it without checking, which saves some time on this fast path.\n   */\n\n#define REMOVE_FB(fb, victim, pp)\t\t\t\\\n  do\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\\\n      victim = pp;\t\t\t\t\t\\\n      if (victim == NULL)\t\t\t\t\\\n\tbreak;\t\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\\\n  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim->fd, victim)) \\\n\t != victim);\t\t\t\t\t\\\n\n  if ((unsigned long) (nb) <= (unsigned long) (get_max_fast ()))\n    {\n      idx = fastbin_index (nb);\n      mfastbinptr *fb = &fastbin (av, idx);\n      mchunkptr pp;\n      victim = *fb;\n\n      if (victim != NULL)\n\t{\n\t  if (SINGLE_THREAD_P)\n\t    *fb = victim->fd;\n\t  else\n\t    REMOVE_FB (fb, pp, victim);\n\t  if (__glibc_likely (victim != NULL))\n\t    {\n\t      size_t victim_idx = fastbin_index (chunksize (victim));\n\t      if (__builtin_expect (victim_idx != idx, 0))\n\t\tmalloc_printerr (\"malloc(): memory corruption (fast)\");\n\t      check_remalloced_chunk (av, victim, nb);\n#if USE_TCACHE\n\t      /* While we're here, if we see other chunks of the same size,\n\t\t stash them in the tcache.  */\n\t      size_t tc_idx = csize2tidx (nb);\n\t      if (tcache && tc_idx < mp_.tcache_bins)\n\t\t{\n\t\t  mchunkptr tc_victim;\n\n\t\t  /* While bin not empty and tcache not full, copy chunks.  */\n\t\t  while (tcache->counts[tc_idx] < mp_.tcache_count\n\t\t\t && (tc_victim = *fb) != NULL)\n\t\t    {\n\t\t      if (SINGLE_THREAD_P)\n\t\t\t*fb = tc_victim->fd;\n\t\t      else\n\t\t\t{\n\t\t\t  REMOVE_FB (fb, pp, tc_victim);\n\t\t\t  if (__glibc_unlikely (tc_victim == NULL))\n\t\t\t    break;\n\t\t\t}\n\t\t      tcache_put (tc_victim, tc_idx);\n\t\t    }\n\t\t}\n#endif\n\t      void *p = chunk2mem (victim);\n\t      alloc_perturb (p, bytes);\n\t      return p;\n\t    }\n\t}\n    }\n\n  /*\n     If a small request, check regular bin.  Since these \"smallbins\"\n     hold one size each, no searching within bins is necessary.\n     (For a large request, we need to wait until unsorted chunks are\n     processed to find best fit. But for small ones, fits are exact\n     anyway, so we can check now, which is faster.)\n   */\n\n  if (in_smallbin_range (nb))\n    {\n      idx = smallbin_index (nb);\n      bin = bin_at (av, idx);\n\n      if ((victim = last (bin)) != bin)\n        {\n          bck = victim->bk;\n\t  if (__glibc_unlikely (bck->fd != victim))\n\t    malloc_printerr (\"malloc(): smallbin double linked list corrupted\");\n          set_inuse_bit_at_offset (victim, nb);\n          bin->bk = bck;\n          bck->fd = bin;\n\n          if (av != &main_arena)\n\t    set_non_main_arena (victim);\n          check_malloced_chunk (av, victim, nb);\n#if USE_TCACHE\n\t  /* While we're here, if we see other chunks of the same size,\n\t     stash them in the tcache.  */\n\t  size_t tc_idx = csize2tidx (nb);\n\t  if (tcache && tc_idx < mp_.tcache_bins)\n\t    {\n\t      mchunkptr tc_victim;\n\n\t      /* While bin not empty and tcache not full, copy chunks over.  */\n\t      while (tcache->counts[tc_idx] < mp_.tcache_count\n\t\t     && (tc_victim = last (bin)) != bin)\n\t\t{\n\t\t  if (tc_victim != 0)\n\t\t    {\n\t\t      bck = tc_victim->bk;\n\t\t      set_inuse_bit_at_offset (tc_victim, nb);\n\t\t      if (av != &main_arena)\n\t\t\tset_non_main_arena (tc_victim);\n\t\t      bin->bk = bck;\n\t\t      bck->fd = bin;\n\n\t\t      tcache_put (tc_victim, tc_idx);\n\t            }\n\t\t}\n\t    }\n#endif\n          void *p = chunk2mem (victim);\n          alloc_perturb (p, bytes);\n          return p;\n        }\n    }\n\n  /*\n     If this is a large request, consolidate fastbins before continuing.\n     While it might look excessive to kill all fastbins before\n     even seeing if there is space available, this avoids\n     fragmentation problems normally associated with fastbins.\n     Also, in practice, programs tend to have runs of either small or\n     large requests, but less often mixtures, so consolidation is not\n     invoked all that often in most programs. And the programs that\n     it is called frequently in otherwise tend to fragment.\n   */\n\n  else\n    {\n      idx = largebin_index (nb);\n      if (atomic_load_relaxed (&av->have_fastchunks))\n        malloc_consolidate (av);\n    }\n\n  /*\n     Process recently freed or remaindered chunks, taking one only if\n     it is exact fit, or, if this a small request, the chunk is remainder from\n     the most recent non-exact fit.  Place other traversed chunks in\n     bins.  Note that this step is the only place in any routine where\n     chunks are placed in bins.\n\n     The outer loop here is needed because we might not realize until\n     near the end of malloc that we should have consolidated, so must\n     do so and retry. This happens at most once, and only when we would\n     otherwise need to expand memory to service a \"small\" request.\n   */\n\n#if USE_TCACHE\n  INTERNAL_SIZE_T tcache_nb = 0;\n  size_t tc_idx = csize2tidx (nb);\n  if (tcache && tc_idx < mp_.tcache_bins)\n    tcache_nb = nb;\n  int return_cached = 0;\n\n  tcache_unsorted_count = 0;\n#endif\n\n  for (;; )\n    {\n      int iters = 0;\n      while ((victim = unsorted_chunks (av)->bk) != unsorted_chunks (av))\n        {\n          bck = victim->bk;\n          size = chunksize (victim);\n          mchunkptr next = chunk_at_offset (victim, size);\n\n          if (__glibc_unlikely (size <= 2 * SIZE_SZ)\n              || __glibc_unlikely (size > av->system_mem))\n            malloc_printerr (\"malloc(): invalid size (unsorted)\");\n          if (__glibc_unlikely (chunksize_nomask (next) < 2 * SIZE_SZ)\n              || __glibc_unlikely (chunksize_nomask (next) > av->system_mem))\n            malloc_printerr (\"malloc(): invalid next size (unsorted)\");\n          if (__glibc_unlikely ((prev_size (next) & ~(SIZE_BITS)) != size))\n            malloc_printerr (\"malloc(): mismatching next->prev_size (unsorted)\");\n          if (__glibc_unlikely (bck->fd != victim)\n              || __glibc_unlikely (victim->fd != unsorted_chunks (av)))\n            malloc_printerr (\"malloc(): unsorted double linked list corrupted\");\n          if (__glibc_unlikely (prev_inuse (next)))\n            malloc_printerr (\"malloc(): invalid next->prev_inuse (unsorted)\");\n\n          /*\n             If a small request, try to use last remainder if it is the\n             only chunk in unsorted bin.  This helps promote locality for\n             runs of consecutive small requests. This is the only\n             exception to best-fit, and applies only when there is\n             no exact fit for a small chunk.\n           */\n\n          if (in_smallbin_range (nb) &&\n              bck == unsorted_chunks (av) &&\n              victim == av->last_remainder &&\n              (unsigned long) (size) > (unsigned long) (nb + MINSIZE))\n            {\n              /* split and reattach remainder */\n              remainder_size = size - nb;\n              remainder = chunk_at_offset (victim, nb);\n              unsorted_chunks (av)->bk = unsorted_chunks (av)->fd = remainder;\n              av->last_remainder = remainder;\n              remainder->bk = remainder->fd = unsorted_chunks (av);\n              if (!in_smallbin_range (remainder_size))\n                {\n                  remainder->fd_nextsize = NULL;\n                  remainder->bk_nextsize = NULL;\n                }\n\n              set_head (victim, nb | PREV_INUSE |\n                        (av != &main_arena ? NON_MAIN_ARENA : 0));\n              set_head (remainder, remainder_size | PREV_INUSE);\n              set_foot (remainder, remainder_size);\n\n              check_malloced_chunk (av, victim, nb);\n              void *p = chunk2mem (victim);\n              alloc_perturb (p, bytes);\n              return p;\n            }\n\n          /* remove from unsorted list */\n          if (__glibc_unlikely (bck->fd != victim))\n            malloc_printerr (\"malloc(): corrupted unsorted chunks 3\");\n          unsorted_chunks (av)->bk = bck;\n          bck->fd = unsorted_chunks (av);\n\n          /* Take now instead of binning if exact fit */\n\n          if (size == nb)\n            {\n              set_inuse_bit_at_offset (victim, size);\n              if (av != &main_arena)\n\t\tset_non_main_arena (victim);\n#if USE_TCACHE\n\t      /* Fill cache first, return to user only if cache fills.\n\t\t We may return one of these chunks later.  */\n\t      if (tcache_nb\n\t\t  && tcache->counts[tc_idx] < mp_.tcache_count)\n\t\t{\n\t\t  tcache_put (victim, tc_idx);\n\t\t  return_cached = 1;\n\t\t  continue;\n\t\t}\n\t      else\n\t\t{\n#endif\n              check_malloced_chunk (av, victim, nb);\n              void *p = chunk2mem (victim);\n              alloc_perturb (p, bytes);\n              return p;\n#if USE_TCACHE\n\t\t}\n#endif\n            }\n\n          /* place chunk in bin */\n\n          if (in_smallbin_range (size))\n            {\n              victim_index = smallbin_index (size);\n              bck = bin_at (av, victim_index);\n              fwd = bck->fd;\n            }\n          else\n            {\n              victim_index = largebin_index (size);\n              bck = bin_at (av, victim_index);\n              fwd = bck->fd;\n\n              /* maintain large bins in sorted order */\n              if (fwd != bck)\n                {\n                  /* Or with inuse bit to speed comparisons */\n                  size |= PREV_INUSE;\n                  /* if smaller than smallest, bypass loop below */\n                  assert (chunk_main_arena (bck->bk));\n                  if ((unsigned long) (size)\n\t\t      < (unsigned long) chunksize_nomask (bck->bk))\n                    {\n                      fwd = bck;\n                      bck = bck->bk;\n\n                      victim->fd_nextsize = fwd->fd;\n                      victim->bk_nextsize = fwd->fd->bk_nextsize;\n                      fwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim;\n                    }\n                  else\n                    {\n                      assert (chunk_main_arena (fwd));\n                      while ((unsigned long) size < chunksize_nomask (fwd))\n                        {\n                          fwd = fwd->fd_nextsize;\n\t\t\t  assert (chunk_main_arena (fwd));\n                        }\n\n                      if ((unsigned long) size\n\t\t\t  == (unsigned long) chunksize_nomask (fwd))\n                        /* Always insert in the second position.  */\n                        fwd = fwd->fd;\n                      else\n                        {\n                          victim->fd_nextsize = fwd;\n                          victim->bk_nextsize = fwd->bk_nextsize;\n                          fwd->bk_nextsize = victim;\n                          victim->bk_nextsize->fd_nextsize = victim;\n                        }\n                      bck = fwd->bk;\n                    }\n                }\n              else\n                victim->fd_nextsize = victim->bk_nextsize = victim;\n            }\n\n          mark_bin (av, victim_index);\n          victim->bk = bck;\n          victim->fd = fwd;\n          fwd->bk = victim;\n          bck->fd = victim;\n\n#if USE_TCACHE\n      /* If we've processed as many chunks as we're allowed while\n\t filling the cache, return one of the cached ones.  */\n      ++tcache_unsorted_count;\n      if (return_cached\n\t  && mp_.tcache_unsorted_limit > 0\n\t  && tcache_unsorted_count > mp_.tcache_unsorted_limit)\n\t{\n\t  return tcache_get (tc_idx);\n\t}\n#endif\n\n#define MAX_ITERS       10000\n          if (++iters >= MAX_ITERS)\n            break;\n        }\n\n#if USE_TCACHE\n      /* If all the small chunks we found ended up cached, return one now.  */\n      if (return_cached)\n\t{\n\t  return tcache_get (tc_idx);\n\t}\n#endif\n\n      /*\n         If a large request, scan through the chunks of current bin in\n         sorted order to find smallest that fits.  Use the skip list for this.\n       */\n\n      if (!in_smallbin_range (nb))\n        {\n          bin = bin_at (av, idx);\n\n          /* skip scan if empty or largest chunk is too small */\n          if ((victim = first (bin)) != bin\n\t      && (unsigned long) chunksize_nomask (victim)\n\t        >= (unsigned long) (nb))\n            {\n              victim = victim->bk_nextsize;\n              while (((unsigned long) (size = chunksize (victim)) <\n                      (unsigned long) (nb)))\n                victim = victim->bk_nextsize;\n\n              /* Avoid removing the first entry for a size so that the skip\n                 list does not have to be rerouted.  */\n              if (victim != last (bin)\n\t\t  && chunksize_nomask (victim)\n\t\t    == chunksize_nomask (victim->fd))\n                victim = victim->fd;\n\n              remainder_size = size - nb;\n              unlink (av, victim, bck, fwd);\n\n              /* Exhaust */\n              if (remainder_size < MINSIZE)\n                {\n                  set_inuse_bit_at_offset (victim, size);\n                  if (av != &main_arena)\n\t\t    set_non_main_arena (victim);\n                }\n              /* Split */\n              else\n                {\n                  remainder = chunk_at_offset (victim, nb);\n                  /* We cannot assume the unsorted list is empty and therefore\n                     have to perform a complete insert here.  */\n                  bck = unsorted_chunks (av);\n                  fwd = bck->fd;\n\t\t  if (__glibc_unlikely (fwd->bk != bck))\n\t\t    malloc_printerr (\"malloc(): corrupted unsorted chunks\");\n                  remainder->bk = bck;\n                  remainder->fd = fwd;\n                  bck->fd = remainder;\n                  fwd->bk = remainder;\n                  if (!in_smallbin_range (remainder_size))\n                    {\n                      remainder->fd_nextsize = NULL;\n                      remainder->bk_nextsize = NULL;\n                    }\n                  set_head (victim, nb | PREV_INUSE |\n                            (av != &main_arena ? NON_MAIN_ARENA : 0));\n                  set_head (remainder, remainder_size | PREV_INUSE);\n                  set_foot (remainder, remainder_size);\n                }\n              check_malloced_chunk (av, victim, nb);\n              void *p = chunk2mem (victim);\n              alloc_perturb (p, bytes);\n              return p;\n            }\n        }\n\n      /*\n         Search for a chunk by scanning bins, starting with next largest\n         bin. This search is strictly by best-fit; i.e., the smallest\n         (with ties going to approximately the least recently used) chunk\n         that fits is selected.\n\n         The bitmap avoids needing to check that most blocks are nonempty.\n         The particular case of skipping all bins during warm-up phases\n         when no chunks have been returned yet is faster than it might look.\n       */\n\n      ++idx;\n      bin = bin_at (av, idx);\n      block = idx2block (idx);\n      map = av->binmap[block];\n      bit = idx2bit (idx);\n\n      for (;; )\n        {\n          /* Skip rest of block if there are no more set bits in this block.  */\n          if (bit > map || bit == 0)\n            {\n              do\n                {\n                  if (++block >= BINMAPSIZE) /* out of bins */\n                    goto use_top;\n                }\n              while ((map = av->binmap[block]) == 0);\n\n              bin = bin_at (av, (block << BINMAPSHIFT));\n              bit = 1;\n            }\n\n          /* Advance to bin with set bit. There must be one. */\n          while ((bit & map) == 0)\n            {\n              bin = next_bin (bin);\n              bit <<= 1;\n              assert (bit != 0);\n            }\n\n          /* Inspect the bin. It is likely to be non-empty */\n          victim = last (bin);\n\n          /*  If a false alarm (empty bin), clear the bit. */\n          if (victim == bin)\n            {\n              av->binmap[block] = map &= ~bit; /* Write through */\n              bin = next_bin (bin);\n              bit <<= 1;\n            }\n\n          else\n            {\n              size = chunksize (victim);\n\n              /*  We know the first chunk in this bin is big enough to use. */\n              assert ((unsigned long) (size) >= (unsigned long) (nb));\n\n              remainder_size = size - nb;\n\n              /* unlink */\n              unlink (av, victim, bck, fwd);\n\n              /* Exhaust */\n              if (remainder_size < MINSIZE)\n                {\n                  set_inuse_bit_at_offset (victim, size);\n                  if (av != &main_arena)\n\t\t    set_non_main_arena (victim);\n                }\n\n              /* Split */\n              else\n                {\n                  remainder = chunk_at_offset (victim, nb);\n\n                  /* We cannot assume the unsorted list is empty and therefore\n                     have to perform a complete insert here.  */\n                  bck = unsorted_chunks (av);\n                  fwd = bck->fd;\n\t\t  if (__glibc_unlikely (fwd->bk != bck))\n\t\t    malloc_printerr (\"malloc(): corrupted unsorted chunks 2\");\n                  remainder->bk = bck;\n                  remainder->fd = fwd;\n                  bck->fd = remainder;\n                  fwd->bk = remainder;\n\n                  /* advertise as last remainder */\n                  if (in_smallbin_range (nb))\n                    av->last_remainder = remainder;\n                  if (!in_smallbin_range (remainder_size))\n                    {\n                      remainder->fd_nextsize = NULL;\n                      remainder->bk_nextsize = NULL;\n                    }\n                  set_head (victim, nb | PREV_INUSE |\n                            (av != &main_arena ? NON_MAIN_ARENA : 0));\n                  set_head (remainder, remainder_size | PREV_INUSE);\n                  set_foot (remainder, remainder_size);\n                }\n              check_malloced_chunk (av, victim, nb);\n              void *p = chunk2mem (victim);\n              alloc_perturb (p, bytes);\n              return p;\n            }\n        }\n\n    use_top:\n      /*\n         If large enough, split off the chunk bordering the end of memory\n         (held in av->top). Note that this is in accord with the best-fit\n         search rule.  In effect, av->top is treated as larger (and thus\n         less well fitting) than any other available chunk since it can\n         be extended to be as large as necessary (up to system\n         limitations).\n\n         We require that av->top always exists (i.e., has size >=\n         MINSIZE) after initialization, so if it would otherwise be\n         exhausted by current request, it is replenished. (The main\n         reason for ensuring it exists is that we may need MINSIZE space\n         to put in fenceposts in sysmalloc.)\n       */\n\n      victim = av->top;\n      size = chunksize (victim);\n\n      if (__glibc_unlikely (size > av->system_mem))\n        malloc_printerr (\"malloc(): corrupted top size\");\n\n      if ((unsigned long) (size) >= (unsigned long) (nb + MINSIZE))\n        {\n          remainder_size = size - nb;\n          remainder = chunk_at_offset (victim, nb);\n          av->top = remainder;\n          set_head (victim, nb | PREV_INUSE |\n                    (av != &main_arena ? NON_MAIN_ARENA : 0));\n          set_head (remainder, remainder_size | PREV_INUSE);\n\n          check_malloced_chunk (av, victim, nb);\n          void *p = chunk2mem (victim);\n          alloc_perturb (p, bytes);\n          return p;\n        }\n\n      /* When we are using atomic ops to free fast chunks we can get\n         here for all block sizes.  */\n      else if (atomic_load_relaxed (&av->have_fastchunks))\n        {\n          malloc_consolidate (av);\n          /* restore original bin index */\n          if (in_smallbin_range (nb))\n            idx = smallbin_index (nb);\n          else\n            idx = largebin_index (nb);\n        }\n\n      /*\n         Otherwise, relay to handle system-dependent cases\n       */\n      else\n        {\n          void *p = sysmalloc (nb, av);\n          if (p != NULL)\n            alloc_perturb (p, bytes);\n          return p;\n        }\n    }\n}\n\n/*\n   ------------------------------ free ------------------------------\n */\n\nstatic void\n_int_free (mstate av, mchunkptr p, int have_lock)\n{\n  INTERNAL_SIZE_T size;        /* its size */\n  mfastbinptr *fb;             /* associated fastbin */\n  mchunkptr nextchunk;         /* next contiguous chunk */\n  INTERNAL_SIZE_T nextsize;    /* its size */\n  int nextinuse;               /* true if nextchunk is used */\n  INTERNAL_SIZE_T prevsize;    /* size of previous contiguous chunk */\n  mchunkptr bck;               /* misc temp for linking */\n  mchunkptr fwd;               /* misc temp for linking */\n\n  size = chunksize (p);\n\n  /* Little security check which won't hurt performance: the\n     allocator never wrapps around at the end of the address space.\n     Therefore we can exclude some size values which might appear\n     here by accident or by \"design\" from some intruder.  */\n  if (__builtin_expect ((uintptr_t) p > (uintptr_t) -size, 0)\n      || __builtin_expect (misaligned_chunk (p), 0))\n    malloc_printerr (\"free(): invalid pointer\");\n  /* We know that each chunk is at least MINSIZE bytes in size or a\n     multiple of MALLOC_ALIGNMENT.  */\n  if (__glibc_unlikely (size < MINSIZE || !aligned_OK (size)))\n    malloc_printerr (\"free(): invalid size\");\n\n  check_inuse_chunk(av, p);\n\n#if USE_TCACHE\n  {\n    size_t tc_idx = csize2tidx (size);\n\n    if (tcache\n\t&& tc_idx < mp_.tcache_bins\n\t&& tcache->counts[tc_idx] < mp_.tcache_count)\n      {\n\ttcache_put (p, tc_idx);\n\treturn;\n      }\n  }\n#endif\n\n  /*\n    If eligible, place chunk on a fastbin so it can be found\n    and used quickly in malloc.\n  */\n\n  if ((unsigned long)(size) <= (unsigned long)(get_max_fast ())\n\n#if TRIM_FASTBINS\n      /*\n\tIf TRIM_FASTBINS set, don't place chunks\n\tbordering top into fastbins\n      */\n      && (chunk_at_offset(p, size) != av->top)\n#endif\n      ) {\n\n    if (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))\n\t\t\t  <= 2 * SIZE_SZ, 0)\n\t|| __builtin_expect (chunksize (chunk_at_offset (p, size))\n\t\t\t     >= av->system_mem, 0))\n      {\n\tbool fail = true;\n\t/* We might not have a lock at this point and concurrent modifications\n\t   of system_mem might result in a false positive.  Redo the test after\n\t   getting the lock.  */\n\tif (!have_lock)\n\t  {\n\t    __libc_lock_lock (av->mutex);\n\t    fail = (chunksize_nomask (chunk_at_offset (p, size)) <= 2 * SIZE_SZ\n\t\t    || chunksize (chunk_at_offset (p, size)) >= av->system_mem);\n\t    __libc_lock_unlock (av->mutex);\n\t  }\n\n\tif (fail)\n\t  malloc_printerr (\"free(): invalid next size (fast)\");\n      }\n\n    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);\n\n    atomic_store_relaxed (&av->have_fastchunks, true);\n    unsigned int idx = fastbin_index(size);\n    fb = &fastbin (av, idx);\n\n    /* Atomically link P to its fastbin: P->FD = *FB; *FB = P;  */\n    mchunkptr old = *fb, old2;\n\n    if (SINGLE_THREAD_P)\n      {\n\t/* Check that the top of the bin is not the record we are going to\n\t   add (i.e., double free).  */\n\tif (__builtin_expect (old == p, 0))\n\t  malloc_printerr (\"double free or corruption (fasttop)\");\n\tp->fd = old;\n\t*fb = p;\n      }\n    else\n      do\n\t{\n\t  /* Check that the top of the bin is not the record we are going to\n\t     add (i.e., double free).  */\n\t  if (__builtin_expect (old == p, 0))\n\t    malloc_printerr (\"double free or corruption (fasttop)\");\n\t  p->fd = old2 = old;\n\t}\n      while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))\n\t     != old2);\n\n    /* Check that size of fastbin chunk at the top is the same as\n       size of the chunk that we are adding.  We can dereference OLD\n       only if we have the lock, otherwise it might have already been\n       allocated again.  */\n    if (have_lock && old != NULL\n\t&& __builtin_expect (fastbin_index (chunksize (old)) != idx, 0))\n      malloc_printerr (\"invalid fastbin entry (free)\");\n  }\n\n  /*\n    Consolidate other non-mmapped chunks as they arrive.\n  */\n\n  else if (!chunk_is_mmapped(p)) {\n\n    /* If we're single-threaded, don't lock the arena.  */\n    if (SINGLE_THREAD_P)\n      have_lock = true;\n\n    if (!have_lock)\n      __libc_lock_lock (av->mutex);\n\n    nextchunk = chunk_at_offset(p, size);\n\n    /* Lightweight tests: check whether the block is already the\n       top block.  */\n    if (__glibc_unlikely (p == av->top))\n      malloc_printerr (\"double free or corruption (top)\");\n    /* Or whether the next chunk is beyond the boundaries of the arena.  */\n    if (__builtin_expect (contiguous (av)\n\t\t\t  && (char *) nextchunk\n\t\t\t  >= ((char *) av->top + chunksize(av->top)), 0))\n\tmalloc_printerr (\"double free or corruption (out)\");\n    /* Or whether the block is actually not marked used.  */\n    if (__glibc_unlikely (!prev_inuse(nextchunk)))\n      malloc_printerr (\"double free or corruption (!prev)\");\n\n    nextsize = chunksize(nextchunk);\n    if (__builtin_expect (chunksize_nomask (nextchunk) <= 2 * SIZE_SZ, 0)\n\t|| __builtin_expect (nextsize >= av->system_mem, 0))\n      malloc_printerr (\"free(): invalid next size (normal)\");\n\n    free_perturb (chunk2mem(p), size - 2 * SIZE_SZ);\n\n    /* consolidate backward */\n    if (!prev_inuse(p)) {\n      prevsize = prev_size (p);\n      size += prevsize;\n      p = chunk_at_offset(p, -((long) prevsize));\n      if (__glibc_unlikely (chunksize(p) != prevsize))\n        malloc_printerr (\"corrupted size vs. prev_size while consolidating\");\n      unlink(av, p, bck, fwd);\n    }\n\n    if (nextchunk != av->top) {\n      /* get and clear inuse bit */\n      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);\n\n      /* consolidate forward */\n      if (!nextinuse) {\n\tunlink(av, nextchunk, bck, fwd);\n\tsize += nextsize;\n      } else\n\tclear_inuse_bit_at_offset(nextchunk, 0);\n\n      /*\n\tPlace the chunk in unsorted chunk list. Chunks are\n\tnot placed into regular bins until after they have\n\tbeen given one chance to be used in malloc.\n      */\n\n      bck = unsorted_chunks(av);\n      fwd = bck->fd;\n      if (__glibc_unlikely (fwd->bk != bck))\n\tmalloc_printerr (\"free(): corrupted unsorted chunks\");\n      p->fd = fwd;\n      p->bk = bck;\n      if (!in_smallbin_range(size))\n\t{\n\t  p->fd_nextsize = NULL;\n\t  p->bk_nextsize = NULL;\n\t}\n      bck->fd = p;\n      fwd->bk = p;\n\n      set_head(p, size | PREV_INUSE);\n      set_foot(p, size);\n\n      check_free_chunk(av, p);\n    }\n\n    /*\n      If the chunk borders the current high end of memory,\n      consolidate into top\n    */\n\n    else {\n      size += nextsize;\n      set_head(p, size | PREV_INUSE);\n      av->top = p;\n      check_chunk(av, p);\n    }\n\n    /*\n      If freeing a large space, consolidate possibly-surrounding\n      chunks. Then, if the total unused topmost memory exceeds trim\n      threshold, ask malloc_trim to reduce top.\n\n      Unless max_fast is 0, we don't know if there are fastbins\n      bordering top, so we cannot tell for sure whether threshold\n      has been reached unless fastbins are consolidated.  But we\n      don't want to consolidate on each free.  As a compromise,\n      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD\n      is reached.\n    */\n\n    if ((unsigned long)(size) >= FASTBIN_CONSOLIDATION_THRESHOLD) {\n      if (atomic_load_relaxed (&av->have_fastchunks))\n\tmalloc_consolidate(av);\n\n      if (av == &main_arena) {\n#ifndef MORECORE_CANNOT_TRIM\n\tif ((unsigned long)(chunksize(av->top)) >=\n\t    (unsigned long)(mp_.trim_threshold))\n\t  systrim(mp_.top_pad, av);\n#endif\n      } else {\n\t/* Always try heap_trim(), even if the top chunk is not\n\t   large, because the corresponding heap might go away.  */\n\theap_info *heap = heap_for_ptr(top(av));\n\n\tassert(heap->ar_ptr == av);\n\theap_trim(heap, mp_.top_pad);\n      }\n    }\n\n    if (!have_lock)\n      __libc_lock_unlock (av->mutex);\n  }\n  /*\n    If the chunk was allocated via mmap, release via munmap().\n  */\n\n  else {\n    munmap_chunk (p);\n  }\n}\n\n/*\n  ------------------------- malloc_consolidate -------------------------\n\n  malloc_consolidate is a specialized version of free() that tears\n  down chunks held in fastbins.  Free itself cannot be used for this\n  purpose since, among other things, it might place chunks back onto\n  fastbins.  So, instead, we need to use a minor variant of the same\n  code.\n*/\n\nstatic void malloc_consolidate(mstate av)\n{\n  mfastbinptr*    fb;                 /* current fastbin being consolidated */\n  mfastbinptr*    maxfb;              /* last fastbin (for loop control) */\n  mchunkptr       p;                  /* current chunk being consolidated */\n  mchunkptr       nextp;              /* next chunk to consolidate */\n  mchunkptr       unsorted_bin;       /* bin header */\n  mchunkptr       first_unsorted;     /* chunk to link to */\n\n  /* These have same use as in free() */\n  mchunkptr       nextchunk;\n  INTERNAL_SIZE_T size;\n  INTERNAL_SIZE_T nextsize;\n  INTERNAL_SIZE_T prevsize;\n  int             nextinuse;\n  mchunkptr       bck;\n  mchunkptr       fwd;\n\n  atomic_store_relaxed (&av->have_fastchunks, false);\n\n  unsorted_bin = unsorted_chunks(av);\n\n  /*\n    Remove each chunk from fast bin and consolidate it, placing it\n    then in unsorted bin. Among other reasons for doing this,\n    placing in unsorted bin avoids needing to calculate actual bins\n    until malloc is sure that chunks aren't immediately going to be\n    reused anyway.\n  */\n\n  maxfb = &fastbin (av, NFASTBINS - 1);\n  fb = &fastbin (av, 0);\n  do {\n    p = atomic_exchange_acq (fb, NULL);\n    if (p != 0) {\n      do {\n\t{\n\t  unsigned int idx = fastbin_index (chunksize (p));\n\t  if ((&fastbin (av, idx)) != fb)\n\t    malloc_printerr (\"malloc_consolidate(): invalid chunk size\");\n\t}\n\n\tcheck_inuse_chunk(av, p);\n\tnextp = p->fd;\n\n\t/* Slightly streamlined version of consolidation code in free() */\n\tsize = chunksize (p);\n\tnextchunk = chunk_at_offset(p, size);\n\tnextsize = chunksize(nextchunk);\n\n\tif (!prev_inuse(p)) {\n\t  prevsize = prev_size (p);\n\t  size += prevsize;\n\t  p = chunk_at_offset(p, -((long) prevsize));\n\t  if (__glibc_unlikely (chunksize(p) != prevsize))\n\t    malloc_printerr (\"corrupted size vs. prev_size in fastbins\");\n\t  unlink(av, p, bck, fwd);\n\t}\n\n\tif (nextchunk != av->top) {\n\t  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);\n\n\t  if (!nextinuse) {\n\t    size += nextsize;\n\t    unlink(av, nextchunk, bck, fwd);\n\t  } else\n\t    clear_inuse_bit_at_offset(nextchunk, 0);\n\n\t  first_unsorted = unsorted_bin->fd;\n\t  unsorted_bin->fd = p;\n\t  first_unsorted->bk = p;\n\n\t  if (!in_smallbin_range (size)) {\n\t    p->fd_nextsize = NULL;\n\t    p->bk_nextsize = NULL;\n\t  }\n\n\t  set_head(p, size | PREV_INUSE);\n\t  p->bk = unsorted_bin;\n\t  p->fd = first_unsorted;\n\t  set_foot(p, size);\n\t}\n\n\telse {\n\t  size += nextsize;\n\t  set_head(p, size | PREV_INUSE);\n\t  av->top = p;\n\t}\n\n      } while ( (p = nextp) != 0);\n\n    }\n  } while (fb++ != maxfb);\n}\n\n/*\n  ------------------------------ realloc ------------------------------\n*/\n\nvoid*\n_int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize,\n\t     INTERNAL_SIZE_T nb)\n{\n  mchunkptr        newp;            /* chunk to return */\n  INTERNAL_SIZE_T  newsize;         /* its size */\n  void*          newmem;          /* corresponding user mem */\n\n  mchunkptr        next;            /* next contiguous chunk after oldp */\n\n  mchunkptr        remainder;       /* extra space at end of newp */\n  unsigned long    remainder_size;  /* its size */\n\n  mchunkptr        bck;             /* misc temp for linking */\n  mchunkptr        fwd;             /* misc temp for linking */\n\n  unsigned long    copysize;        /* bytes to copy */\n  unsigned int     ncopies;         /* INTERNAL_SIZE_T words to copy */\n  INTERNAL_SIZE_T* s;               /* copy source */\n  INTERNAL_SIZE_T* d;               /* copy destination */\n\n  /* oldmem size */\n  if (__builtin_expect (chunksize_nomask (oldp) <= 2 * SIZE_SZ, 0)\n      || __builtin_expect (oldsize >= av->system_mem, 0))\n    malloc_printerr (\"realloc(): invalid old size\");\n\n  check_inuse_chunk (av, oldp);\n\n  /* All callers already filter out mmap'ed chunks.  */\n  assert (!chunk_is_mmapped (oldp));\n\n  next = chunk_at_offset (oldp, oldsize);\n  INTERNAL_SIZE_T nextsize = chunksize (next);\n  if (__builtin_expect (chunksize_nomask (next) <= 2 * SIZE_SZ, 0)\n      || __builtin_expect (nextsize >= av->system_mem, 0))\n    malloc_printerr (\"realloc(): invalid next size\");\n\n  if ((unsigned long) (oldsize) >= (unsigned long) (nb))\n    {\n      /* already big enough; split below */\n      newp = oldp;\n      newsize = oldsize;\n    }\n\n  else\n    {\n      /* Try to expand forward into top */\n      if (next == av->top &&\n          (unsigned long) (newsize = oldsize + nextsize) >=\n          (unsigned long) (nb + MINSIZE))\n        {\n          set_head_size (oldp, nb | (av != &main_arena ? NON_MAIN_ARENA : 0));\n          av->top = chunk_at_offset (oldp, nb);\n          set_head (av->top, (newsize - nb) | PREV_INUSE);\n          check_inuse_chunk (av, oldp);\n          return chunk2mem (oldp);\n        }\n\n      /* Try to expand forward into next chunk;  split off remainder below */\n      else if (next != av->top &&\n               !inuse (next) &&\n               (unsigned long) (newsize = oldsize + nextsize) >=\n               (unsigned long) (nb))\n        {\n          newp = oldp;\n          unlink (av, next, bck, fwd);\n        }\n\n      /* allocate, copy, free */\n      else\n        {\n          newmem = _int_malloc (av, nb - MALLOC_ALIGN_MASK);\n          if (newmem == 0)\n            return 0; /* propagate failure */\n\n          newp = mem2chunk (newmem);\n          newsize = chunksize (newp);\n\n          /*\n             Avoid copy if newp is next chunk after oldp.\n           */\n          if (newp == next)\n            {\n              newsize += oldsize;\n              newp = oldp;\n            }\n          else\n            {\n              /*\n                 Unroll copy of <= 36 bytes (72 if 8byte sizes)\n                 We know that contents have an odd number of\n                 INTERNAL_SIZE_T-sized words; minimally 3.\n               */\n\n              copysize = oldsize - SIZE_SZ;\n              s = (INTERNAL_SIZE_T *) (chunk2mem (oldp));\n              d = (INTERNAL_SIZE_T *) (newmem);\n              ncopies = copysize / sizeof (INTERNAL_SIZE_T);\n              assert (ncopies >= 3);\n\n              if (ncopies > 9)\n                memcpy (d, s, copysize);\n\n              else\n                {\n                  *(d + 0) = *(s + 0);\n                  *(d + 1) = *(s + 1);\n                  *(d + 2) = *(s + 2);\n                  if (ncopies > 4)\n                    {\n                      *(d + 3) = *(s + 3);\n                      *(d + 4) = *(s + 4);\n                      if (ncopies > 6)\n                        {\n                          *(d + 5) = *(s + 5);\n                          *(d + 6) = *(s + 6);\n                          if (ncopies > 8)\n                            {\n                              *(d + 7) = *(s + 7);\n                              *(d + 8) = *(s + 8);\n                            }\n                        }\n                    }\n                }\n\n              _int_free (av, oldp, 1);\n              check_inuse_chunk (av, newp);\n              return chunk2mem (newp);\n            }\n        }\n    }\n\n  /* If possible, free extra space in old or extended chunk */\n\n  assert ((unsigned long) (newsize) >= (unsigned long) (nb));\n\n  remainder_size = newsize - nb;\n\n  if (remainder_size < MINSIZE)   /* not enough extra to split off */\n    {\n      set_head_size (newp, newsize | (av != &main_arena ? NON_MAIN_ARENA : 0));\n      set_inuse_bit_at_offset (newp, newsize);\n    }\n  else   /* split remainder */\n    {\n      remainder = chunk_at_offset (newp, nb);\n      set_head_size (newp, nb | (av != &main_arena ? NON_MAIN_ARENA : 0));\n      set_head (remainder, remainder_size | PREV_INUSE |\n                (av != &main_arena ? NON_MAIN_ARENA : 0));\n      /* Mark remainder as inuse so free() won't complain */\n      set_inuse_bit_at_offset (remainder, remainder_size);\n      _int_free (av, remainder, 1);\n    }\n\n  check_inuse_chunk (av, newp);\n  return chunk2mem (newp);\n}\n\n/*\n   ------------------------------ memalign ------------------------------\n */\n\nstatic void *\n_int_memalign (mstate av, size_t alignment, size_t bytes)\n{\n  INTERNAL_SIZE_T nb;             /* padded  request size */\n  char *m;                        /* memory returned by malloc call */\n  mchunkptr p;                    /* corresponding chunk */\n  char *brk;                      /* alignment point within p */\n  mchunkptr newp;                 /* chunk to return */\n  INTERNAL_SIZE_T newsize;        /* its size */\n  INTERNAL_SIZE_T leadsize;       /* leading space before alignment point */\n  mchunkptr remainder;            /* spare room at end to split off */\n  unsigned long remainder_size;   /* its size */\n  INTERNAL_SIZE_T size;\n\n\n\n  checked_request2size (bytes, nb);\n\n  /*\n     Strategy: find a spot within that chunk that meets the alignment\n     request, and then possibly free the leading and trailing space.\n   */\n\n\n  /* Check for overflow.  */\n  if (nb > SIZE_MAX - alignment - MINSIZE)\n    {\n      __set_errno (ENOMEM);\n      return 0;\n    }\n\n  /* Call malloc with worst case padding to hit alignment. */\n\n  m = (char *) (_int_malloc (av, nb + alignment + MINSIZE));\n\n  if (m == 0)\n    return 0;           /* propagate failure */\n\n  p = mem2chunk (m);\n\n  if ((((unsigned long) (m)) % alignment) != 0)   /* misaligned */\n\n    { /*\n                Find an aligned spot inside chunk.  Since we need to give back\n                leading space in a chunk of at least MINSIZE, if the first\n                calculation places us at a spot with less than MINSIZE leader,\n                we can move to the next aligned spot -- we've allocated enough\n                total room so that this is always possible.\n                 */\n      brk = (char *) mem2chunk (((unsigned long) (m + alignment - 1)) &\n                                - ((signed long) alignment));\n      if ((unsigned long) (brk - (char *) (p)) < MINSIZE)\n        brk += alignment;\n\n      newp = (mchunkptr) brk;\n      leadsize = brk - (char *) (p);\n      newsize = chunksize (p) - leadsize;\n\n      /* For mmapped chunks, just adjust offset */\n      if (chunk_is_mmapped (p))\n        {\n          set_prev_size (newp, prev_size (p) + leadsize);\n          set_head (newp, newsize | IS_MMAPPED);\n          return chunk2mem (newp);\n        }\n\n      /* Otherwise, give back leader, use the rest */\n      set_head (newp, newsize | PREV_INUSE |\n                (av != &main_arena ? NON_MAIN_ARENA : 0));\n      set_inuse_bit_at_offset (newp, newsize);\n      set_head_size (p, leadsize | (av != &main_arena ? NON_MAIN_ARENA : 0));\n      _int_free (av, p, 1);\n      p = newp;\n\n      assert (newsize >= nb &&\n              (((unsigned long) (chunk2mem (p))) % alignment) == 0);\n    }\n\n  /* Also give back spare room at the end */\n  if (!chunk_is_mmapped (p))\n    {\n      size = chunksize (p);\n      if ((unsigned long) (size) > (unsigned long) (nb + MINSIZE))\n        {\n          remainder_size = size - nb;\n          remainder = chunk_at_offset (p, nb);\n          set_head (remainder, remainder_size | PREV_INUSE |\n                    (av != &main_arena ? NON_MAIN_ARENA : 0));\n          set_head_size (p, nb);\n          _int_free (av, remainder, 1);\n        }\n    }\n\n  check_inuse_chunk (av, p);\n  return chunk2mem (p);\n}\n\n\n/*\n   ------------------------------ malloc_trim ------------------------------\n */\n\nstatic int\nmtrim (mstate av, size_t pad)\n{\n  /* Ensure all blocks are consolidated.  */\n  malloc_consolidate (av);\n\n  const size_t ps = GLRO (dl_pagesize);\n  int psindex = bin_index (ps);\n  const size_t psm1 = ps - 1;\n\n  int result = 0;\n  for (int i = 1; i < NBINS; ++i)\n    if (i == 1 || i >= psindex)\n      {\n        mbinptr bin = bin_at (av, i);\n\n        for (mchunkptr p = last (bin); p != bin; p = p->bk)\n          {\n            INTERNAL_SIZE_T size = chunksize (p);\n\n            if (size > psm1 + sizeof (struct malloc_chunk))\n              {\n                /* See whether the chunk contains at least one unused page.  */\n                char *paligned_mem = (char *) (((uintptr_t) p\n                                                + sizeof (struct malloc_chunk)\n                                                + psm1) & ~psm1);\n\n                assert ((char *) chunk2mem (p) + 4 * SIZE_SZ <= paligned_mem);\n                assert ((char *) p + size > paligned_mem);\n\n                /* This is the size we could potentially free.  */\n                size -= paligned_mem - (char *) p;\n\n                if (size > psm1)\n                  {\n#if MALLOC_DEBUG\n                    /* When debugging we simulate destroying the memory\n                       content.  */\n                    memset (paligned_mem, 0x89, size & ~psm1);\n#endif\n                    __madvise (paligned_mem, size & ~psm1, MADV_DONTNEED);\n\n                    result = 1;\n                  }\n              }\n          }\n      }\n\n#ifndef MORECORE_CANNOT_TRIM\n  return result | (av == &main_arena ? systrim (pad, av) : 0);\n\n#else\n  return result;\n#endif\n}\n\n\nint\n__malloc_trim (size_t s)\n{\n  int result = 0;\n\n  if (__malloc_initialized < 0)\n    ptmalloc_init ();\n\n  mstate ar_ptr = &main_arena;\n  do\n    {\n      __libc_lock_lock (ar_ptr->mutex);\n      result |= mtrim (ar_ptr, s);\n      __libc_lock_unlock (ar_ptr->mutex);\n\n      ar_ptr = ar_ptr->next;\n    }\n  while (ar_ptr != &main_arena);\n\n  return result;\n}\n\n\n/*\n   ------------------------- malloc_usable_size -------------------------\n */\n\nstatic size_t\nmusable (void *mem)\n{\n  mchunkptr p;\n  if (mem != 0)\n    {\n      p = mem2chunk (mem);\n\n      if (__builtin_expect (using_malloc_checking == 1, 0))\n        return malloc_check_get_size (p);\n\n      if (chunk_is_mmapped (p))\n\t{\n\t  if (DUMPED_MAIN_ARENA_CHUNK (p))\n\t    return chunksize (p) - SIZE_SZ;\n\t  else\n\t    return chunksize (p) - 2 * SIZE_SZ;\n\t}\n      else if (inuse (p))\n        return chunksize (p) - SIZE_SZ;\n    }\n  return 0;\n}\n\n\nsize_t\n__malloc_usable_size (void *m)\n{\n  size_t result;\n\n  result = musable (m);\n  return result;\n}\n\n/*\n   ------------------------------ mallinfo ------------------------------\n   Accumulate malloc statistics for arena AV into M.\n */\n\nstatic void\nint_mallinfo (mstate av, struct mallinfo *m)\n{\n  size_t i;\n  mbinptr b;\n  mchunkptr p;\n  INTERNAL_SIZE_T avail;\n  INTERNAL_SIZE_T fastavail;\n  int nblocks;\n  int nfastblocks;\n\n  check_malloc_state (av);\n\n  /* Account for top */\n  avail = chunksize (av->top);\n  nblocks = 1;  /* top always exists */\n\n  /* traverse fastbins */\n  nfastblocks = 0;\n  fastavail = 0;\n\n  for (i = 0; i < NFASTBINS; ++i)\n    {\n      for (p = fastbin (av, i); p != 0; p = p->fd)\n        {\n          ++nfastblocks;\n          fastavail += chunksize (p);\n        }\n    }\n\n  avail += fastavail;\n\n  /* traverse regular bins */\n  for (i = 1; i < NBINS; ++i)\n    {\n      b = bin_at (av, i);\n      for (p = last (b); p != b; p = p->bk)\n        {\n          ++nblocks;\n          avail += chunksize (p);\n        }\n    }\n\n  m->smblks += nfastblocks;\n  m->ordblks += nblocks;\n  m->fordblks += avail;\n  m->uordblks += av->system_mem - avail;\n  m->arena += av->system_mem;\n  m->fsmblks += fastavail;\n  if (av == &main_arena)\n    {\n      m->hblks = mp_.n_mmaps;\n      m->hblkhd = mp_.mmapped_mem;\n      m->usmblks = 0;\n      m->keepcost = chunksize (av->top);\n    }\n}\n\n\nstruct mallinfo\n__libc_mallinfo (void)\n{\n  struct mallinfo m;\n  mstate ar_ptr;\n\n  if (__malloc_initialized < 0)\n    ptmalloc_init ();\n\n  memset (&m, 0, sizeof (m));\n  ar_ptr = &main_arena;\n  do\n    {\n      __libc_lock_lock (ar_ptr->mutex);\n      int_mallinfo (ar_ptr, &m);\n      __libc_lock_unlock (ar_ptr->mutex);\n\n      ar_ptr = ar_ptr->next;\n    }\n  while (ar_ptr != &main_arena);\n\n  return m;\n}\n\n/*\n   ------------------------------ malloc_stats ------------------------------\n */\n\nvoid\n__malloc_stats (void)\n{\n  int i;\n  mstate ar_ptr;\n  unsigned int in_use_b = mp_.mmapped_mem, system_b = in_use_b;\n\n  if (__malloc_initialized < 0)\n    ptmalloc_init ();\n  _IO_flockfile (stderr);\n  int old_flags2 = stderr->_flags2;\n  stderr->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n  for (i = 0, ar_ptr = &main_arena;; i++)\n    {\n      struct mallinfo mi;\n\n      memset (&mi, 0, sizeof (mi));\n      __libc_lock_lock (ar_ptr->mutex);\n      int_mallinfo (ar_ptr, &mi);\n      fprintf (stderr, \"Arena %d:\\n\", i);\n      fprintf (stderr, \"system bytes     = %10u\\n\", (unsigned int) mi.arena);\n      fprintf (stderr, \"in use bytes     = %10u\\n\", (unsigned int) mi.uordblks);\n#if MALLOC_DEBUG > 1\n      if (i > 0)\n        dump_heap (heap_for_ptr (top (ar_ptr)));\n#endif\n      system_b += mi.arena;\n      in_use_b += mi.uordblks;\n      __libc_lock_unlock (ar_ptr->mutex);\n      ar_ptr = ar_ptr->next;\n      if (ar_ptr == &main_arena)\n        break;\n    }\n  fprintf (stderr, \"Total (incl. mmap):\\n\");\n  fprintf (stderr, \"system bytes     = %10u\\n\", system_b);\n  fprintf (stderr, \"in use bytes     = %10u\\n\", in_use_b);\n  fprintf (stderr, \"max mmap regions = %10u\\n\", (unsigned int) mp_.max_n_mmaps);\n  fprintf (stderr, \"max mmap bytes   = %10lu\\n\",\n           (unsigned long) mp_.max_mmapped_mem);\n  stderr->_flags2 = old_flags2;\n  _IO_funlockfile (stderr);\n}\n\n\n/*\n   ------------------------------ mallopt ------------------------------\n */\nstatic inline int\n__always_inline\ndo_set_trim_threshold (size_t value)\n{\n  LIBC_PROBE (memory_mallopt_trim_threshold, 3, value, mp_.trim_threshold,\n\t      mp_.no_dyn_threshold);\n  mp_.trim_threshold = value;\n  mp_.no_dyn_threshold = 1;\n  return 1;\n}\n\nstatic inline int\n__always_inline\ndo_set_top_pad (size_t value)\n{\n  LIBC_PROBE (memory_mallopt_top_pad, 3, value, mp_.top_pad,\n\t      mp_.no_dyn_threshold);\n  mp_.top_pad = value;\n  mp_.no_dyn_threshold = 1;\n  return 1;\n}\n\nstatic inline int\n__always_inline\ndo_set_mmap_threshold (size_t value)\n{\n  /* Forbid setting the threshold too high.  */\n  if (value <= HEAP_MAX_SIZE / 2)\n    {\n      LIBC_PROBE (memory_mallopt_mmap_threshold, 3, value, mp_.mmap_threshold,\n\t\t  mp_.no_dyn_threshold);\n      mp_.mmap_threshold = value;\n      mp_.no_dyn_threshold = 1;\n      return 1;\n    }\n  return 0;\n}\n\nstatic inline int\n__always_inline\ndo_set_mmaps_max (int32_t value)\n{\n  LIBC_PROBE (memory_mallopt_mmap_max, 3, value, mp_.n_mmaps_max,\n\t      mp_.no_dyn_threshold);\n  mp_.n_mmaps_max = value;\n  mp_.no_dyn_threshold = 1;\n  return 1;\n}\n\nstatic inline int\n__always_inline\ndo_set_mallopt_check (int32_t value)\n{\n  return 1;\n}\n\nstatic inline int\n__always_inline\ndo_set_perturb_byte (int32_t value)\n{\n  LIBC_PROBE (memory_mallopt_perturb, 2, value, perturb_byte);\n  perturb_byte = value;\n  return 1;\n}\n\nstatic inline int\n__always_inline\ndo_set_arena_test (size_t value)\n{\n  LIBC_PROBE (memory_mallopt_arena_test, 2, value, mp_.arena_test);\n  mp_.arena_test = value;\n  return 1;\n}\n\nstatic inline int\n__always_inline\ndo_set_arena_max (size_t value)\n{\n  LIBC_PROBE (memory_mallopt_arena_max, 2, value, mp_.arena_max);\n  mp_.arena_max = value;\n  return 1;\n}\n\n#if USE_TCACHE\nstatic inline int\n__always_inline\ndo_set_tcache_max (size_t value)\n{\n  if (value >= 0 && value <= MAX_TCACHE_SIZE)\n    {\n      LIBC_PROBE (memory_tunable_tcache_max_bytes, 2, value, mp_.tcache_max_bytes);\n      mp_.tcache_max_bytes = value;\n      mp_.tcache_bins = csize2tidx (request2size(value)) + 1;\n    }\n  return 1;\n}\n\nstatic inline int\n__always_inline\ndo_set_tcache_count (size_t value)\n{\n  LIBC_PROBE (memory_tunable_tcache_count, 2, value, mp_.tcache_count);\n  mp_.tcache_count = value;\n  return 1;\n}\n\nstatic inline int\n__always_inline\ndo_set_tcache_unsorted_limit (size_t value)\n{\n  LIBC_PROBE (memory_tunable_tcache_unsorted_limit, 2, value, mp_.tcache_unsorted_limit);\n  mp_.tcache_unsorted_limit = value;\n  return 1;\n}\n#endif\n\nint\n__libc_mallopt (int param_number, int value)\n{\n  mstate av = &main_arena;\n  int res = 1;\n\n  if (__malloc_initialized < 0)\n    ptmalloc_init ();\n  __libc_lock_lock (av->mutex);\n\n  LIBC_PROBE (memory_mallopt, 2, param_number, value);\n\n  /* We must consolidate main arena before changing max_fast\n     (see definition of set_max_fast).  */\n  malloc_consolidate (av);\n\n  switch (param_number)\n    {\n    case M_MXFAST:\n      if (value >= 0 && value <= MAX_FAST_SIZE)\n        {\n          LIBC_PROBE (memory_mallopt_mxfast, 2, value, get_max_fast ());\n          set_max_fast (value);\n        }\n      else\n        res = 0;\n      break;\n\n    case M_TRIM_THRESHOLD:\n      do_set_trim_threshold (value);\n      break;\n\n    case M_TOP_PAD:\n      do_set_top_pad (value);\n      break;\n\n    case M_MMAP_THRESHOLD:\n      res = do_set_mmap_threshold (value);\n      break;\n\n    case M_MMAP_MAX:\n      do_set_mmaps_max (value);\n      break;\n\n    case M_CHECK_ACTION:\n      do_set_mallopt_check (value);\n      break;\n\n    case M_PERTURB:\n      do_set_perturb_byte (value);\n      break;\n\n    case M_ARENA_TEST:\n      if (value > 0)\n\tdo_set_arena_test (value);\n      break;\n\n    case M_ARENA_MAX:\n      if (value > 0)\n\tdo_set_arena_max (value);\n      break;\n    }\n  __libc_lock_unlock (av->mutex);\n  return res;\n}\nlibc_hidden_def (__libc_mallopt)\n\n\n/*\n   -------------------- Alternative MORECORE functions --------------------\n */\n\n\n/*\n   General Requirements for MORECORE.\n\n   The MORECORE function must have the following properties:\n\n   If MORECORE_CONTIGUOUS is false:\n\n * MORECORE must allocate in multiples of pagesize. It will\n      only be called with arguments that are multiples of pagesize.\n\n * MORECORE(0) must return an address that is at least\n      MALLOC_ALIGNMENT aligned. (Page-aligning always suffices.)\n\n   else (i.e. If MORECORE_CONTIGUOUS is true):\n\n * Consecutive calls to MORECORE with positive arguments\n      return increasing addresses, indicating that space has been\n      contiguously extended.\n\n * MORECORE need not allocate in multiples of pagesize.\n      Calls to MORECORE need not have args of multiples of pagesize.\n\n * MORECORE need not page-align.\n\n   In either case:\n\n * MORECORE may allocate more memory than requested. (Or even less,\n      but this will generally result in a malloc failure.)\n\n * MORECORE must not allocate memory when given argument zero, but\n      instead return one past the end address of memory from previous\n      nonzero call. This malloc does NOT call MORECORE(0)\n      until at least one call with positive arguments is made, so\n      the initial value returned is not important.\n\n * Even though consecutive calls to MORECORE need not return contiguous\n      addresses, it must be OK for malloc'ed chunks to span multiple\n      regions in those cases where they do happen to be contiguous.\n\n * MORECORE need not handle negative arguments -- it may instead\n      just return MORECORE_FAILURE when given negative arguments.\n      Negative arguments are always multiples of pagesize. MORECORE\n      must not misinterpret negative args as large positive unsigned\n      args. You can suppress all such calls from even occurring by defining\n      MORECORE_CANNOT_TRIM,\n\n   There is some variation across systems about the type of the\n   argument to sbrk/MORECORE. If size_t is unsigned, then it cannot\n   actually be size_t, because sbrk supports negative args, so it is\n   normally the signed type of the same width as size_t (sometimes\n   declared as \"intptr_t\", and sometimes \"ptrdiff_t\").  It doesn't much\n   matter though. Internally, we use \"long\" as arguments, which should\n   work across all reasonable possibilities.\n\n   Additionally, if MORECORE ever returns failure for a positive\n   request, then mmap is used as a noncontiguous system allocator. This\n   is a useful backup strategy for systems with holes in address spaces\n   -- in this case sbrk cannot contiguously expand the heap, but mmap\n   may be able to map noncontiguous space.\n\n   If you'd like mmap to ALWAYS be used, you can define MORECORE to be\n   a function that always returns MORECORE_FAILURE.\n\n   If you are using this malloc with something other than sbrk (or its\n   emulation) to supply memory regions, you probably want to set\n   MORECORE_CONTIGUOUS as false.  As an example, here is a custom\n   allocator kindly contributed for pre-OSX macOS.  It uses virtually\n   but not necessarily physically contiguous non-paged memory (locked\n   in, present and won't get swapped out).  You can use it by\n   uncommenting this section, adding some #includes, and setting up the\n   appropriate defines above:\n\n *#define MORECORE osMoreCore\n *#define MORECORE_CONTIGUOUS 0\n\n   There is also a shutdown routine that should somehow be called for\n   cleanup upon program exit.\n\n *#define MAX_POOL_ENTRIES 100\n *#define MINIMUM_MORECORE_SIZE  (64 * 1024)\n   static int next_os_pool;\n   void *our_os_pools[MAX_POOL_ENTRIES];\n\n   void *osMoreCore(int size)\n   {\n    void *ptr = 0;\n    static void *sbrk_top = 0;\n\n    if (size > 0)\n    {\n      if (size < MINIMUM_MORECORE_SIZE)\n         size = MINIMUM_MORECORE_SIZE;\n      if (CurrentExecutionLevel() == kTaskLevel)\n         ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);\n      if (ptr == 0)\n      {\n        return (void *) MORECORE_FAILURE;\n      }\n      // save ptrs so they can be freed during cleanup\n      our_os_pools[next_os_pool] = ptr;\n      next_os_pool++;\n      ptr = (void *) ((((unsigned long) ptr) + RM_PAGE_MASK) & ~RM_PAGE_MASK);\n      sbrk_top = (char *) ptr + size;\n      return ptr;\n    }\n    else if (size < 0)\n    {\n      // we don't currently support shrink behavior\n      return (void *) MORECORE_FAILURE;\n    }\n    else\n    {\n      return sbrk_top;\n    }\n   }\n\n   // cleanup any allocated memory pools\n   // called as last thing before shutting down driver\n\n   void osCleanupMem(void)\n   {\n    void **ptr;\n\n    for (ptr = our_os_pools; ptr < &our_os_pools[MAX_POOL_ENTRIES]; ptr++)\n      if (*ptr)\n      {\n         PoolDeallocate(*ptr);\n * ptr = 0;\n      }\n   }\n\n */\n\n\n/* Helper code.  */\n\nextern char **__libc_argv attribute_hidden;\n\nstatic void\nmalloc_printerr (const char *str)\n{\n  __libc_message (do_abort, \"%s\\n\", str);\n  __builtin_unreachable ();\n}\n\n/* We need a wrapper function for one of the additions of POSIX.  */\nint\n__posix_memalign (void **memptr, size_t alignment, size_t size)\n{\n  void *mem;\n\n  /* Test whether the SIZE argument is valid.  It must be a power of\n     two multiple of sizeof (void *).  */\n  if (alignment % sizeof (void *) != 0\n      || !powerof2 (alignment / sizeof (void *))\n      || alignment == 0)\n    return EINVAL;\n\n\n  void *address = RETURN_ADDRESS (0);\n  mem = _mid_memalign (alignment, size, address);\n\n  if (mem != NULL)\n    {\n      *memptr = mem;\n      return 0;\n    }\n\n  return ENOMEM;\n}\nweak_alias (__posix_memalign, posix_memalign)\n\n\nint\n__malloc_info (int options, FILE *fp)\n{\n  /* For now, at least.  */\n  if (options != 0)\n    return EINVAL;\n\n  int n = 0;\n  size_t total_nblocks = 0;\n  size_t total_nfastblocks = 0;\n  size_t total_avail = 0;\n  size_t total_fastavail = 0;\n  size_t total_system = 0;\n  size_t total_max_system = 0;\n  size_t total_aspace = 0;\n  size_t total_aspace_mprotect = 0;\n\n\n\n  if (__malloc_initialized < 0)\n    ptmalloc_init ();\n\n  fputs (\"<malloc version=\\\"1\\\">\\n\", fp);\n\n  /* Iterate over all arenas currently in use.  */\n  mstate ar_ptr = &main_arena;\n  do\n    {\n      fprintf (fp, \"<heap nr=\\\"%d\\\">\\n<sizes>\\n\", n++);\n\n      size_t nblocks = 0;\n      size_t nfastblocks = 0;\n      size_t avail = 0;\n      size_t fastavail = 0;\n      struct\n      {\n\tsize_t from;\n\tsize_t to;\n\tsize_t total;\n\tsize_t count;\n      } sizes[NFASTBINS + NBINS - 1];\n#define nsizes (sizeof (sizes) / sizeof (sizes[0]))\n\n      __libc_lock_lock (ar_ptr->mutex);\n\n      for (size_t i = 0; i < NFASTBINS; ++i)\n\t{\n\t  mchunkptr p = fastbin (ar_ptr, i);\n\t  if (p != NULL)\n\t    {\n\t      size_t nthissize = 0;\n\t      size_t thissize = chunksize (p);\n\n\t      while (p != NULL)\n\t\t{\n\t\t  ++nthissize;\n\t\t  p = p->fd;\n\t\t}\n\n\t      fastavail += nthissize * thissize;\n\t      nfastblocks += nthissize;\n\t      sizes[i].from = thissize - (MALLOC_ALIGNMENT - 1);\n\t      sizes[i].to = thissize;\n\t      sizes[i].count = nthissize;\n\t    }\n\t  else\n\t    sizes[i].from = sizes[i].to = sizes[i].count = 0;\n\n\t  sizes[i].total = sizes[i].count * sizes[i].to;\n\t}\n\n\n      mbinptr bin;\n      struct malloc_chunk *r;\n\n      for (size_t i = 1; i < NBINS; ++i)\n\t{\n\t  bin = bin_at (ar_ptr, i);\n\t  r = bin->fd;\n\t  sizes[NFASTBINS - 1 + i].from = ~((size_t) 0);\n\t  sizes[NFASTBINS - 1 + i].to = sizes[NFASTBINS - 1 + i].total\n\t\t\t\t\t  = sizes[NFASTBINS - 1 + i].count = 0;\n\n\t  if (r != NULL)\n\t    while (r != bin)\n\t      {\n\t\tsize_t r_size = chunksize_nomask (r);\n\t\t++sizes[NFASTBINS - 1 + i].count;\n\t\tsizes[NFASTBINS - 1 + i].total += r_size;\n\t\tsizes[NFASTBINS - 1 + i].from\n\t\t  = MIN (sizes[NFASTBINS - 1 + i].from, r_size);\n\t\tsizes[NFASTBINS - 1 + i].to = MAX (sizes[NFASTBINS - 1 + i].to,\n\t\t\t\t\t\t   r_size);\n\n\t\tr = r->fd;\n\t      }\n\n\t  if (sizes[NFASTBINS - 1 + i].count == 0)\n\t    sizes[NFASTBINS - 1 + i].from = 0;\n\t  nblocks += sizes[NFASTBINS - 1 + i].count;\n\t  avail += sizes[NFASTBINS - 1 + i].total;\n\t}\n\n      size_t heap_size = 0;\n      size_t heap_mprotect_size = 0;\n      size_t heap_count = 0;\n      if (ar_ptr != &main_arena)\n\t{\n\t  /* Iterate over the arena heaps from back to front.  */\n\t  heap_info *heap = heap_for_ptr (top (ar_ptr));\n\t  do\n\t    {\n\t      heap_size += heap->size;\n\t      heap_mprotect_size += heap->mprotect_size;\n\t      heap = heap->prev;\n\t      ++heap_count;\n\t    }\n\t  while (heap != NULL);\n\t}\n\n      __libc_lock_unlock (ar_ptr->mutex);\n\n      total_nfastblocks += nfastblocks;\n      total_fastavail += fastavail;\n\n      total_nblocks += nblocks;\n      total_avail += avail;\n\n      for (size_t i = 0; i < nsizes; ++i)\n\tif (sizes[i].count != 0 && i != NFASTBINS)\n\t  fprintf (fp, \"\t\t\t\t\t\t\t      \\\n  <size from=\\\"%zu\\\" to=\\\"%zu\\\" total=\\\"%zu\\\" count=\\\"%zu\\\"/>\\n\",\n\t\t   sizes[i].from, sizes[i].to, sizes[i].total, sizes[i].count);\n\n      if (sizes[NFASTBINS].count != 0)\n\tfprintf (fp, \"\\\n  <unsorted from=\\\"%zu\\\" to=\\\"%zu\\\" total=\\\"%zu\\\" count=\\\"%zu\\\"/>\\n\",\n\t\t sizes[NFASTBINS].from, sizes[NFASTBINS].to,\n\t\t sizes[NFASTBINS].total, sizes[NFASTBINS].count);\n\n      total_system += ar_ptr->system_mem;\n      total_max_system += ar_ptr->max_system_mem;\n\n      fprintf (fp,\n\t       \"</sizes>\\n<total type=\\\"fast\\\" count=\\\"%zu\\\" size=\\\"%zu\\\"/>\\n\"\n\t       \"<total type=\\\"rest\\\" count=\\\"%zu\\\" size=\\\"%zu\\\"/>\\n\"\n\t       \"<system type=\\\"current\\\" size=\\\"%zu\\\"/>\\n\"\n\t       \"<system type=\\\"max\\\" size=\\\"%zu\\\"/>\\n\",\n\t       nfastblocks, fastavail, nblocks, avail,\n\t       ar_ptr->system_mem, ar_ptr->max_system_mem);\n\n      if (ar_ptr != &main_arena)\n\t{\n\t  fprintf (fp,\n\t\t   \"<aspace type=\\\"total\\\" size=\\\"%zu\\\"/>\\n\"\n\t\t   \"<aspace type=\\\"mprotect\\\" size=\\\"%zu\\\"/>\\n\"\n\t\t   \"<aspace type=\\\"subheaps\\\" size=\\\"%zu\\\"/>\\n\",\n\t\t   heap_size, heap_mprotect_size, heap_count);\n\t  total_aspace += heap_size;\n\t  total_aspace_mprotect += heap_mprotect_size;\n\t}\n      else\n\t{\n\t  fprintf (fp,\n\t\t   \"<aspace type=\\\"total\\\" size=\\\"%zu\\\"/>\\n\"\n\t\t   \"<aspace type=\\\"mprotect\\\" size=\\\"%zu\\\"/>\\n\",\n\t\t   ar_ptr->system_mem, ar_ptr->system_mem);\n\t  total_aspace += ar_ptr->system_mem;\n\t  total_aspace_mprotect += ar_ptr->system_mem;\n\t}\n\n      fputs (\"</heap>\\n\", fp);\n      ar_ptr = ar_ptr->next;\n    }\n  while (ar_ptr != &main_arena);\n\n  fprintf (fp,\n\t   \"<total type=\\\"fast\\\" count=\\\"%zu\\\" size=\\\"%zu\\\"/>\\n\"\n\t   \"<total type=\\\"rest\\\" count=\\\"%zu\\\" size=\\\"%zu\\\"/>\\n\"\n\t   \"<total type=\\\"mmap\\\" count=\\\"%d\\\" size=\\\"%zu\\\"/>\\n\"\n\t   \"<system type=\\\"current\\\" size=\\\"%zu\\\"/>\\n\"\n\t   \"<system type=\\\"max\\\" size=\\\"%zu\\\"/>\\n\"\n\t   \"<aspace type=\\\"total\\\" size=\\\"%zu\\\"/>\\n\"\n\t   \"<aspace type=\\\"mprotect\\\" size=\\\"%zu\\\"/>\\n\"\n\t   \"</malloc>\\n\",\n\t   total_nfastblocks, total_fastavail, total_nblocks, total_avail,\n\t   mp_.n_mmaps, mp_.mmapped_mem,\n\t   total_system, total_max_system,\n\t   total_aspace, total_aspace_mprotect);\n\n  return 0;\n}\nweak_alias (__malloc_info, malloc_info)\n\n\nstrong_alias (__libc_calloc, __calloc) weak_alias (__libc_calloc, calloc)\nstrong_alias (__libc_free, __free) strong_alias (__libc_free, free)\nstrong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, malloc)\nstrong_alias (__libc_memalign, __memalign)\nweak_alias (__libc_memalign, memalign)\nstrong_alias (__libc_realloc, __realloc) strong_alias (__libc_realloc, realloc)\nstrong_alias (__libc_valloc, __valloc) weak_alias (__libc_valloc, valloc)\nstrong_alias (__libc_pvalloc, __pvalloc) weak_alias (__libc_pvalloc, pvalloc)\nstrong_alias (__libc_mallinfo, __mallinfo)\nweak_alias (__libc_mallinfo, mallinfo)\nstrong_alias (__libc_mallopt, __mallopt) weak_alias (__libc_mallopt, mallopt)\n\nweak_alias (__malloc_stats, malloc_stats)\nweak_alias (__malloc_usable_size, malloc_usable_size)\nweak_alias (__malloc_trim, malloc_trim)\n\n#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_26)\ncompat_symbol (libc, __libc_free, cfree, GLIBC_2_0);\n#endif\n\n/* ------------------------------------------------------------\n   History:\n\n   [see ftp://g.oswego.edu/pub/misc/malloc.c for the history of dlmalloc]\n\n */\n/*\n * Local variables:\n * c-basic-offset: 2\n * End:\n */\n"}}, "reports": [{"events": [{"location": {"line": 272, "col": 7, "file": 1}, "message": "Assuming the condition is false"}, {"location": {"line": 277, "col": 7, "file": 1}, "message": "Assuming 'oldmem' is not equal to null"}, {"location": {"line": 280, "col": 7, "file": 1}, "message": "Assuming 'bytes' is not equal to 0"}, {"location": {"line": 285, "col": 3, "file": 1}, "message": "Assuming the condition is true"}, {"location": {"line": 286, "col": 26, "file": 1}, "message": "Calling 'mem2chunk_check'"}, {"location": {"line": 147, "col": 1, "file": 1}, "message": "Entered call from 'realloc_check'"}, {"location": {"line": 159, "col": 11, "file": 1}, "message": "Calling 'magicbyte'"}, {"location": {"line": 71, "col": 1, "file": 1}, "message": "Entered call from 'mem2chunk_check'"}, {"location": {"line": 78, "col": 7, "file": 1}, "message": "Assuming 'magic' is not equal to 1"}, {"location": {"line": 159, "col": 11, "file": 1}, "message": "Returning from 'magicbyte'"}, {"location": {"line": 160, "col": 7, "file": 1}, "message": "Assuming the condition is false"}, {"location": {"line": 187, "col": 12, "file": 1}, "message": "Assuming the condition is false"}, {"location": {"line": 191, "col": 36, "file": 1}, "message": "Assuming the condition is false"}, {"location": {"line": 196, "col": 21, "file": 1}, "message": "Loop body executed 0 times"}, {"location": {"line": 204, "col": 5, "file": 1}, "message": "Value assigned to 'magic_p'"}, {"location": {"line": 286, "col": 26, "file": 1}, "message": "Returning from 'mem2chunk_check'"}, {"location": {"line": 287, "col": 3, "file": 1}, "message": "Assuming the condition is true"}, {"location": {"line": 292, "col": 3, "file": 1}, "message": "Assuming the condition is false"}, {"location": {"line": 292, "col": 3, "file": 1}, "message": "Assuming the condition is false"}, {"location": {"line": 293, "col": 3, "file": 1}, "message": "Assuming the condition is true"}, {"location": {"line": 337, "col": 7, "file": 1}, "message": "Assuming 'newmem' is equal to NULL"}, {"location": {"line": 338, "col": 14, "file": 1}, "message": "Dereference of null pointer (loaded from variable 'magic_p')"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/malloc/hooks.c", "reportHash": "f5a99eada4b5217ce9b5434d494c0e64", "checkerName": "core.NullDereference", "reviewStatus": null, "severity": "HIGH"}, {"events": [{"location": {"line": 2563, "col": 15, "file": 2}, "message": "Value stored to 'front_misalign' is never read"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/malloc/malloc.c", "reportHash": "502eae5aadce83c3d2501ac9e0706ef3", "checkerName": "deadcode.DeadStores", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"line": 2564, "col": 15, "file": 2}, "message": "Value stored to 'end_misalign' is never read"}], "macros": [], "notes": [], "path": "/media/lavo07/lavo07/glibc/malloc/malloc.c", "reportHash": "516160b5ae866a54220222c3c90a585c", "checkerName": "deadcode.DeadStores", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
